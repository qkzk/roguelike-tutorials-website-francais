<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8">
<meta http-equiv="x-ua-compatible" content="ie=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

<meta property="og:title" content="Partie 2 - Une entité générique, les fonctions de rendu et la carte]" />
<meta property="og:description" content="Maintenant que l&rsquo;on peut déplacer notre petit symbole &ldquo;@&rdquo;, on doit lui donner un cadre. Mais avant ça pensons un instant à l&rsquo;objet joueur lui même.
Pour l&rsquo;instant, nous représentons simplement le joueur avec un &lsquo;@&rsquo; et ses coordonnées x et y. On devrait regrouper ces éléments dans un objet avec d&rsquo;autres données et des fonctions qui lui correspondent.
Créons une classe générique qui représente non seulement le joueur mais aussi tous les éléments de notre monde de jeu." />
<meta property="og:type" content="article" />
<meta property="og:url" content="/tutoriels/tcod/part-2/" />
<meta property="article:published_time" content="2019-03-30T08:39:20-07:00"/>
<meta property="article:modified_time" content="2019-03-30T08:39:20-07:00"/>

<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Partie 2 - Une entité générique, les fonctions de rendu et la carte]"/>
<meta name="twitter:description" content="Maintenant que l&rsquo;on peut déplacer notre petit symbole &ldquo;@&rdquo;, on doit lui donner un cadre. Mais avant ça pensons un instant à l&rsquo;objet joueur lui même.
Pour l&rsquo;instant, nous représentons simplement le joueur avec un &lsquo;@&rsquo; et ses coordonnées x et y. On devrait regrouper ces éléments dans un objet avec d&rsquo;autres données et des fonctions qui lui correspondent.
Créons une classe générique qui représente non seulement le joueur mais aussi tous les éléments de notre monde de jeu."/>



    <link rel="canonical" href="/tutoriels/tcod/part-2/">

    <title>
      
        Partie 2 - Une entité générique, les fonctions de rendu et la carte] | Tutoriel Roguelike
      
    </title>

    
    <link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.1.3/css/bootstrap.min.css" integrity="sha384-MCw98/SFnGE8fJT3GXwEOngsV7Zt27NXFoaoApmYm81iuXoPkFOJwJ8ERdknLPMO" crossorigin="anonymous">
    <link href="/css/style.css" rel="stylesheet">

    

    

    
  </head>
  <body>
    
      

<header class="blog-header">
    <nav class="navbar navbar-expand-md navbar-dark bg-dark">
        <a class="navbar-brand" href="/">
            Tutoriel Roguelike
        </a>
        <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNav" aria-controls="navbarNav" aria-expanded="false"
            aria-label="Toggle navigation">
            <span class="navbar-toggler-icon"></span>
        </button>
        <div class="collapse navbar-collapse justify-content-between" id="navbarNav">
            <ul class="navbar-nav">
                
                
                <li class="nav-item ">
                    
                        <a class="nav-link" href="/">Home</a>
                    
                </li>
                
                <li class="nav-item ">
                    
                        <a class="nav-link" href="/tutoriels/tcod/">Tutoriel TCOD</a>
                    
                </li>
                
                <li class="nav-item ">
                    
                        <a class="nav-link" href="/about/">A propos</a>
                    
                </li>
                
            </ul>
            
        </div>
    </nav>
</header>

    

    
    <div class="container">
      <div class="row">
        <div class="col-12 col-lg-8 blog-main">

          

<header>
    <h2 class="blog-post-title">
    <a class="text-dark" href="/tutoriels/tcod/part-2/">Partie 2 - Une entité générique, les fonctions de rendu et la carte]</a>
</h2>

    


<div class="blog-post-date text-secondary">
    
        <time datetime="2019-03-30">Mar 30, 2019</time>
    
    
</div>

    
    
    <hr>
</header>
<article class="blog-post">
    <p>Maintenant que l&rsquo;on peut déplacer notre petit symbole &ldquo;@&rdquo;, on doit lui donner un
<em>cadre</em>. Mais avant ça pensons un instant à l&rsquo;objet joueur lui même.</p>

<p>Pour l&rsquo;instant, nous représentons simplement le joueur avec un &lsquo;@&rsquo; et ses
coordonnées x et y. On devrait regrouper ces éléments dans un objet avec
d&rsquo;autres données et des fonctions qui lui correspondent.</p>

<p>Créons une classe générique qui représente non seulement le joueur mais aussi
<em>tous les éléments</em> de notre monde de jeu. Ennemis, items et tout autre entité
à laquelle on pourrait penser feront parties de cette classe qui s&rsquo;appellera
<code>Entity</code>.</p>

<p>Créez un nouveau fichier et nommez le <code>entity.py</code>. Dans ce fichier, ajouter la
classe suivante :</p>

<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-py3" data-lang="py3"><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Entity</span>:
    <span style="color:#e6db74">&#34;&#34;&#34;
</span><span style="color:#e6db74">    A generic object to represent players, enemies, items, etc.
</span><span style="color:#e6db74">    &#34;&#34;&#34;</span>
    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">__init__</span>(self, x, y, char, color):
        self<span style="color:#f92672">.</span>x <span style="color:#f92672">=</span> x
        self<span style="color:#f92672">.</span>y <span style="color:#f92672">=</span> y
        self<span style="color:#f92672">.</span>char <span style="color:#f92672">=</span> char
        self<span style="color:#f92672">.</span>color <span style="color:#f92672">=</span> color

    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">move</span>(self, dx, dy):
        <span style="color:#75715e"># Move the entity by a given amount</span>
        self<span style="color:#f92672">.</span>x <span style="color:#f92672">+=</span> dx
        self<span style="color:#f92672">.</span>y <span style="color:#f92672">+=</span> dy</code></pre></div>

<p>C&rsquo;est plutôt explicite. La classe <code>Entity</code> qui contient les coordonnées x et y
ainsi que le caractère (le symbole <code>@</code> en ce qui concerne le joueur) et la
couleur (blanche par défaut pour le joueur). Nous avons aussi une méthode
appelée <code>move</code> qui permettra à l&rsquo;entité d&rsquo;être déplacée selon des coordonnées
x et y données.</p>

<p>Mettons cette nouvelle classe en action ! Modifiez la première partie de
<code>engine.py</code> pour qu&rsquo;elle ressemble à ceci :</p>

<div>
  <button class="btn btn-primary data-toggle-tab active" data-toggle-tab="diff">
    Diff
  </button>
  <button class="btn btn-secondary data-toggle-tab" data-toggle-tab="original">
    Original
  </button>

  
<div class="data-pane active" data-pane="diff">
  
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-diff" data-lang="diff">import tcod as libtcod

<span style="color:#a6e22e">+from entity import Entity
</span><span style="color:#a6e22e"></span>from input_handlers import handle_keys


def main():
    screen_width = 80
    screen_height = 50

<span style="color:#f92672">-   player_x = int(screen_width / 2)
</span><span style="color:#f92672">-   player_y = int(screen_height / 2)
</span><span style="color:#f92672"></span>
<span style="color:#a6e22e">+   player = Entity(int(screen_width / 2), int(screen_height / 2), &#39;@&#39;, libtcod.white)
</span><span style="color:#a6e22e">+   npc = Entity(int(screen_width / 2 - 5), int(screen_height / 2), &#39;@&#39;, libtcod.yellow)
</span><span style="color:#a6e22e">+   entities = [npc, player]
</span><span style="color:#a6e22e"></span>    ...
</code></pre></div>

</div>
<div class="data-pane" data-pane="original">
  
<pre>import tcod as libtcod

<span class="new-text">from entity import Entity</span>
from input_handlers import handle_keys


def main():
    screen_width = 80
    screen_height = 50

    <span class="crossed-out-text">player_x = int(screen_width / 2)</span>
    <span class="crossed-out-text">player_y = int(screen_height / 2)</span>

    <span class="new-text">player = Entity(int(screen_width / 2), int(screen_height / 2), '@', libtcod.white)
    npc = Entity(int(screen_width / 2 - 5), int(screen_height / 2), '@', libtcod.yellow)
    entities = [npc, player]</span>
    ...</pre>

</div>

</div>


<p>On importe la classe <code>Entity</code> dans <code>engine.py</code> et on l&rsquo;emploie pour initialiser
le joueur et un nouveau NPC. On range ces éléments dans une liste qui contiendra
toutes les entités sur la carte.</p>

<p>Modifiez aussi la partie qui gère le mouvement de façon à ce que ce soit la
classe Entity qui s&rsquo;en occupe.</p>

<div>
  <button class="btn btn-primary data-toggle-tab active" data-toggle-tab="diff">
    Diff
  </button>
  <button class="btn btn-secondary data-toggle-tab" data-toggle-tab="original">
    Original
  </button>

  
<div class="data-pane active" data-pane="diff">
  
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-diff" data-lang="diff">        if move:
            dx, dy = move
<span style="color:#f92672">-           player_x += dx
</span><span style="color:#f92672">-           player_x += dy
</span><span style="color:#f92672"></span><span style="color:#a6e22e">+           player.move(dx, dy)
</span></code></pre></div>

</div>
<div class="data-pane" data-pane="original">
  
<pre>        if move:
            dx, dy = move
            <span class="crossed-out-text">player_x += dx</span>
            <span class="crossed-out-text">player_x += dy</span>
            <span class="new-text">player.move(dx, dy)</span></pre>

</div>

</div>


<p>Enfin, mettez à jour les fonctions de dessin pour utiliser le nouvel objet
joueur.</p>

<div>
  <button class="btn btn-primary data-toggle-tab active" data-toggle-tab="diff">
    Diff
  </button>
  <button class="btn btn-secondary data-toggle-tab" data-toggle-tab="original">
    Original
  </button>

  
<div class="data-pane active" data-pane="diff">
  
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-diff" data-lang="diff">    while not libtcod.console_is_window_closed():
        libtcod.sys_check_for_event(libtcod.EVENT_KEY_PRESS, key, mouse)

        libtcod.console_set_default_foreground(con, libtcod.white)
<span style="color:#f92672">-       libtcod.console_put_char(con, player_x, player_y, &#39;@&#39;, libtcod.BKGND_NONE)
</span><span style="color:#f92672"></span><span style="color:#a6e22e">+       libtcod.console_put_char(con, player.x, player.y, &#39;@&#39;, libtcod.BKGND_NONE)
</span><span style="color:#a6e22e"></span>        libtcod.console_blit(con, 0, 0, screen_width, screen_height, 0, 0, 0)
        libtcod.console_set_default_foreground(0, libtcod.white)
<span style="color:#f92672">-       libtcod.console_put_char(0, player_x, player_y, &#39;@&#39;, libtcod.BKGND_NONE)
</span><span style="color:#f92672"></span><span style="color:#a6e22e">+       libtcod.console_put_char(0, player.x, player.y, &#39;@&#39;, libtcod.BKGND_NONE)
</span><span style="color:#a6e22e"></span>        libtcod.console_flush()

<span style="color:#f92672">-       libtcod.console_put_char(con, player_x, player_y, &#39; &#39;, libtcod.BKGND_NONE)
</span><span style="color:#f92672">-       libtcod.console_put_char(0, player_x, player_y, &#39; &#39;, libtcod.BKGND_NONE)
</span><span style="color:#f92672"></span><span style="color:#a6e22e">+       libtcod.console_put_char(con, player.x, player.y, &#39; &#39;, libtcod.BKGND_NONE)
</span><span style="color:#a6e22e">+       libtcod.console_put_char(0, player.x, player.y, &#39; &#39;, libtcod.BKGND_NONE)
</span><span style="color:#a6e22e"></span>
        action = handle_keys(key)
</code></pre></div>

</div>
<div class="data-pane" data-pane="original">
  
<pre>    while not libtcod.console_is_window_closed():
        libtcod.sys_check_for_event(libtcod.EVENT_KEY_PRESS, key, mouse)

        libtcod.console_set_default_foreground(con, libtcod.white)
        <span class="crossed-out-text">libtcod.console_put_char(con, player_x, player_y, '@', libtcod.BKGND_NONE)</span>
        <span class="new-text">libtcod.console_put_char(con, player.x, player.y, '@', libtcod.BKGND_NONE)</span>
        libtcod.console_blit(con, 0, 0, screen_width, screen_height, 0, 0, 0)
        libtcod.console_set_default_foreground(0, libtcod.white)
        <span class="crossed-out-text">libtcod.console_put_char(0, player_x, player_y, '@', libtcod.BKGND_NONE)</span>
        <span class="new-text">libtcod.console_put_char(0, player.x, player.y, '@', libtcod.BKGND_NONE)</span>
        libtcod.console_flush()

        <span class="crossed-out-text">libtcod.console_put_char(con, player_x, player_y, ' ', libtcod.BKGND_NONE)</span>
        <span class="crossed-out-text">libtcod.console_put_char(0, player_x, player_y, ' ', libtcod.BKGND_NONE)</span>
        <span class="new-text">libtcod.console_put_char(con, player.x, player.y, ' ', libtcod.BKGND_NONE)</span>
        <span class="new-text">libtcod.console_put_char(0, player.x, player.y, ' ', libtcod.BKGND_NONE)</span>

        action = handle_keys(key)
    </pre>

</div>

</div>


<p>On doit modifier la manière dont l&rsquo;entité est dessinée à l&rsquo;écran. Si vous
exécutez le code maintenant, seul le joueur est dessiné. Ecrivons quelques
fonctions qui dessinent à la fois le joueur mais aussi toute entité de la liste
des entités.</p>

<p>Créez un nouveau fichier appelé <code>render_functions.py</code>. Il contiendra nos
fonctions de dessin et une fonction nettoyant l&rsquo;écran. Ajoutez le code suivant
dans ce fichier.</p>

<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-py3" data-lang="py3"><span style="color:#f92672">import</span> tcod <span style="color:#66d9ef">as</span> libtcod


<span style="color:#66d9ef">def</span> <span style="color:#a6e22e">render_all</span>(con, entities, screen_width, screen_height):
    <span style="color:#75715e"># Draw all entities in the list</span>
    <span style="color:#66d9ef">for</span> entity <span style="color:#f92672">in</span> entities:
        draw_entity(con, entity)

    libtcod<span style="color:#f92672">.</span>console_blit(con, <span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">0</span>, screen_width, screen_height, <span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">0</span>)


<span style="color:#66d9ef">def</span> <span style="color:#a6e22e">clear_all</span>(con, entities):
    <span style="color:#66d9ef">for</span> entity <span style="color:#f92672">in</span> entities:
        clear_entity(con, entity)


<span style="color:#66d9ef">def</span> <span style="color:#a6e22e">draw_entity</span>(con, entity):
    libtcod<span style="color:#f92672">.</span>console_set_default_foreground(con, entity<span style="color:#f92672">.</span>color)
    libtcod<span style="color:#f92672">.</span>console_put_char(con, entity<span style="color:#f92672">.</span>x, entity<span style="color:#f92672">.</span>y, entity<span style="color:#f92672">.</span>char, libtcod<span style="color:#f92672">.</span>BKGND_NONE)


<span style="color:#66d9ef">def</span> <span style="color:#a6e22e">clear_entity</span>(con, entity):
    <span style="color:#75715e"># erase the character that represents this object</span>
    libtcod<span style="color:#f92672">.</span>console_put_char(con, entity<span style="color:#f92672">.</span>x, entity<span style="color:#f92672">.</span>y, <span style="color:#e6db74">&#39; &#39;</span>, libtcod<span style="color:#f92672">.</span>BKGND_NONE)</code></pre></div>

<p>Voici un découpage rapide de ce que font ces fonctions :</p>

<ul>
<li>La fonction <code>render_all</code> est celle qui sera appelée de notre boucle de
jeu pour dessiner les entités et, dans un instant, la carte. Pour l&rsquo;instant
elle prend la console (con), une liste d&rsquo;entité et les dimensions
(hauteur/largeur) de l&rsquo;écran en paramètres et elle appelle la fonction
<code>draw_entity</code> sur chaque élément. Ensuite elle colle (blit) les changements
à l&rsquo;écran.</li>
<li><code>draw_entity</code> est ce qui réalise vraiment le dessin. Le code devrait être
très proche de ce qui est dans notre boucle de jeu actuellement à ceci près
qu&rsquo;elle utilise les variables de l&rsquo;entité (x, y, char et color) pour faire
le dessin. Cela est assez flexible en théorie pour dessiner n&rsquo;importe quelle
entité qu&rsquo;on lui donne.</li>
<li><code>clear_all</code> et ce qu&rsquo;on utilisera pour nettoyer les entités après les avoir
dessinées à l&rsquo;écran. C&rsquo;est simplement une boucle qui appelle une autre
fonction.</li>
<li><code>clear_entity</code> est justement cette fonction. Elle nettoie les entités de
l&rsquo;écran (de façon à ce qu&rsquo;elle bouge sans laisser une trace derrière elle).</li>
</ul>

<p>Maitenant qu&rsquo;on a quelques fonctions pour nous aider à dessiner les entités
mettons les en action. Réalisez les modifications dans la partie où le joueur
est dessiné dans <code>engine.py</code></p>

<div>
  <button class="btn btn-primary data-toggle-tab active" data-toggle-tab="diff">
    Diff
  </button>
  <button class="btn btn-secondary data-toggle-tab" data-toggle-tab="original">
    Original
  </button>

  
<div class="data-pane active" data-pane="diff">
  
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-diff" data-lang="diff">        ...
    libtcod.sys_check_for_event(libtcod.EVENT_KEY_PRESS, key, mouse)

<span style="color:#f92672">-   libtcod.console_set_default_foreground(con, libtcod.white)
</span><span style="color:#f92672">-   libtcod.console_put_char(con, player.x, player.y, &#39;@&#39;, libtcod.BKGND_NONE)
</span><span style="color:#f92672">-   libtcod.console_blit(con, 0, 0, screen_width, screen_height, 0, 0, 0)
</span><span style="color:#f92672"></span><span style="color:#a6e22e">+   render_all(con, entities, screen_width, screen_height)
</span><span style="color:#a6e22e"></span>
    libtcod.console_flush()

<span style="color:#f92672">-   libtcod.console_put_char(con, player.x, player.y, &#39; &#39;, libtcod.BKGND_NONE)
</span><span style="color:#f92672"></span><span style="color:#a6e22e">+   clear_all(con, entities)
</span><span style="color:#a6e22e"></span>
    action = handle_keys(key)
    ...
</code></pre></div>

</div>
<div class="data-pane" data-pane="original">
  
<pre>        ...
    libtcod.sys_check_for_event(libtcod.EVENT_KEY_PRESS, key, mouse)

    <span class="crossed-out-text">libtcod.console_set_default_foreground(con, libtcod.white)</span>
    <span class="crossed-out-text">libtcod.console_put_char(con, player.x, player.y, '@', libtcod.BKGND_NONE)</span>
    <span class="crossed-out-text">libtcod.console_blit(con, 0, 0, screen_width, screen_height, 0, 0, 0)</span>
    <span class="new-text">render_all(con, entities, screen_width, screen_height)</span>

    libtcod.console_flush()

    <span class="crossed-out-text">libtcod.console_put_char(con, player.x, player.y, ' ', libtcod.BKGND_NONE)</span>
    <span class="new-text">clear_all(con, entities)</span>

    action = handle_keys(key)
    ...</pre>

</div>

</div>


<p>N&rsquo;oubliez pas d&rsquo;importez <code>render_all</code> et <code>clear_all</code> en haut de votre fichier.
Votre partie d&rsquo;imports devrait ressemble à quelque chose comme cela :</p>

<div>
  <button class="btn btn-primary data-toggle-tab active" data-toggle-tab="diff">
    Diff
  </button>
  <button class="btn btn-secondary data-toggle-tab" data-toggle-tab="original">
    Original
  </button>

  
<div class="data-pane active" data-pane="diff">
  
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-diff" data-lang="diff">import tcod as libtcod

from entity import Entity
from input_handlers import handle_keys
<span style="color:#a6e22e">+from render_functions import clear_all, render_all
</span></code></pre></div>

</div>
<div class="data-pane" data-pane="original">
  
<pre>import tcod as libtcod

from entity import Entity
from input_handlers import handle_keys
<span class="new-text">from render_functions import clear_all, render_all</span></pre>

</div>

</div>


<p>Si vous exécutez le projet maintenant, vous devriez voir votre symbole &lsquo;@&rsquo;
accompagné d&rsquo;un autre symbole jaune représentant notre NPC. Il ne fait rien
pour l&rsquo;instant mais nous avons une méthode permettant dessiner plus d&rsquo;un
personnage à l&rsquo;écran.</p>

<p>Il est temps de changer de vitesse et de mettre la carte en place. La carte est
un tableau 2d d&rsquo;objets Tile (tuile). Les tuiles aurons quelques propriétés qui
définissent si on peut voir à travers ou voir à travers.</p>

<p>On devrait commencer en définissant la taille de notre carte. Ajoutez ces
variables juste après avoir défini la hauteur et la largeur de l&rsquo;écran.</p>

<div>
  <button class="btn btn-primary data-toggle-tab active" data-toggle-tab="diff">
    Diff
  </button>
  <button class="btn btn-secondary data-toggle-tab" data-toggle-tab="original">
    Original
  </button>

  
<div class="data-pane active" data-pane="diff">
  
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-diff" data-lang="diff">    ...
    screen_height = 50
<span style="color:#a6e22e">+   map_width = 80
</span><span style="color:#a6e22e">+   map_height = 45
</span></code></pre></div>

</div>
<div class="data-pane" data-pane="original">
  
<pre>    ...
    screen_height = 50
    <span class="new-text">map_width = 80
    map_height = 45</span></pre>

</div>

</div>


<p>Assez simple. On doit maintenant trouver une place pour notre classe Tile
et d&rsquo;autres classes. Je préfère ranger les classes similaires dans le même
dossier donc créez un nouveau package Python (c&rsquo;est un dossier avec un fichier
appelé <code>__init__.py</code>, ce fichier étant vide dans notre cas) appelé
<code>map_objects</code>. Dans ce dossier, crées un fichier <code>tile.py</code> et ajoutez-y le code
suivant.</p>

<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-py3" data-lang="py3"><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Tile</span>:
    <span style="color:#e6db74">&#34;&#34;&#34;
</span><span style="color:#e6db74">    A tile on a map. It may or may not be blocked, and may or may not block sight.
</span><span style="color:#e6db74">    &#34;&#34;&#34;</span>
    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">__init__</span>(self, blocked, block_sight<span style="color:#f92672">=</span><span style="color:#66d9ef">None</span>):
        self<span style="color:#f92672">.</span>blocked <span style="color:#f92672">=</span> blocked

        <span style="color:#75715e"># By default, if a tile is blocked, it also blocks sight</span>
        <span style="color:#66d9ef">if</span> block_sight <span style="color:#f92672">is</span> <span style="color:#66d9ef">None</span>:
            block_sight <span style="color:#f92672">=</span> blocked

        self<span style="color:#f92672">.</span>block_sight <span style="color:#f92672">=</span> block_sight</code></pre></div>

<p>Rien de très compliqué ici. La classe <code>Tile</code> contient l&rsquo;information selon
laquelle elle est bloquante (blocked, si elle l&rsquo;est, vous ne pouvez vous
déplacer dedans et l&rsquo;information nous permettant de savoir si on peut voir à
travers (<code>block_sight</code> pour notre algorithme de champ de vision FOV). Remarquez
qu&rsquo;il n&rsquo;est pas nécessaire de passer <code>block_sight</code> à chaque fois ; ce
paramètre supposé être le même que <code>blocked</code>. En séparant les deux, une tuile
peut être transparente sans pouvoir être traversée (un puis de lave,
peut-être ?) ou inversement (une pièce sombre, par exemple).</p>

<p>Maintenant qu&rsquo;on a une classe tuile, il nous faut un conteneur pour garder
nos tuiles. Créeons une classe <code>GameMap</code> qui contiendra notre tableau 2d de
tuiles ainsi que quelques méthodes pour régler et intéragir avec elles.
Créez un fichier dans le dossier map_objects et appelez le <code>game_map.py</code>.
Ajoutez-y le code suivant :</p>

<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-py3" data-lang="py3"><span style="color:#f92672">from</span> map_objects.tile <span style="color:#66d9ef">import</span> Tile


<span style="color:#66d9ef">class</span> <span style="color:#a6e22e">GameMap</span>:
    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">__init__</span>(self, width, height):
        self<span style="color:#f92672">.</span>width <span style="color:#f92672">=</span> width
        self<span style="color:#f92672">.</span>height <span style="color:#f92672">=</span> height
        self<span style="color:#f92672">.</span>tiles <span style="color:#f92672">=</span> self<span style="color:#f92672">.</span>initialize_tiles()

    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">initialize_tiles</span>(self):
        tiles <span style="color:#f92672">=</span> [[Tile(<span style="color:#66d9ef">False</span>) <span style="color:#66d9ef">for</span> y <span style="color:#f92672">in</span> range(self<span style="color:#f92672">.</span>height)] <span style="color:#66d9ef">for</span> x <span style="color:#f92672">in</span> range(self<span style="color:#f92672">.</span>width)]

        tiles[<span style="color:#ae81ff">30</span>][<span style="color:#ae81ff">22</span>]<span style="color:#f92672">.</span>blocked <span style="color:#f92672">=</span> <span style="color:#66d9ef">True</span>
        tiles[<span style="color:#ae81ff">30</span>][<span style="color:#ae81ff">22</span>]<span style="color:#f92672">.</span>block_sight <span style="color:#f92672">=</span> <span style="color:#66d9ef">True</span>
        tiles[<span style="color:#ae81ff">31</span>][<span style="color:#ae81ff">22</span>]<span style="color:#f92672">.</span>blocked <span style="color:#f92672">=</span> <span style="color:#66d9ef">True</span>
        tiles[<span style="color:#ae81ff">31</span>][<span style="color:#ae81ff">22</span>]<span style="color:#f92672">.</span>block_sight <span style="color:#f92672">=</span> <span style="color:#66d9ef">True</span>
        tiles[<span style="color:#ae81ff">32</span>][<span style="color:#ae81ff">22</span>]<span style="color:#f92672">.</span>blocked <span style="color:#f92672">=</span> <span style="color:#66d9ef">True</span>
        tiles[<span style="color:#ae81ff">32</span>][<span style="color:#ae81ff">22</span>]<span style="color:#f92672">.</span>block_sight <span style="color:#f92672">=</span> <span style="color:#66d9ef">True</span>

        <span style="color:#66d9ef">return</span> tiles</code></pre></div>

<p>On lui passe la largeur et la hauteur de la carte (définies dans notre moteur)
et on initialise un tableau 2d de tuiles, réglées sur non bloquantes par défaut.
On règle quelques tuiles comme étant bloquantes, pour démontrer le principe.
J&rsquo;ai conservé les réglages des tuiles hors de la fonction <code>__init__</code> pour deux
raisons. D&rsquo;une part parce qu&rsquo;on peut l&rsquo;appeler en dehors de l&rsquo;initialisation,
d&rsquo;autre part parce que je prefère avoir des fonctions <code>__init__</code> aussi simples
que possible.</p>

<p>Revenez sur <code>engine.py</code> où nous allons faire quelques changement pour
initialiser la carte et l&rsquo;afficher à l&rsquo;écran.</p>

<p>D&rsquo;abord, nous définissons quelle couleur employer pour les tuiles bloquantes et
non bloquantes. Définissons un dictionnaire qui contient les couleurs qu&rsquo;on
utilisera pour l&rsquo;instant (il s&rsquo;agrandira avec l&rsquo;avancée du tutoriel).</p>

<div>
  <button class="btn btn-primary data-toggle-tab active" data-toggle-tab="diff">
    Diff
  </button>
  <button class="btn btn-secondary data-toggle-tab" data-toggle-tab="original">
    Original
  </button>

  
<div class="data-pane active" data-pane="diff">
  
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-diff" data-lang="diff">    ...
    map_height = 45

<span style="color:#a6e22e">+   colors = {
</span><span style="color:#a6e22e">+       &#39;dark_wall&#39;: libtcod.Color(0, 0, 100),
</span><span style="color:#a6e22e">+       &#39;dark_ground&#39;: libtcod.Color(50, 50, 150)
</span><span style="color:#a6e22e">+   }
</span><span style="color:#a6e22e"></span>
    player = Entity(int(screen_width / 2), int(screen_height / 2), &#39;@&#39;, libtcod.white)
</code></pre></div>

</div>
<div class="data-pane" data-pane="original">
  
<pre>    ...
    map_height = 45

    <span class="new-text">colors = {
        'dark_wall': libtcod.Color(0, 0, 100),
        'dark_ground': libtcod.Color(50, 50, 150)
    }</span>

    player = Entity(int(screen_width / 2), int(screen_height / 2), '@', libtcod.white)</pre>

</div>

</div>


<p>Ces couleurs nous serviront pour les murs et le sol en dehors du champ de vision
quand on y sera (d&rsquo;où le &lsquo;dark&rsquo; de leurs noms).</p>

<p>Maintenant nous allons initialiser la carte de jeu elle même. Cela peut-être
placé n&rsquo;importe où avant la boucle principale. J&rsquo;ajoute la mienne juste en
dessous de l&rsquo;initialisation de la console.</p>

<div>
  <button class="btn btn-primary data-toggle-tab active" data-toggle-tab="diff">
    Diff
  </button>
  <button class="btn btn-secondary data-toggle-tab" data-toggle-tab="original">
    Original
  </button>

  
<div class="data-pane active" data-pane="diff">
  
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-diff" data-lang="diff">    con = libtcod.console_new(screen_width, screen_height)

<span style="color:#a6e22e">+   game_map = GameMap(map_width, map_height)
</span><span style="color:#a6e22e"></span>
    key = libtcod.Key()
</code></pre></div>

</div>
<div class="data-pane" data-pane="original">
  
<pre>    con = libtcod.console_new(screen_width, screen_height)

    <span class="new-text">game_map = GameMap(map_width, map_height)</span>

    key = libtcod.Key()</pre>

</div>

</div>


<p>N&rsquo;oublions pas d&rsquo;importer l&rsquo;objet GameMap de façon à l&rsquo;utiliser dans le moteur.</p>

<div>
  <button class="btn btn-primary data-toggle-tab active" data-toggle-tab="diff">
    Diff
  </button>
  <button class="btn btn-secondary data-toggle-tab" data-toggle-tab="original">
    Original
  </button>

  
<div class="data-pane active" data-pane="diff">
  
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-diff" data-lang="diff">from entity import Entity
from input_handlers import handle_keys
<span style="color:#a6e22e">+from map_objects.game_map import GameMap
</span><span style="color:#a6e22e"></span>from render_functions import clear_all, render_all
</code></pre></div>

</div>
<div class="data-pane" data-pane="original">
  
<pre>from entity import Entity
from input_handlers import handle_keys
<span class="new-text">from map_objects.game_map import GameMap</span>
from render_functions import clear_all, render_all</pre>

</div>

</div>


<p>Maintenant que notre objet carte est prêt passons le à <code>render_all</code> de façon
à le dessiner. Nous passerons aussi le dictionnaire <code>colors</code> parce que
<code>render_all</code> aura besoin de connaître les couleurs des éléments de la carte.
Remarquez que l&rsquo;ordre dans lequel vous passez ces arguments n&rsquo;a pas d&rsquo;importance
cela doit simplement être cohérent avec la définition de la fonction quand vous
l&rsquo;appelez.</p>

<div>
  <button class="btn btn-primary data-toggle-tab active" data-toggle-tab="diff">
    Diff
  </button>
  <button class="btn btn-secondary data-toggle-tab" data-toggle-tab="original">
    Original
  </button>

  
<div class="data-pane active" data-pane="diff">
  
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-diff" data-lang="diff"><span style="color:#f92672">-       render_all(con, entities, screen_width, screen_height)
</span><span style="color:#f92672"></span><span style="color:#a6e22e">+       render_all(con, entities, game_map, screen_width, screen_height, colors)
</span></code></pre></div>

</div>
<div class="data-pane" data-pane="original">
  
<pre>        <span class="crossed-out-text">render_all(con, entities, screen_width, screen_height)</span>
        <span class="new-text">render_all(con, entities, game_map, screen_width, screen_height, colors)</span></pre>

</div>

</div>


<p>Ouvrez <code>render_functions.py</code> et modifiez <code>render_all</code> ainsi :</p>

<div>
  <button class="btn btn-primary data-toggle-tab active" data-toggle-tab="diff">
    Diff
  </button>
  <button class="btn btn-secondary data-toggle-tab" data-toggle-tab="original">
    Original
  </button>

  
<div class="data-pane active" data-pane="diff">
  
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-diff" data-lang="diff"><span style="color:#f92672">-def render_all(con, entities, screen_width, screen_height):
</span><span style="color:#f92672"></span><span style="color:#a6e22e">+def render_all(con, entities, game_map, screen_width, screen_height, colors):
</span><span style="color:#a6e22e">+   # Draw all the tiles in the game map
</span><span style="color:#a6e22e">+   for y in range(game_map.height):
</span><span style="color:#a6e22e">+       for x in range(game_map.width):
</span><span style="color:#a6e22e">+           wall = game_map.tiles[x][y].block_sight
</span><span style="color:#a6e22e">+
</span><span style="color:#a6e22e">+           if wall:
</span><span style="color:#a6e22e">+               libtcod.console_set_char_background(con, x, y, colors.get(&#39;dark_wall&#39;), libtcod.BKGND_SET)
</span><span style="color:#a6e22e">+           else:
</span><span style="color:#a6e22e">+               libtcod.console_set_char_background(con, x, y, colors.get(&#39;dark_ground&#39;), libtcod.BKGND_SET)
</span><span style="color:#a6e22e">+
</span><span style="color:#a6e22e"></span>    # Draw all entities in the list
    for entity in entities:
        draw_entity(con, entity)

    libtcod.console_blit(con, 0, 0, screen_width, screen_height, 0, 0, 0)
</code></pre></div>

</div>
<div class="data-pane" data-pane="original">
  
<pre><span class="crossed-out-text">def render_all(con, entities, screen_width, screen_height):</span>
<span class="new-text">def render_all(con, entities, game_map, screen_width, screen_height, colors):
    # Draw all the tiles in the game map
    for y in range(game_map.height):
        for x in range(game_map.width):
            wall = game_map.tiles[x][y].block_sight

            if wall:
                libtcod.console_set_char_background(con, x, y, colors.get('dark_wall'), libtcod.BKGND_SET)
            else:
                libtcod.console_set_char_background(con, x, y, colors.get('dark_ground'), libtcod.BKGND_SET)
    </span>
    # Draw all entities in the list
    for entity in entities:
        draw_entity(con, entity)

    libtcod.console_blit(con, 0, 0, screen_width, screen_height, 0, 0, 0)</pre>

</div>

</div>


<p><code>render_all</code> boucle maintenant sur les tuiles de la carte de jeu et vérifie si
elles bloquent la vue ou non. Si c&rsquo;est le cas, il dessine la tuile comme un mur
et sinon comme le sol.</p>

<p>Lancez le projet maintenant et vous devriez voir la carte dessinée avec des
couleurs. Vous verrez nos trois blocs de mur mais il y a un problème : vous
pouvez bouger à travers le mur !</p>

<p>Nous devons ajouter deux choses avant de conclure cette étape. Modifiez la
partie où la fonction de déplacement du joueur est appelée pour qu&rsquo;elle
ressemble à ceci :</p>

<div>
  <button class="btn btn-primary data-toggle-tab active" data-toggle-tab="diff">
    Diff
  </button>
  <button class="btn btn-secondary data-toggle-tab" data-toggle-tab="original">
    Original
  </button>

  
<div class="data-pane active" data-pane="diff">
  
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-diff" data-lang="diff">            if not game_map.is_blocked(player.x + dx, player.y + dy):
                player.move(dx, dy)
<span style="color:#f92672">-           player.move(dx, dy)
</span></code></pre></div>

</div>
<div class="data-pane" data-pane="original">
  
<pre>            <span class="new-text">if not game_map.is_blocked(player.x + dx, player.y + dy):
                player.move(dx, dy)</span>
            <span class="crossed-out-text">player.move(dx, dy)</span></pre>

</div>

</div>


<p><em>* Remarquez le changement d&rsquo;indentation pour <code>plaer.move(dx, dy)</code>. En Python
l&rsquo;indentation est importante !</em></p>

<p>Maintenant on doit simplement crée la méthode <code>is_blocked</code> dans la carte du jeu.
Ouvrez le fichier <code>game_map.py</code> et ajouter cette méthode à la classe :</p>

<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-py3" data-lang="py3">    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">is_blocked</span>(self, x, y):
        <span style="color:#66d9ef">if</span> self<span style="color:#f92672">.</span>tiles[x][y]<span style="color:#f92672">.</span>blocked:
            <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">True</span>

        <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">False</span></code></pre></div>

<p><em>* Remarque : vous pouvez raccourcir la fonction <code>is_blocked</code> en écrivant
simplement <code>return self.tiles[x][y].blocked</code> mais nous changerons cette fonction
pour qu&rsquo;elle vérifie plus de choses plus tard aussi nous prenons un chemin
plus explicite.</em></p>

<p>Lancez le projet à nouveau et vous serez bloqués par les murs.</p>

<p>Cela fera l&rsquo;affaire pour ce tutoriel. Il n&rsquo;y parait peut-être pas mais nous
avons fait ce qu&rsquo;il faut pour créer un donjon réalise dans la prochaine partie.</p>

<p>Si vous voulez voir le code actuel entièrement, <a href="https://github.com/TStand90/roguelike_tutorial_revised/tree/part2">cliquez ici</a>.</p>

<p><a href="/tutorials/tcod/part-3">Cliquez ici pour vous rendre à la partie suivante de ce tutoriel.</a></p>

<script src="/js/codetabs.js"></script>


    

    


</article>



        </div>

        <aside class="col-12 col-lg-3 ml-auto blog-sidebar">
    
    
        <section>
    
        
    
        
    
</section>
    
</aside>

      </div>
    </div>
    

    
      







<footer class="blog-footer w-100">
    <nav class="navbar navbar-light bg-light">
        <p class="w-100 text-center">Dernière mise à jour le 24 juillet 2019</p>
        <p class="w-100 text-center"><a href="#">Back to top</a></p>
    </nav>
</footer>

    

    
    
    <script src="https://code.jquery.com/jquery-3.3.1.slim.min.js" integrity="sha384-q8i/X+965DzO0rT7abK41JStQIAqVgRVzpbzo5smXKp4YfRvH+8abtTE1Pi6jizo" crossorigin="anonymous"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/popper.js/1.14.3/umd/popper.min.js" integrity="sha384-ZMP7rVo3mIykV+2+9J3UJ46jBk0WLaUAdn689aCwoqbBJiSnjAK/l8WvCWPIPm49" crossorigin="anonymous"></script>
    <script src="https://stackpath.bootstrapcdn.com/bootstrap/4.1.3/js/bootstrap.min.js" integrity="sha384-ChfqqxuZUCnJSK3+MXmPNIyE6ZbWh2IMqE241rYiqJxyMiZ6OW/JmZQ5stwEULTy" crossorigin="anonymous"></script>
  </body>
</html>
