<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8">
<meta http-equiv="x-ua-compatible" content="ie=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

<meta property="og:title" content="Part 3 - Générer un donjon" />
<meta property="og:description" content="Bienvenue à nouveau dans le tutoriel Roguelike revisité ! Dans cette étape nous allons franchir un pas très important vers un vrai jeu fonctionnel : créer un donjon procédural !
Vous souvenez-vous du petit mur crée pour la démonstration dans la partie précédente ? Nous n&rsquo;en avons plus besoin aussi enlevons le.
 Diff  Original  - tiles[30][22].blocked = True - tiles[30][22].block_sight = True - tiles[31][22].blocked = True - tiles[31][22]." />
<meta property="og:type" content="article" />
<meta property="og:url" content="/tutoriels/tcod/part-3/" />
<meta property="article:published_time" content="2019-03-30T08:39:22-07:00"/>
<meta property="article:modified_time" content="2019-03-30T08:39:22-07:00"/>

<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Part 3 - Générer un donjon"/>
<meta name="twitter:description" content="Bienvenue à nouveau dans le tutoriel Roguelike revisité ! Dans cette étape nous allons franchir un pas très important vers un vrai jeu fonctionnel : créer un donjon procédural !
Vous souvenez-vous du petit mur crée pour la démonstration dans la partie précédente ? Nous n&rsquo;en avons plus besoin aussi enlevons le.
 Diff  Original  - tiles[30][22].blocked = True - tiles[30][22].block_sight = True - tiles[31][22].blocked = True - tiles[31][22]."/>



    <link rel="canonical" href="/tutoriels/tcod/part-3/">

    <title>
      
        Part 3 - Générer un donjon | Tutoriel Roguelike
      
    </title>

    
    <link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.1.3/css/bootstrap.min.css" integrity="sha384-MCw98/SFnGE8fJT3GXwEOngsV7Zt27NXFoaoApmYm81iuXoPkFOJwJ8ERdknLPMO" crossorigin="anonymous">
    <link href="/css/style.css" rel="stylesheet">

    

    

    
  </head>
  <body>
    
      

<header class="blog-header">
    <nav class="navbar navbar-expand-md navbar-dark bg-dark">
        <a class="navbar-brand" href="/">
            Tutoriel Roguelike
        </a>
        <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNav" aria-controls="navbarNav" aria-expanded="false"
            aria-label="Toggle navigation">
            <span class="navbar-toggler-icon"></span>
        </button>
        <div class="collapse navbar-collapse justify-content-between" id="navbarNav">
            <ul class="navbar-nav">
                
                
                <li class="nav-item ">
                    
                        <a class="nav-link" href="/">Home</a>
                    
                </li>
                
                <li class="nav-item ">
                    
                        <a class="nav-link" href="/tutoriels/tcod/">Tutoriel TCOD</a>
                    
                </li>
                
                <li class="nav-item ">
                    
                        <a class="nav-link" href="/about/">A propos</a>
                    
                </li>
                
            </ul>
            
        </div>
    </nav>
</header>

    

    
    <div class="container">
      <div class="row">
        <div class="col-12 col-lg-8 blog-main">

          

<header>
    <h2 class="blog-post-title">
    <a class="text-dark" href="/tutoriels/tcod/part-3/">Part 3 - Générer un donjon</a>
</h2>

    


<div class="blog-post-date text-secondary">
    
        <time datetime="2019-03-30">Mar 30, 2019</time>
    
    
</div>

    
    
    <hr>
</header>
<article class="blog-post">
    <p>Bienvenue à nouveau dans le tutoriel Roguelike revisité ! Dans cette étape nous
allons franchir un pas <strong>très</strong> important vers un vrai jeu fonctionnel : créer
un donjon procédural !</p>

<p>Vous souvenez-vous du petit mur crée pour la démonstration dans la partie
précédente ? Nous n&rsquo;en avons plus besoin aussi enlevons le.</p>

<div>
  <button class="btn btn-primary data-toggle-tab active" data-toggle-tab="diff">
    Diff
  </button>
  <button class="btn btn-secondary data-toggle-tab" data-toggle-tab="original">
    Original
  </button>

  
<div class="data-pane active" data-pane="diff">
  
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-diff" data-lang="diff"><span style="color:#f92672">-       tiles[30][22].blocked = True
</span><span style="color:#f92672">-       tiles[30][22].block_sight = True
</span><span style="color:#f92672">-       tiles[31][22].blocked = True
</span><span style="color:#f92672">-       tiles[31][22].block_sight = True
</span><span style="color:#f92672">-       tiles[32][22].blocked = True
</span><span style="color:#f92672">-       tiles[32][22].block_sight = True
</span></code></pre></div>

</div>
<div class="data-pane" data-pane="original">
  
<pre>        <span class="crossed-out-text">tiles[30][22].blocked = True</span>
        <span class="crossed-out-text">tiles[30][22].block_sight = True</span>
        <span class="crossed-out-text">tiles[31][22].blocked = True</span>
        <span class="crossed-out-text">tiles[31][22].block_sight = True</span>
        <span class="crossed-out-text">tiles[32][22].blocked = True</span>
        <span class="crossed-out-text">tiles[32][22].block_sight = True</span></pre>

</div>

</div>


<p>Nous avons aussi besoin de faire un petit changement à la liste par
compréhension qui crée nos tuiles.</p>

<div>
  <button class="btn btn-primary data-toggle-tab active" data-toggle-tab="diff">
    Diff
  </button>
  <button class="btn btn-secondary data-toggle-tab" data-toggle-tab="original">
    Original
  </button>

  
<div class="data-pane active" data-pane="diff">
  
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-diff" data-lang="diff"><span style="color:#f92672">-       tiles = [[Tile(False) for y in range(self.height)] for x in range(self.width)]
</span><span style="color:#f92672"></span><span style="color:#a6e22e">+       tiles = [[Tile(True) for y in range(self.height)] for x in range(self.width)]
</span></code></pre></div>

</div>
<div class="data-pane" data-pane="original">
  
<pre>        <span class="crossed-out-text">tiles = [[Tile(False) for y in range(self.height)] for x in range(self.width)]</span>
        <span class="new-text">tiles = [[Tile(True) for y in range(self.height)] for x in range(self.width)]</span></pre>

</div>

</div>


<p>Pourquoi changer <code>False</code> en <code>True</code> ? Jusque là, nous réglions chaque tuile
pour être franchissable par défaut de façon à nous déplacer facilement.
Aussi nous passion <code>False</code> à la classe <code>Tile</code> de façon a rendre l&rsquo;attribut
<code>blocked</code> en False.</p>

<p>Cependant notre algorithme de génération fonctionne à l&rsquo;envers : on crée une
pièce remplie de murs et on creuse les sections alors qu&rsquo;on avance. Aussi,
on initialise nos tuiles pour qu&rsquo;elles bloquent par défaut. Pour information,
tous les algorithmes de génération que j&rsquo;ai vu fonctionnent ainsi.</p>

<p>Avant d&rsquo;attaquer l&rsquo;algorithme nous devons faire une chose en plus : définir une
classe d&rsquo;aide pour nos &ldquo;cartes&rdquo;. Ce sera une classe basique qui contiendra un
peu d&rsquo;information à propos des dimensions et que nous appellerons <code>Rect</code> (pour
rectangle). Créez un nouveau fichier dans le dossier <code>map_objects</code> et appelez-le
<code>rectangle.py</code>. Saisissez-y le code suivant.</p>

<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-py3" data-lang="py3"><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Rect</span>:
    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">__init__</span>(self, x, y, w, h):
        self<span style="color:#f92672">.</span>x1 <span style="color:#f92672">=</span> x
        self<span style="color:#f92672">.</span>y1 <span style="color:#f92672">=</span> y
        self<span style="color:#f92672">.</span>x2 <span style="color:#f92672">=</span> x <span style="color:#f92672">+</span> w
        self<span style="color:#f92672">.</span>y2 <span style="color:#f92672">=</span> y <span style="color:#f92672">+</span> h</code></pre></div>

<p>La fonction <code>__init__</code> prend les coordonnées x et y du coin supérieur gauche et
calcule le coin inférieur droit avec la largeur et la hauteur données en
paramètres w et h. Nous ajouterons plus de choses à cette classe dans peu de
temps mais c&rsquo;est tout ce dont on a besoin pour commencer.</p>

<p>Maintenant, si nous voulons &ldquo;creuser&rdquo; un paquet de pièces pour créer notre
donjon, nous avons besoin d&rsquo;une fonction pour créer une pièce. Cette fonction
doit prendre un argument, appelé <code>room</code> qui doit être de la classe <code>Rect</code> que
nous venons de créer. De x1 à x2 et de y1 à y2 nous voulons que chaque tuile
dans le <code>Rect</code> ne soit pas bloquante de façon à ce que le joueur puisse s&rsquo;y
déplacer. Nous pouvons ajouter cette fonction dans la classe <code>GameMap</code> puisque
nous manipulerons la liste des tuiles de la carte.</p>

<p>Voici ce qu&rsquo;on obtient dans cette fonction :</p>

<div>
  <button class="btn btn-primary data-toggle-tab active" data-toggle-tab="diff">
    Diff
  </button>
  <button class="btn btn-secondary data-toggle-tab" data-toggle-tab="original">
    Original
  </button>

   <div class="data-pane active" data-pane="diff">
   <div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-diff" data-lang="diff">    def initialize_tiles(self):
        ...

<span style="color:#a6e22e">+   def create_room(self, room):
</span><span style="color:#a6e22e">+       # go through the tiles in the rectangle and make them passable
</span><span style="color:#a6e22e">+       for x in range(room.x1 + 1, room.x2):
</span><span style="color:#a6e22e">+           for y in range(room.y1 + 1, room.y2):
</span><span style="color:#a6e22e">+               self.tiles[x][y].blocked = False
</span><span style="color:#a6e22e">+               self.tiles[x][y].block_sight = False
</span><span style="color:#a6e22e"></span>
    def is_blocked(self, x, y):
        ...
</code></pre></div>

</div>
<div class="data-pane" data-pane="original">
  
<pre>    def initialize_tiles(self):
        ...

    <span class="new-text">def create_room(self, room):
        # go through the tiles in the rectangle and make them passable
        for x in range(room.x1 + 1, room.x2):
            for y in range(room.y1 + 1, room.y2):
                self.tiles[x][y].blocked = False
                self.tiles[x][y].block_sight = False</span>

    def is_blocked(self, x, y):
        ...</pre>

</div>

</div>


<p>**Remarque : <code>initialize_tiles</code> et <code>is_blocked</code> sont réduites pour rendre les
choses concises.</p>

<p>Pourquoi les + 1 de room.x1 et room.y1 ? Pensons à ce que nous disons à notre
programme quand nous voulons une pièce aux coordonnées (1, 1) qui aille jusque
(6, 6). On pourrait supposer qu&rsquo;on creuse une pièce comme celle-ci
(souvenez-vous que les listes sont indexées à partir de 0) donc (0, 0) est un
mur dans notre cas) :</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">  0 1 2 3 4 5 6 7
0 # # # # # # # #
1 # . . . . . . #
2 # . . . . . . #
3 # . . . . . . #
4 # . . . . . . #
5 # . . . . . . #
6 # . . . . . . #
7 # # # # # # # #</pre></div>
<p>Tout cela est bel et bon mais que se passe-t-il si on ajoute une pièce juste
à côté ? Imaginons une pièce qui commence en (7, 1) et aille jusque (9, 6).</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">  0 1 2 3 4 5 6 7 8 9 10
0 # # # # # # # # # # #
1 # . . . . . . . . . #
2 # . . . . . . . . . #
3 # . . . . . . . . . #
4 # . . . . . . . . . #
5 # . . . . . . . . . #
6 # . . . . . . . . . #
7 # # # # # # # # # # #</pre></div>
<p>Aucun mur ne les sépare ! Cela veut dire que si deux pièces sont côte à côte,
il n&rsquo;y aura aucun mur entre elles ! Pour faire simple, notre fonction doit
tenir compte des murs quand on creuse une pièce. Ainsi si on a un rectangle de
coordonnées x1 = 1, x2 = 6, y1 = 1 et y2 = 6, alors la pièce devrait ressembler
à cela :</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">  0 1 2 3 4 5 6 7
0 # # # # # # # #
1 # # # # # # # #
2 # # . . . . # #
3 # # . . . . # #
4 # # . . . . # #
5 # # . . . . # #
6 # # # # # # # #
7 # # # # # # # #</pre></div>
<p>Cela nous assure qu&rsquo;on aura au moins une tuile de mur d&rsquo;épaisseur entre les
pièces à moins qu&rsquo;on souhaite créer des pièces qui se superposent. De façon à y
parvenir on ajoute + 1 à x1 et y1.</p>

<p><em>* Note: In case you&rsquo;re wondering, we don&rsquo;t subtract 1 from x2 and y2
because Python&rsquo;s range function does not include the &lsquo;end&rsquo; value in its
range. For example, range(0, 10) would give us [0, 1, 2, 3, 4, 5, 6, 7,
8, 9].</em></p>

<p><em>* Remarque : si vous vous posiez la question, on n&rsquo;a pas besoin de soustraire
1 de x2 et y2 parce que la fonction range de Python n&rsquo;inclut pas les valeurs
de fin dans son intervalle. Par exemple range(0, 10) nous donne [0, 1, 2, 3, 4,
 5, 6, 7, 8, 9].</em></p>

<p>Créons des pièces ! Nous avons besoin d&rsquo;une fonction dans <code>GameMap</code> pour
générer notre carte donc ajoutons en une :</p>

<div>
  <button class="btn btn-primary data-toggle-tab active" data-toggle-tab="diff">
    Diff
  </button>
  <button class="btn btn-secondary data-toggle-tab" data-toggle-tab="original">
    Original
  </button>

   <div class="data-pane active" data-pane="diff">
   <div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-diff" data-lang="diff">    def initialize_tiles(self):
        ...

<span style="color:#a6e22e">+   def make_map(self):
</span><span style="color:#a6e22e">+       # Create two rooms for demonstration purposes
</span><span style="color:#a6e22e">+       room1 = Rect(20, 15, 10, 15)
</span><span style="color:#a6e22e">+       room2 = Rect(35, 15, 10, 15)
</span><span style="color:#a6e22e">+
</span><span style="color:#a6e22e">+       self.create_room(room1)
</span><span style="color:#a6e22e">+       self.create_room(room2)
</span><span style="color:#a6e22e"></span>
    def create_room(self, room):
        ...
</code></pre></div>

</div>
<div class="data-pane" data-pane="original">
  
<pre>    def initialize_tiles(self):
        ...

    <span class="new-text">def make_map(self):
        # Create two rooms for demonstration purposes
        room1 = Rect(20, 15, 10, 15)
        room2 = Rect(35, 15, 10, 15)

        self.create_room(room1)
        self.create_room(room2)</span>

    def create_room(self, room):
        ...</pre>

</div>

</div>


<p>On doit importer la classe <code>Rect</code> dans le fichier <code>game_map</code> de façon à ce que
ça fonctionne. En haut de votre fichier, modifiez votre section d&rsquo;import :</p>

<div>
  <button class="btn btn-primary data-toggle-tab active" data-toggle-tab="diff">
    Diff
  </button>
  <button class="btn btn-secondary data-toggle-tab" data-toggle-tab="original">
    Original
  </button>

   <div class="data-pane active" data-pane="diff">
   <div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-diff" data-lang="diff"><span style="color:#a6e22e">+from map_objects.rectangle import Rect
</span><span style="color:#a6e22e"></span>from map_objects.tile import Tile
</code></pre></div>

</div>
<div class="data-pane" data-pane="original">
  
        <pre><span class="new-text">from map_objects.rectangle import Rect</span>
from map_objects.tile import Tile</pre>

</div>

</div>


<p>Enfin, modifiez <code>engine.py</code> pour appeler la nouvelle fonction <code>make_map</code>.</p>

<div>
  <button class="btn btn-primary data-toggle-tab active" data-toggle-tab="diff">
    Diff
  </button>
  <button class="btn btn-secondary data-toggle-tab" data-toggle-tab="original">
    Original
  </button>

   <div class="data-pane active" data-pane="diff">
   <div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-diff" data-lang="diff">    game_map = GameMap(map_width, map_height)
<span style="color:#a6e22e">+   game_map.make_map()
</span></code></pre></div>

</div>
<div class="data-pane" data-pane="original">
  
    <pre>    game_map = GameMap(map_width, map_height)
    <span class="new-text">game_map.make_map()</span></pre>

</div>

</div>


<p>C&rsquo;est le bon moment pour exécuter votre code et vous assurer que tout fonctionne
comme prévu. Les changements effectués mettent deux pièces d&rsquo;exemple sur la
carte avec notre joueur au centre de l&rsquo;une d&rsquo;entre elle (notre pauvre NPC est
coincé dans un mur, cela dit).</p>

<p>Je pense que vous aurez remarqué que les pièces ne sont pas reliées. Quel est
l&rsquo;intérêt d&rsquo;avoir un donjon si on est enfermé dans une pièce ? Pas d&rsquo;inquiétude,
écrivons un peu de code pour créer un tunnel d&rsquo;une pièce à l&rsquo;autre. Ajoutez la
méthode suivante à <code>GameMap</code> :</p>

<div>
  <button class="btn btn-primary data-toggle-tab active" data-toggle-tab="diff">
    Diff
  </button>
  <button class="btn btn-secondary data-toggle-tab" data-toggle-tab="original">
    Original
  </button>

   <div class="data-pane active" data-pane="diff">
   <div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-diff" data-lang="diff">    def create_room(self, room):
        ...

<span style="color:#a6e22e">+   def create_h_tunnel(self, x1, x2, y):
</span><span style="color:#a6e22e">+       for x in range(min(x1, x2), max(x1, x2) + 1):
</span><span style="color:#a6e22e">+           self.tiles[x][y].blocked = False
</span><span style="color:#a6e22e">+           self.tiles[x][y].block_sight = False
</span><span style="color:#a6e22e">+
</span><span style="color:#a6e22e">+   def create_v_tunnel(self, y1, y2, x):
</span><span style="color:#a6e22e">+       for y in range(min(y1, y2), max(y1, y2) + 1):
</span><span style="color:#a6e22e">+           self.tiles[x][y].blocked = False
</span><span style="color:#a6e22e">+           self.tiles[x][y].block_sight = False
</span><span style="color:#a6e22e"></span>
    def is_blocked(self, x, y):
        ...
</code></pre></div>

</div>
<div class="data-pane" data-pane="original">
  
<pre>    def create_room(self, room):
        ...

    <span class="new-text">def create_h_tunnel(self, x1, x2, y):
        for x in range(min(x1, x2), max(x1, x2) + 1):
            self.tiles[x][y].blocked = False
            self.tiles[x][y].block_sight = False

    def create_v_tunnel(self, y1, y2, x):
        for y in range(min(y1, y2), max(y1, y2) + 1):
            self.tiles[x][y].blocked = False
            self.tiles[x][y].block_sight = False</span>

    def is_blocked(self, x, y):
        ...
        </pre>

</div>

</div>


<p>Let&rsquo;s put this code to use by drawing a tunnel between our two rooms.</p>

<div>
  <button class="btn btn-primary data-toggle-tab active" data-toggle-tab="diff">
    Diff
  </button>
  <button class="btn btn-secondary data-toggle-tab" data-toggle-tab="original">
    Original
  </button>

   <div class="data-pane active" data-pane="diff">
   <div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-diff" data-lang="diff">        ...
        self.create_room(room2)

<span style="color:#a6e22e">+       self.create_h_tunnel(25, 40, 23)
</span></code></pre></div>

</div>
<div class="data-pane" data-pane="original">
  
<pre>        ...
        self.create_room(room2)

        <span class="new-text">self.create_h_tunnel(25, 40, 23)</span></pre>

</div>

</div>


<p>Maintenant qu&rsquo;on a démontré que nos fonctions de pièces et de tunnels
fonctionnent comme prévues, il est temps de passer à un vrai algorithme de
génération de donjons. Le notre sera plutôt simple : on place des pièces une à
la fois en nous assurant qu&rsquo;elles ne se superposent pas et on les relie avec des
tunnels.</p>

<p>Nous aurons besoin de deux fonctions dans la classe <code>Rect</code> pour nous assurer que
les deux rectangles (rooms) ne se superposent pas. Saisissez les méthodes dans
la classe <code>Rect</code> :</p>

<div>
  <button class="btn btn-primary data-toggle-tab active" data-toggle-tab="diff">
    Diff
  </button>
  <button class="btn btn-secondary data-toggle-tab" data-toggle-tab="original">
    Original
  </button>

   <div class="data-pane active" data-pane="diff">
   <div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-diff" data-lang="diff">class Rect:
    def __init__(self, x, y, w, h):
        self.x1 = x
        self.y1 = y
        self.x2 = x + w
        self.y2 = y + h

<span style="color:#a6e22e">+   def center(self):
</span><span style="color:#a6e22e">+       center_x = int((self.x1 + self.x2) / 2)
</span><span style="color:#a6e22e">+       center_y = int((self.y1 + self.y2) / 2)
</span><span style="color:#a6e22e">+       return (center_x, center_y)
</span><span style="color:#a6e22e">+
</span><span style="color:#a6e22e">+   def intersect(self, other):
</span><span style="color:#a6e22e">+       # returns true if this rectangle intersects with another one
</span><span style="color:#a6e22e">+       return (self.x1 &lt;= other.x2 and self.x2 &gt;= other.x1 and
</span><span style="color:#a6e22e">+               self.y1 &lt;= other.y2 and self.y2 &gt;= other.y1)
</span></code></pre></div>

</div>
<div class="data-pane" data-pane="original">
  
<pre>class Rect:
    def __init__(self, x, y, w, h):
        self.x1 = x
        self.y1 = y
        self.x2 = x + w
        self.y2 = y + h

    <span class="new-text">def center(self):
        center_x = int((self.x1 + self.x2) / 2)
        center_y = int((self.y1 + self.y2) / 2)
        return (center_x, center_y)

    def intersect(self, other):
        # returns true if this rectangle intersects with another one
        return (self.x1 <= other.x2 and self.x2 >= other.x1 and
                self.y1 <= other.y2 and self.y2 >= other.y1)</span></pre>

</div>

</div>


<p>Ne vous souciez pas trop des détails ici. Sachez simplement que la méthode
&lsquo;center&rsquo; renvoie le point central d&rsquo;un rectangle et qu&rsquo;<code>intersect</code> nous indique
si deux rectangles se rencontrent.</p>

<p>Nous aurons besoin de quelques variables pour régler les dimensions minimales
des pièces ainsi que le nombre maximal de pièces qu&rsquo;un étage peut contenir.
Ajoutez les éléments suivants à <code>engine.py</code></p>

<div>
  <button class="btn btn-primary data-toggle-tab active" data-toggle-tab="diff">
    Diff
  </button>
  <button class="btn btn-secondary data-toggle-tab" data-toggle-tab="original">
    Original
  </button>

   <div class="data-pane active" data-pane="diff">
   <div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-diff" data-lang="diff">    ...
    map_height = 45

<span style="color:#a6e22e">+   room_max_size = 10
</span><span style="color:#a6e22e">+   room_min_size = 6
</span><span style="color:#a6e22e">+   max_rooms = 30
</span><span style="color:#a6e22e"></span>
    colors = {
    ...
</code></pre></div>

</div>
<div class="data-pane" data-pane="original">
  
<pre>    ...
    map_height = 45

    <span class="new-text">room_max_size = 10
    room_min_size = 6
    max_rooms = 30</span>

    colors = {
    ...</pre>

</div>

</div>


<p>Enfin, il est temps de modifier <code>make_map</code> pour créer notre donjon !
Vous pouvez enlever complètement notre ancienne implémentation et la remplacer
par la suivante :</p>

<div>
  <button class="btn btn-primary data-toggle-tab active" data-toggle-tab="diff">
    Diff
  </button>
  <button class="btn btn-secondary data-toggle-tab" data-toggle-tab="original">
    Original
  </button>

   <div class="data-pane active" data-pane="diff">
   <div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-diff" data-lang="diff"><span style="color:#f92672">-   def make_map(self):
</span><span style="color:#f92672"></span><span style="color:#a6e22e">+   def make_map(self, max_rooms, room_min_size, room_max_size, map_width, map_height, player):
</span><span style="color:#a6e22e"></span><span style="color:#f92672">-       room1 = Rect(20, 15, 10, 15)
</span><span style="color:#f92672">-       room2 = Rect(35, 15, 10, 15)
</span><span style="color:#f92672"></span>
<span style="color:#f92672">-       self.create_room(room1)
</span><span style="color:#f92672">-       self.create_room(room2)
</span><span style="color:#f92672"></span>
<span style="color:#f92672">-       self.create_h_tunnel(25, 40, 23)
</span><span style="color:#f92672"></span>
<span style="color:#a6e22e">+       rooms = []
</span><span style="color:#a6e22e">+       num_rooms = 0
</span><span style="color:#a6e22e">+
</span><span style="color:#a6e22e">+       for r in range(max_rooms):
</span><span style="color:#a6e22e">+           # random width and height
</span><span style="color:#a6e22e">+           w = randint(room_min_size, room_max_size)
</span><span style="color:#a6e22e">+           h = randint(room_min_size, room_max_size)
</span><span style="color:#a6e22e">+           # random position without going out of the boundaries of the map
</span><span style="color:#a6e22e">+           x = randint(0, map_width - w - 1)
</span><span style="color:#a6e22e">+           y = randint(0, map_height - h - 1)
</span></code></pre></div>

</div>
<div class="data-pane" data-pane="original">
  
<pre>    <span class="crossed-out-text">def make_map(self):</span>
    <span class="new-text">def make_map(self, max_rooms, room_min_size, room_max_size, map_width, map_height, player):</span>
        <span class="crossed-out-text">room1 = Rect(20, 15, 10, 15)</span>
        <span class="crossed-out-text">room2 = Rect(35, 15, 10, 15)</span>

        <span class="crossed-out-text">self.create_room(room1)</span>
        <span class="crossed-out-text">self.create_room(room2)</span>

        <span class="crossed-out-text">self.create_h_tunnel(25, 40, 23)</span>

        <span class="new-text">rooms = []
        num_rooms = 0

        for r in range(max_rooms):
            # random width and height
            w = randint(room_min_size, room_max_size)
            h = randint(room_min_size, room_max_size)
            # random position without going out of the boundaries of the map
            x = randint(0, map_width - w - 1)
            y = randint(0, map_height - h - 1)</span></pre>

</div>

</div>


<p>Les variables que nous créons ici seront celles que nous utiliserons pour
créer nos pièces dans un instant. <code>randint</code> nous donne un entier aléatoire entre
les valeurs indiquées. Dans notre cas nous voulons que que la largeur et la
hauteur soient entre les minimums et maximums et que notre x et y soient entre
les bornes de la carte.</p>

<p>Nous devons aussi importer <code>randint</code> de <code>random</code> en haut du fichier.
Votre section d&rsquo;import pour <code>game_map.py</code> devrait maintenant ressembler à
quelque chose comme ceci :</p>

<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-py3" data-lang="py3"><span style="color:#f92672">from</span> random <span style="color:#66d9ef">import</span> randint

<span style="color:#f92672">from</span> map_objects.rectangle <span style="color:#66d9ef">import</span> Rect
<span style="color:#f92672">from</span> map_objects.tile <span style="color:#66d9ef">import</span> Tile</code></pre></div>

<p>Dernière étape avant d&rsquo;avancer : nous devons mettre à jour l&rsquo;appel de <code>make_map</code>
dans <code>engine.py</code>, nous utilisons des variables qui n&rsquo;existaient pas jusque là.
Modifiez le pour qu&rsquo;il ressemble à :</p>

<div>
  <button class="btn btn-primary data-toggle-tab active" data-toggle-tab="diff">
    Diff
  </button>
  <button class="btn btn-secondary data-toggle-tab" data-toggle-tab="original">
    Original
  </button>

   <div class="data-pane active" data-pane="diff">
   <div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-diff" data-lang="diff">    ...
    game_map = GameMap(map_width, map_height)
<span style="color:#f92672">-   game_map.make_map()
</span><span style="color:#f92672"></span><span style="color:#a6e22e">+   game_map.make_map(max_rooms, room_min_size, room_max_size, map_width, map_height, player)
</span></code></pre></div>

</div>
<div class="data-pane" data-pane="original">
  
<pre>    ...
    game_map = GameMap(map_width, map_height)
    <span class="crossed-out-text">game_map.make_map()</span>
    <span class="new-text">game_map.make_map(max_rooms, room_min_size, room_max_size, map_width, map_height, player)</span></pre>

</div>

</div>


<p>Maintenant nous allons mettre notre classe <code>Rect</code> en action en lui passant les
variables créees. Ensuite, nous pourrons vérifier s&rsquo;il rencontre une autre
pièce. Si c&rsquo;est le cas, nous ne voulons pas l&rsquo;ajouter aux pièces et on s&rsquo;en
débarrasse simplement.</p>

<div>
  <button class="btn btn-primary data-toggle-tab active" data-toggle-tab="diff">
    Diff
  </button>
  <button class="btn btn-secondary data-toggle-tab" data-toggle-tab="original">
    Original
  </button>

   <div class="data-pane active" data-pane="diff">
   <div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-diff" data-lang="diff">            ...
            y = randint(0, map_height - h - 1)

<span style="color:#a6e22e">+           # &#34;Rect&#34; class makes rectangles easier to work with
</span><span style="color:#a6e22e">+           new_room = Rect(x, y, w, h)
</span><span style="color:#a6e22e">+
</span><span style="color:#a6e22e">+           # run through the other rooms and see if they intersect with this one
</span><span style="color:#a6e22e">+           for other_room in rooms:
</span><span style="color:#a6e22e">+               if new_room.intersect(other_room):
</span><span style="color:#a6e22e">+                   break
</span></code></pre></div>

</div>
<div class="data-pane" data-pane="original">
  
<pre>            ...
            y = randint(0, map_height - h - 1)

            <span class="new-text"># "Rect" class makes rectangles easier to work with
            new_room = Rect(x, y, w, h)

            # run through the other rooms and see if they intersect with this one
            for other_room in rooms:
                if new_room.intersect(other_room):
                    break</span></pre>

</div>

</div>


<p>Si la pièce <em>n&rsquo;en rencontre pas</em> d&rsquo;autre alors nous devons la créer. Plutôt que
d&rsquo;introduire un booléen (True/False) pour garder ça en mémoire, on peut
simplement utiliser une expression for-else ! C&rsquo;est une particularité
spécifique et méconnue de Python qui dit simplement &ldquo;si la boucle n&rsquo;a pas été
interrompue par un &lsquo;break&rsquo;, alors fait ceci&rdquo;. Nous ajoutons notre code de
construction de la pièce dans l&rsquo;expression &lsquo;else&rsquo; juste après la boucle &lsquo;for&rsquo;.</p>

<div>
  <button class="btn btn-primary data-toggle-tab active" data-toggle-tab="diff">
    Diff
  </button>
  <button class="btn btn-secondary data-toggle-tab" data-toggle-tab="original">
    Original
  </button>

   <div class="data-pane active" data-pane="diff">
   <div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-diff" data-lang="diff">            ...
            for other_room in rooms:
                if new_room.intersect(other_room):
                    break
<span style="color:#a6e22e">+           else:
</span><span style="color:#a6e22e">+               # this means there are no intersections, so this room is valid
</span><span style="color:#a6e22e">+
</span><span style="color:#a6e22e">+               # &#34;paint&#34; it to the map&#39;s tiles
</span><span style="color:#a6e22e">+               self.create_room(new_room)
</span><span style="color:#a6e22e">+
</span><span style="color:#a6e22e">+               # center coordinates of new room, will be useful later
</span><span style="color:#a6e22e">+               (new_x, new_y) = new_room.center()
</span><span style="color:#a6e22e">+
</span><span style="color:#a6e22e">+               if num_rooms == 0:
</span><span style="color:#a6e22e">+                   # this is the first room, where the player starts at
</span><span style="color:#a6e22e">+                   player.x = new_x
</span><span style="color:#a6e22e">+                   player.y = new_y
</span></code></pre></div>

</div>
<div class="data-pane" data-pane="original">
  
<pre>            ...
            for other_room in rooms:
                if new_room.intersect(other_room):
                    break
            <span class="new-text">else:
                # this means there are no intersections, so this room is valid

                # "paint" it to the map's tiles
                self.create_room(new_room)

                # center coordinates of new room, will be useful later
                (new_x, new_y) = new_room.center()

                if num_rooms == 0:
                    # this is the first room, where the player starts at
                    player.x = new_x
                    player.y = new_y</span></pre>

</div>

</div>


<p>Nous créons la pièce et conservons les coordonnées de son centre. Si c&rsquo;est la
première pièce créée on y place le joueur en son centre. Nous allons utiliser
ces coordonnés de centre dans un instant pour créer nos tunnels.</p>

<div>
  <button class="btn btn-primary data-toggle-tab active" data-toggle-tab="diff">
    Diff
  </button>
  <button class="btn btn-secondary data-toggle-tab" data-toggle-tab="original">
    Original
  </button>

   <div class="data-pane active" data-pane="diff">
   <div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-diff" data-lang="diff">                ...
                if num_rooms == 0:
                    # this is the first room, where the player starts at
                    player.x = new_x
                    player.y = new_y
<span style="color:#a6e22e">+               else:
</span><span style="color:#a6e22e">+                   # all rooms after the first:
</span><span style="color:#a6e22e">+                   # connect it to the previous room with a tunnel
</span><span style="color:#a6e22e">+
</span><span style="color:#a6e22e">+                   # center coordinates of previous room
</span><span style="color:#a6e22e">+                   (prev_x, prev_y) = rooms[num_rooms - 1].center()
</span><span style="color:#a6e22e">+
</span><span style="color:#a6e22e">+                   # flip a coin (random number that is either 0 or 1)
</span><span style="color:#a6e22e">+                   if randint(0, 1) == 1:
</span><span style="color:#a6e22e">+                       # first move horizontally, then vertically
</span><span style="color:#a6e22e">+                       self.create_h_tunnel(prev_x, new_x, prev_y)
</span><span style="color:#a6e22e">+                       self.create_v_tunnel(prev_y, new_y, new_x)
</span><span style="color:#a6e22e">+                   else:
</span><span style="color:#a6e22e">+                       # first move vertically, then horizontally
</span><span style="color:#a6e22e">+                       self.create_v_tunnel(prev_y, new_y, prev_x)
</span><span style="color:#a6e22e">+                       self.create_h_tunnel(prev_x, new_x, new_y)
</span><span style="color:#a6e22e">+
</span><span style="color:#a6e22e">+               # finally, append the new room to the list
</span><span style="color:#a6e22e">+               rooms.append(new_room)
</span><span style="color:#a6e22e">+               num_rooms += 1
</span></code></pre></div>

</div>
<div class="data-pane" data-pane="original">
  
<pre>                ...
                if num_rooms == 0:
                    # this is the first room, where the player starts at
                    player.x = new_x
                    player.y = new_y
                <span class="new-text">else:
                    # all rooms after the first:
                    # connect it to the previous room with a tunnel

                    # center coordinates of previous room
                    (prev_x, prev_y) = rooms[num_rooms - 1].center()

                    # flip a coin (random number that is either 0 or 1)
                    if randint(0, 1) == 1:
                        # first move horizontally, then vertically
                        self.create_h_tunnel(prev_x, new_x, prev_y)
                        self.create_v_tunnel(prev_y, new_y, new_x)
                    else:
                        # first move vertically, then horizontally
                        self.create_v_tunnel(prev_y, new_y, prev_x)
                        self.create_h_tunnel(prev_x, new_x, new_y)

                # finally, append the new room to the list
                rooms.append(new_room)
                num_rooms += 1</span></pre>

</div>

</div>


<p>Ce bloc &lsquo;else&rsquo; traite tous les cas où nous avons déjà crée au moins une pièce.
De manière à pouvoir parcourir notre donjon, on doit s&rsquo;assurer que les tunnels
soient bien connectés. On récupère le centre de la pièce précédente et, selon
un choix aléatoire (entre pile ou face, si vous voulez), on creuse notre tunnel
verticalement puis horizontalement ou le contraire. Une fois tout ceci réalisé
on ajoute la pièce à notre liste de pièces &lsquo;rooms&rsquo; et on incrémente le nombre
de pièces.</p>

<p>Et voilà ! Voici notre algorithme de génération de donjons, plutôt simple, mais
qui fonctionne. Lancez le projet et vous devriez vous trouver dans un donjon
procédural ! Remarquez que le NPC n&rsquo;est pas placé intelligemment et peut être
bloqué dans un mur ou non.</p>

<p>Si vous voulez voir le code actuel entièrement, <a href="https://github.com/TStand90/roguelike_tutorial_revised/tree/part3">cliquez ici</a>.</p>

<p><a href="/tutorials/tcod/part-4">Cliquez ici pour vous rendre à la partie suivante de ce tutoriel.</a></p>

<script src="/js/codetabs.js"></script>


    

    


</article>



        </div>

        <aside class="col-12 col-lg-3 ml-auto blog-sidebar">
    
    
        <section>
    
        
    
        
    
</section>
    
</aside>

      </div>
    </div>
    

    
      







<footer class="blog-footer w-100">
    <nav class="navbar navbar-light bg-light">
        <p class="w-100 text-center">Dernière mise à jour le 24 juillet 2019</p>
        <p class="w-100 text-center"><a href="#">Back to top</a></p>
    </nav>
</footer>

    

    
    
    <script src="https://code.jquery.com/jquery-3.3.1.slim.min.js" integrity="sha384-q8i/X+965DzO0rT7abK41JStQIAqVgRVzpbzo5smXKp4YfRvH+8abtTE1Pi6jizo" crossorigin="anonymous"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/popper.js/1.14.3/umd/popper.min.js" integrity="sha384-ZMP7rVo3mIykV+2+9J3UJ46jBk0WLaUAdn689aCwoqbBJiSnjAK/l8WvCWPIPm49" crossorigin="anonymous"></script>
    <script src="https://stackpath.bootstrapcdn.com/bootstrap/4.1.3/js/bootstrap.min.js" integrity="sha384-ChfqqxuZUCnJSK3+MXmPNIyE6ZbWh2IMqE241rYiqJxyMiZ6OW/JmZQ5stwEULTy" crossorigin="anonymous"></script>
  </body>
</html>
