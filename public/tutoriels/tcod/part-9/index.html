<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8">
<meta http-equiv="x-ua-compatible" content="ie=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

<meta property="og:title" content="Part 9 - Lancer des sorts" />
<meta property="og:description" content="Ajouter des potions de soin fut une grande avancée mais nous ne nous arrêterons pas là. Continuons maintenant avec quelques objets offensifs. Nous allons ajouter quelques parchemins qui donneront au joueur une attaque à distance à usage unique. Cela permet plus d&rsquo;options tactiques ce qui est une direction que vous devez chercher à améliorer dans un jeu.
Commençons simplement par un sort qui frappe l&rsquo;ennemi le plus proche. Nous allons créer un simple parchemin d&rsquo;éclair (scoll of lightning) qui va viser automatiquement l&rsquo;adversaire le plus proche." />
<meta property="og:type" content="article" />
<meta property="og:url" content="/tutoriels/tcod/part-9/" />
<meta property="article:published_time" content="2019-03-30T09:34:01-07:00"/>
<meta property="article:modified_time" content="2019-03-30T09:34:01-07:00"/>

<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Part 9 - Lancer des sorts"/>
<meta name="twitter:description" content="Ajouter des potions de soin fut une grande avancée mais nous ne nous arrêterons pas là. Continuons maintenant avec quelques objets offensifs. Nous allons ajouter quelques parchemins qui donneront au joueur une attaque à distance à usage unique. Cela permet plus d&rsquo;options tactiques ce qui est une direction que vous devez chercher à améliorer dans un jeu.
Commençons simplement par un sort qui frappe l&rsquo;ennemi le plus proche. Nous allons créer un simple parchemin d&rsquo;éclair (scoll of lightning) qui va viser automatiquement l&rsquo;adversaire le plus proche."/>



    <link rel="canonical" href="/tutoriels/tcod/part-9/">

    <title>
      
        Part 9 - Lancer des sorts | Tutoriel Roguelike
      
    </title>

    
    <link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.1.3/css/bootstrap.min.css" integrity="sha384-MCw98/SFnGE8fJT3GXwEOngsV7Zt27NXFoaoApmYm81iuXoPkFOJwJ8ERdknLPMO" crossorigin="anonymous">
    <link href="/css/style.css" rel="stylesheet">

    

    

    
  </head>
  <body>
    
      

<header class="blog-header">
    <nav class="navbar navbar-expand-md navbar-dark bg-dark">
        <a class="navbar-brand" href="/">
            Tutoriel Roguelike
        </a>
        <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNav" aria-controls="navbarNav" aria-expanded="false"
            aria-label="Toggle navigation">
            <span class="navbar-toggler-icon"></span>
        </button>
        <div class="collapse navbar-collapse justify-content-between" id="navbarNav">
            <ul class="navbar-nav">
                
                
                <li class="nav-item ">
                    
                        <a class="nav-link" href="/">Home</a>
                    
                </li>
                
                <li class="nav-item ">
                    
                        <a class="nav-link" href="/tutoriels/tcod/">Tutoriel TCOD</a>
                    
                </li>
                
                <li class="nav-item ">
                    
                        <a class="nav-link" href="/about/">A propos</a>
                    
                </li>
                
            </ul>
            
        </div>
    </nav>
</header>

    

    
    <div class="container">
      <div class="row">
        <div class="col-12 col-lg-8 blog-main">

          

<header>
    <h2 class="blog-post-title">
    <a class="text-dark" href="/tutoriels/tcod/part-9/">Part 9 - Lancer des sorts</a>
</h2>

    


<div class="blog-post-date text-secondary">
    
        <time datetime="2019-03-30">Mar 30, 2019</time>
    
    
</div>

    
    
    <hr>
</header>
<article class="blog-post">
    <p>Ajouter des potions de soin fut une grande avancée mais nous ne nous arrêterons
pas là. Continuons maintenant avec quelques objets offensifs. Nous allons
ajouter quelques parchemins qui donneront au joueur une attaque à distance à
usage unique. Cela permet plus d&rsquo;options tactiques ce qui est une direction
que vous devez chercher à améliorer dans un jeu.</p>

<p>Commençons simplement par un sort qui frappe l&rsquo;ennemi le plus proche. Nous
allons créer un simple parchemin d&rsquo;éclair (scoll of lightning) qui va viser
automatiquement l&rsquo;adversaire le plus proche. Commencez par ajouter la fonction
à <code>item_functions.py</code></p>

<div>
  <button class="btn btn-primary data-toggle-tab active" data-toggle-tab="diff">
    Diff
  </button>
  <button class="btn btn-secondary data-toggle-tab" data-toggle-tab="original">
    Original
  </button>

   <div class="data-pane active" data-pane="diff">
   <div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-diff" data-lang="diff">def heal(*args, **kwargs):
    ...

<span style="color:#a6e22e">+def cast_lightning(*args, **kwargs):
</span><span style="color:#a6e22e">+   caster = args[0]
</span><span style="color:#a6e22e">+   entities = kwargs.get(&#39;entities&#39;)
</span><span style="color:#a6e22e">+   fov_map = kwargs.get(&#39;fov_map&#39;)
</span><span style="color:#a6e22e">+   damage = kwargs.get(&#39;damage&#39;)
</span><span style="color:#a6e22e">+   maximum_range = kwargs.get(&#39;maximum_range&#39;)
</span><span style="color:#a6e22e">+
</span><span style="color:#a6e22e">+   results = []
</span><span style="color:#a6e22e">+
</span><span style="color:#a6e22e">+   target = None
</span><span style="color:#a6e22e">+   closest_distance = maximum_range + 1
</span><span style="color:#a6e22e">+
</span><span style="color:#a6e22e">+   for entity in entities:
</span><span style="color:#a6e22e">+       if entity.fighter and entity != caster and libtcod.map_is_in_fov(fov_map, entity.x, entity.y):
</span><span style="color:#a6e22e">+           distance = caster.distance_to(entity)
</span><span style="color:#a6e22e">+
</span><span style="color:#a6e22e">+           if distance &lt; closest_distance:
</span><span style="color:#a6e22e">+               target = entity
</span><span style="color:#a6e22e">+               closest_distance = distance
</span><span style="color:#a6e22e">+
</span><span style="color:#a6e22e">+   if target:
</span><span style="color:#a6e22e">+       results.append({&#39;consumed&#39;: True, &#39;target&#39;: target, &#39;message&#39;: Message(&#39;A lighting bolt strikes the {0} with a loud thunder! The damage is {1}&#39;.format(target.name, damage))})
</span><span style="color:#a6e22e">+       results.extend(target.fighter.take_damage(damage))
</span><span style="color:#a6e22e">+   else:
</span><span style="color:#a6e22e">+       results.append({&#39;consumed&#39;: False, &#39;target&#39;: None, &#39;message&#39;: Message(&#39;No enemy is close enough to strike.&#39;, libtcod.red)})
</span><span style="color:#a6e22e">+
</span><span style="color:#a6e22e">+   return results
</span></code></pre></div>

</div>
<div class="data-pane" data-pane="original">
  
<pre>def heal(*args, **kwargs):
    ...

<span class="new-text">def cast_lightning(*args, **kwargs):
    caster = args[0]
    entities = kwargs.get('entities')
    fov_map = kwargs.get('fov_map')
    damage = kwargs.get('damage')
    maximum_range = kwargs.get('maximum_range')

    results = []

    target = None
    closest_distance = maximum_range + 1

    for entity in entities:
        if entity.fighter and entity != caster and libtcod.map_is_in_fov(fov_map, entity.x, entity.y):
            distance = caster.distance_to(entity)

            if distance < closest_distance:
                target = entity
                closest_distance = distance

    if target:
        results.append({'consumed': True, 'target': target, 'message': Message('A lighting bolt strikes the {0} with a loud thunder! The damage is {1}'.format(target.name, damage))})
        results.extend(target.fighter.take_damage(damage))
    else:
        results.append({'consumed': False, 'target': None, 'message': Message('No enemy is close enough to strike.', libtcod.red)})

    return results</span></pre>

</div>

</div>


<p>Maintenant nous devons en déposer quelqu&rsquo;uns uns sur la carte. La plupart des
items seront des potions de soin mais nous allons ajouter quelques parchemins
d&rsquo;éclair. Dans <code>game_map.py</code> :</p>

<div>
  <button class="btn btn-primary data-toggle-tab active" data-toggle-tab="diff">
    Diff
  </button>
  <button class="btn btn-secondary data-toggle-tab" data-toggle-tab="original">
    Original
  </button>

   <div class="data-pane active" data-pane="diff">
   <div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-diff" data-lang="diff">            ...
            if not any([entity for entity in entities if entity.x == x and entity.y == y]):
<span style="color:#a6e22e">+               item_chance = randint(0, 100)
</span><span style="color:#a6e22e"></span><span style="color:#f92672">-               item_component = Item(use_function=heal, amount=4)
</span><span style="color:#f92672">-               item = Entity(x, y, &#39;!&#39;, libtcod.violet, &#39;Healing Potion&#39;, render_order=RenderOrder.ITEM,
</span><span style="color:#f92672">-                              item=item_component)
</span><span style="color:#f92672"></span><span style="color:#a6e22e">+
</span><span style="color:#a6e22e">+               if item_chance &lt; 70:
</span><span style="color:#a6e22e">+                   item_component = Item(use_function=heal, amount=4)
</span><span style="color:#a6e22e">+                   item = Entity(x, y, &#39;!&#39;, libtcod.violet, &#39;Healing Potion&#39;, render_order=RenderOrder.ITEM,
</span><span style="color:#a6e22e">+                                 item=item_component)
</span><span style="color:#a6e22e">+               else:
</span><span style="color:#a6e22e">+                   item_component = Item(use_function=cast_lightning, damage=20, maximum_range=5)
</span><span style="color:#a6e22e">+                   item = Entity(x, y, &#39;#&#39;, libtcod.yellow, &#39;Lightning Scroll&#39;, render_order=RenderOrder.ITEM,
</span><span style="color:#a6e22e">+                                 item=item_component)
</span></code></pre></div>

</div>
<div class="data-pane" data-pane="original">
  
<pre>            ...
            if not any([entity for entity in entities if entity.x == x and entity.y == y]):
                <span class="new-text">item_chance = randint(0, 100)

                if item_chance < 70:</span>
                    <span style="color: blue">item_component = Item(use_function=heal, amount=4)
                    item = Entity(x, y, '!', libtcod.violet, 'Healing Potion', render_order=RenderOrder.ITEM,
                                  item=item_component)</span>
                <span class="new-text">else:
                    item_component = Item(use_function=cast_lightning, damage=20, maximum_range=5)
                    item = Entity(x, y, '#', libtcod.yellow, 'Lightning Scroll', render_order=RenderOrder.ITEM,
                                  item=item_component)</span></pre>

</div>

</div>


<p>Assurez-vous d&rsquo;importer <code>cast_lightning</code> en haut du fichier.</p>

<div>
  <button class="btn btn-primary data-toggle-tab active" data-toggle-tab="diff">
    Diff
  </button>
  <button class="btn btn-secondary data-toggle-tab" data-toggle-tab="original">
    Original
  </button>

   <div class="data-pane active" data-pane="diff">
   <div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-diff" data-lang="diff">...
from entity import Entity

<span style="color:#f92672">-from item_functions import heal
</span><span style="color:#f92672"></span><span style="color:#a6e22e">+from item_functions import cast_lightning, heal
</span><span style="color:#a6e22e"></span>
from map_objects.rectangle import Rect
...
</code></pre></div>

</div>
<div class="data-pane" data-pane="original">
  
<pre>...
from entity import Entity

from item_functions import <span class="new-text">cast_lightning,</span> heal

from map_objects.rectangle import Rect
...</pre>

</div>

</div>


<p>Enfin, nous allons ajuster notre appel à &ldquo;utiliser&rdquo; dans <code>engine.py</code>, notre
parchemin d&rsquo;éclair ayant besoin de davantage d&rsquo;arguments qu&rsquo;on n&rsquo;en passe
actuellement.</p>

<div>
  <button class="btn btn-primary data-toggle-tab active" data-toggle-tab="diff">
    Diff
  </button>
  <button class="btn btn-secondary data-toggle-tab" data-toggle-tab="original">
    Original
  </button>

   <div class="data-pane active" data-pane="diff">
   <div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-diff" data-lang="diff">            ...
            if game_state == GameStates.SHOW_INVENTORY:
<span style="color:#f92672">-               player_turn_results.extend(player.inventory.use(item))
</span><span style="color:#f92672"></span><span style="color:#a6e22e">+               player_turn_results.extend(player.inventory.use(item, entities=entities, fov_map=fov_map))
</span><span style="color:#a6e22e"></span>            elif game_state == GameStates.DROP_INVENTORY:
                player_turn_results.extend(player.inventory.drop_item(item))
</code></pre></div>

</div>
<div class="data-pane" data-pane="original">
  
<pre>            ...
            if game_state == GameStates.SHOW_INVENTORY:
                <span class="crossed-out-text">player_turn_results.extend(player.inventory.use(item))</span>
                <span class="new-text">player_turn_results.extend(player.inventory.use(item, entities=entities, fov_map=fov_map))</span>
            elif game_state == GameStates.DROP_INVENTORY:
                player_turn_results.extend(player.inventory.drop_item(item))</pre>

</div>

</div>


<p>Lancez le projet et vous devriez avoir un parchemin d&rsquo;éclair fonctionnel.
C&rsquo;était plutôt simple !</p>

<p><em>*Conseil : pour tester vous pouvez augmenter le nombre maximal d&rsquo;items par
pièce.</em></p>

<p>Inutile de le dire, le sort serait bien plus pratique si on pouvait choisir sa
cible. Nous n&rsquo;allons pas changer le sort d&rsquo;éclair mais plutôt ajouter un autre
type de sort qui permette de viser. Concentrons nous sur une boule de feu qui
permette non seulement de viser mais aussi de toucher plusieurs ennemis dans
un rayon donné.</p>

<p>Nous allons travailler dans l&rsquo;autre sens cette fois, partant d&rsquo;un sort de boule
de feu &ldquo;fireball&rdquo; nous allons modifier tout le reste pour le faire fonctionner.
Voici le sort de boule de feu qui va dans <code>item_functions.py</code> :</p>

<div>
  <button class="btn btn-primary data-toggle-tab active" data-toggle-tab="diff">
    Diff
  </button>
  <button class="btn btn-secondary data-toggle-tab" data-toggle-tab="original">
    Original
  </button>

   <div class="data-pane active" data-pane="diff">
   <div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-diff" data-lang="diff">...
def cast_lightning(*args, **kwargs):
    ...

<span style="color:#a6e22e">+def cast_fireball(*args, **kwargs):
</span><span style="color:#a6e22e">+   entities = kwargs.get(&#39;entities&#39;)
</span><span style="color:#a6e22e">+   fov_map = kwargs.get(&#39;fov_map&#39;)
</span><span style="color:#a6e22e">+   damage = kwargs.get(&#39;damage&#39;)
</span><span style="color:#a6e22e">+   radius = kwargs.get(&#39;radius&#39;)
</span><span style="color:#a6e22e">+   target_x = kwargs.get(&#39;target_x&#39;)
</span><span style="color:#a6e22e">+   target_y = kwargs.get(&#39;target_y&#39;)
</span><span style="color:#a6e22e">+
</span><span style="color:#a6e22e">+   results = []
</span><span style="color:#a6e22e">+
</span><span style="color:#a6e22e">+   if not libtcod.map_is_in_fov(fov_map, target_x, target_y):
</span><span style="color:#a6e22e">+       results.append({&#39;consumed&#39;: False, &#39;message&#39;: Message(&#39;You cannot target a tile outside your field of view.&#39;, libtcod.yellow)})
</span><span style="color:#a6e22e">+       return results
</span><span style="color:#a6e22e">+
</span><span style="color:#a6e22e">+   results.append({&#39;consumed&#39;: True, &#39;message&#39;: Message(&#39;The fireball explodes, burning everything within {0} tiles!&#39;.format(radius), libtcod.orange)})
</span><span style="color:#a6e22e">+
</span><span style="color:#a6e22e">+   for entity in entities:
</span><span style="color:#a6e22e">+       if entity.distance(target_x, target_y) &lt;= radius and entity.fighter:
</span><span style="color:#a6e22e">+           results.append({&#39;message&#39;: Message(&#39;The {0} gets burned for {1} hit points.&#39;.format(entity.name, damage), libtcod.orange)})
</span><span style="color:#a6e22e">+           results.extend(entity.fighter.take_damage(damage))
</span><span style="color:#a6e22e">+
</span><span style="color:#a6e22e">+   return results
</span></code></pre></div>

</div>
<div class="data-pane" data-pane="original">
  
<pre>...
def cast_lightning(*args, **kwargs):
    ...

<span class="new-text">def cast_fireball(*args, **kwargs):
    entities = kwargs.get('entities')
    fov_map = kwargs.get('fov_map')
    damage = kwargs.get('damage')
    radius = kwargs.get('radius')
    target_x = kwargs.get('target_x')
    target_y = kwargs.get('target_y')

    results = []

    if not libtcod.map_is_in_fov(fov_map, target_x, target_y):
        results.append({'consumed': False, 'message': Message('You cannot target a tile outside your field of view.', libtcod.yellow)})
        return results

    results.append({'consumed': True, 'message': Message('The fireball explodes, burning everything within {0} tiles!'.format(radius), libtcod.orange)})

    for entity in entities:
        if entity.distance(target_x, target_y) <= radius and entity.fighter:
            results.append({'message': Message('The {0} gets burned for {1} hit points.'.format(entity.name, damage), libtcod.orange)})
            results.extend(entity.fighter.take_damage(damage))

    return results</span></pre>

</div>

</div>


<p>Que devons-nous changer pour faire marcher cette fonction ? La manière évidente
est de passer les dégâts, le rayon et la position de la cible. Dégâts et rayon
sont simples, on peut le faire quand on crée l&rsquo;objet dans <code>place_entities</code>. La
visée est plus délicate, on n&rsquo;en connaît rien tant que le joueur n&rsquo;a pas choisi
une tuile après avoir utilisé l&rsquo;objet.</p>

<p>Nous allons avoir besoin d&rsquo;un autre état du jeu pour la visée. Quand le joueur
choisit un certain type d&rsquo;objet, le jeu va lui demander de choisir une position
avant de continuer. Le joueur peut alors cliquer sur une position et faire un
clic droit pour annuler. Nous aurons donc besoin d&rsquo;un nouveau gestionnaire de
saisie.</p>

<p>Commençez par la partie facile : ajouter un nouvel état ) <code>GameStates</code> :</p>

<div>
  <button class="btn btn-primary data-toggle-tab active" data-toggle-tab="diff">
    Diff
  </button>
  <button class="btn btn-secondary data-toggle-tab" data-toggle-tab="original">
    Original
  </button>

   <div class="data-pane active" data-pane="diff">
   <div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-diff" data-lang="diff">class GameStates(Enum):
    PLAYERS_TURN = 1
    ENEMY_TURN = 2
    PLAYER_DEAD = 3
    SHOW_INVENTORY = 4
    DROP_INVENTORY = 5
<span style="color:#a6e22e">+   TARGETING = 6
</span></code></pre></div>

</div>
<div class="data-pane" data-pane="original">
  
<pre>class GameStates(Enum):
    PLAYERS_TURN = 1
    ENEMY_TURN = 2
    PLAYER_DEAD = 3
    SHOW_INVENTORY = 4
    DROP_INVENTORY = 5
    <span class="new-text">TARGETING = 6</span></pre>

</div>

</div>


<p>Maitenant modifiez le gestionnaire de saisie. Nous allons ajouter une fonction
pour les touches quand on vise ainsi qu&rsquo;un gestionnaire de souris générique
pour savoir où vise le joueur.</p>

<div>
  <button class="btn btn-primary data-toggle-tab active" data-toggle-tab="diff">
    Diff
  </button>
  <button class="btn btn-secondary data-toggle-tab" data-toggle-tab="original">
    Original
  </button>

   <div class="data-pane active" data-pane="diff">
   <div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-diff" data-lang="diff">def handle_keys(key, game_state):
    if game_state == GameStates.PLAYERS_TURN:
        return handle_player_turn_keys(key)
    elif game_state == GameStates.PLAYER_DEAD:
        return handle_player_dead_keys(key)
<span style="color:#a6e22e">+   elif game_state == GameStates.TARGETING:
</span><span style="color:#a6e22e">+       return handle_targeting_keys(key)
</span><span style="color:#a6e22e"></span>    elif game_state in (GameStates.SHOW_INVENTORY, GameStates.DROP_INVENTORY):
        return handle_inventory_keys(key)
    ...


<span style="color:#a6e22e">+def handle_targeting_keys(key):
</span><span style="color:#a6e22e">+   if key.vk == libtcod.KEY_ESCAPE:
</span><span style="color:#a6e22e">+       return {&#39;exit&#39;: True}
</span><span style="color:#a6e22e">+
</span><span style="color:#a6e22e">+   return {}
</span><span style="color:#a6e22e"></span>
def handle_player_dead_keys(key):
    ...


<span style="color:#a6e22e">+def handle_mouse(mouse):
</span><span style="color:#a6e22e">+   (x, y) = (mouse.cx, mouse.cy)
</span><span style="color:#a6e22e">+
</span><span style="color:#a6e22e">+   if mouse.lbutton_pressed:
</span><span style="color:#a6e22e">+       return {&#39;left_click&#39;: (x, y)}
</span><span style="color:#a6e22e">+   elif mouse.rbutton_pressed:
</span><span style="color:#a6e22e">+       return {&#39;right_click&#39;: (x, y)}
</span><span style="color:#a6e22e">+
</span><span style="color:#a6e22e">+   return {}
</span></code></pre></div>

</div>
<div class="data-pane" data-pane="original">
  
<pre>def handle_keys(key, game_state):
    if game_state == GameStates.PLAYERS_TURN:
        return handle_player_turn_keys(key)
    elif game_state == GameStates.PLAYER_DEAD:
        return handle_player_dead_keys(key)
    <span class="new-text">elif game_state == GameStates.TARGETING:
        return handle_targeting_keys(key)</span>
    elif game_state in (GameStates.SHOW_INVENTORY, GameStates.DROP_INVENTORY):
        return handle_inventory_keys(key)
    ...


<span class="new-text">def handle_targeting_keys(key):
    if key.vk == libtcod.KEY_ESCAPE:
        return {'exit': True}

    return {}</span>

def handle_player_dead_keys(key):
    ...


<span class="new-text">def handle_mouse(mouse):
    (x, y) = (mouse.cx, mouse.cy)

    if mouse.lbutton_pressed:
        return {'left_click': (x, y)}
    elif mouse.rbutton_pressed:
        return {'right_click': (x, y)}

    return {}</span></pre>

</div>

</div>


<p>Si le joueur est en mode visée, la seule touche acceptée est Escape, ce qui
annule la visée. Le gestionnaire de souris ne tient pas compte de l&rsquo;état du
jeu, il ne fait que dire au moteur si le bouton gauche ou droit a été cliqué.
Le moteur devra décider ce qu&rsquo;il doit en faire.
Modifiez <code>engine.py</code> pour recevoir les événements souris.</p>

<div>
  <button class="btn btn-primary data-toggle-tab active" data-toggle-tab="diff">
    Diff
  </button>
  <button class="btn btn-secondary data-toggle-tab" data-toggle-tab="original">
    Original
  </button>

   <div class="data-pane active" data-pane="diff">
   <div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-diff" data-lang="diff">        ...
        action = handle_keys(key, game_state)
<span style="color:#a6e22e">+       mouse_action = handle_mouse(mouse)
</span><span style="color:#a6e22e"></span>
        move = action.get(&#39;move&#39;)
        pickup = action.get(&#39;pickup&#39;)
        show_inventory = action.get(&#39;show_inventory&#39;)
        inventory_index = action.get(&#39;inventory_index&#39;)
        exit = action.get(&#39;exit&#39;)
        fullscreen = action.get(&#39;fullscreen&#39;)

<span style="color:#a6e22e">+       left_click = mouse_action.get(&#39;left_click&#39;)
</span><span style="color:#a6e22e">+       right_click = mouse_action.get(&#39;right_click&#39;)
</span><span style="color:#a6e22e"></span>
        player_turn_results = []
</code></pre></div>

</div>
<div class="data-pane" data-pane="original">
  
<pre>        ...
        action = handle_keys(key, game_state)
        <span class="new-text">mouse_action = handle_mouse(mouse)</span>

        move = action.get('move')
        pickup = action.get('pickup')
        show_inventory = action.get('show_inventory')
        inventory_index = action.get('inventory_index')
        exit = action.get('exit')
        fullscreen = action.get('fullscreen')

        <span class="new-text">left_click = mouse_action.get('left_click')
        right_click = mouse_action.get('right_click')</span>

        player_turn_results = []</pre>

</div>

</div>


<p>Bien sûr, nous devons importer <code>handle_mouse</code> dans <code>engine.py</code> :</p>

<div>
  <button class="btn btn-primary data-toggle-tab active" data-toggle-tab="diff">
    Diff
  </button>
  <button class="btn btn-secondary data-toggle-tab" data-toggle-tab="original">
    Original
  </button>

   <div class="data-pane active" data-pane="diff">
   <div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-diff" data-lang="diff">...
from game_states import GameStates
<span style="color:#f92672">-from input_handlers import handle_keys
</span><span style="color:#f92672"></span><span style="color:#a6e22e">+from input_handlers import handle_keys, handle_mouse
</span><span style="color:#a6e22e"></span>from map_objects.game_map import GameMap
...
</code></pre></div>

</div>
<div class="data-pane" data-pane="original">
  
<pre>...
from game_states import GameStates
from input_handlers import handle_keys<span class="new-text">, handle_mouse</span>
from map_objects.game_map import GameMap
...</pre>

</div>

</div>


<p>Mais comment savons-nous qu&rsquo;un certain item a besoin d&rsquo;une visée ? Nous pouvons
ajouter un attribut au composant <code>Item</code> qui nous l&rsquo;indiquera. Nous devrions
aussi ajouter un message, affiché quand l&rsquo;utilisateur active l&rsquo;objet, pour
l&rsquo;informer qu&rsquo;une cible doit être choisie. Modifiez la fonction <code>__init__</code>
depuis <code>Item</code> comme ceci :</p>

<div>
  <button class="btn btn-primary data-toggle-tab active" data-toggle-tab="diff">
    Diff
  </button>
  <button class="btn btn-secondary data-toggle-tab" data-toggle-tab="original">
    Original
  </button>

   <div class="data-pane active" data-pane="diff">
   <div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-diff" data-lang="diff">class Item:
<span style="color:#f92672">-   def __init__(self, use_function=None, **kwargs):
</span><span style="color:#f92672"></span><span style="color:#a6e22e">+   def __init__(self, use_function=None, targeting=False, targeting_message=None, **kwargs):
</span><span style="color:#a6e22e"></span>        self.use_function = use_function
<span style="color:#a6e22e">+       self.targeting = targeting
</span><span style="color:#a6e22e">+       self.targeting_message = targeting_message
</span><span style="color:#a6e22e"></span>        self.function_kwargs = kwargs
</code></pre></div>

</div>
<div class="data-pane" data-pane="original">
  
<pre>class Item:
    def __init__(self, use_function=None, <span class="new-text">targeting=False, targeting_message=None,</span> **kwargs):
        self.use_function = use_function
        <span class="new-text">self.targeting = targeting
        self.targeting_message = targeting_message</span>
        self.function_kwargs = kwargs</pre>

</div>

</div>


<p>Parce que les valeurs de <code>targeting</code> et <code>targeting_message</code> sont None par
défaut, nous n&rsquo;avons pas à nous soucier de modifier les objets que nous avons
déjà crée.</p>

<p>Nous devrons modifier notre fonction <code>use</code> depuis <code>Inventory</code> pour tenir compte
de la variable de visée. Si l&rsquo;objet a besoin d&rsquo;une cible, nous devrions renvoyer
un résultat qui l&rsquo;indique au moteur plutôt que de consommer l&rsquo;objet. Sinon, on
continue comme avant. Ajoutez une nouvelle expression &ldquo;if&rdquo; à <code>use</code> et entourez
le code précédent dans un bloc &ldquo;else&rdquo; ainsi :</p>

<div>
  <button class="btn btn-primary data-toggle-tab active" data-toggle-tab="diff">
    Diff
  </button>
  <button class="btn btn-secondary data-toggle-tab" data-toggle-tab="original">
    Original
  </button>

   <div class="data-pane active" data-pane="diff">
   <div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-diff" data-lang="diff">    def use(self, item_entity, **kwargs):
        results = []

        item_component = item_entity.item

        if item_component.use_function is None:
            results.append({&#39;message&#39;: Message(&#39;The {0} cannot be used&#39;.format(item_entity.name), libtcod.yellow)})
        else:
<span style="color:#f92672">-           kwargs = {**item_component.function_kwargs, **kwargs}
</span><span style="color:#f92672">-           item_use_results = item_component.use_function(self.owner, **kwargs)
</span><span style="color:#f92672"></span>
<span style="color:#f92672">-           for item_use_result in item_use_results:
</span><span style="color:#f92672">-               if item_use_result.get(&#39;consumed&#39;):
</span><span style="color:#f92672">-                   self.remove_item(item_entity)
</span><span style="color:#f92672">-
</span><span style="color:#f92672">-           results.extend(item_use_results)
</span><span style="color:#f92672"></span><span style="color:#a6e22e">+           if item_component.targeting and not (kwargs.get(&#39;target_x&#39;) or kwargs.get(&#39;target_y&#39;)):
</span><span style="color:#a6e22e">+               results.append({&#39;targeting&#39;: item_entity})
</span><span style="color:#a6e22e">+           else:
</span><span style="color:#a6e22e">+               kwargs = {**item_component.function_kwargs, **kwargs}
</span><span style="color:#a6e22e">+               item_use_results = item_component.use_function(self.owner, **kwargs)
</span><span style="color:#a6e22e">+
</span><span style="color:#a6e22e">+               for item_use_result in item_use_results:
</span><span style="color:#a6e22e">+                   if item_use_result.get(&#39;consumed&#39;):
</span><span style="color:#a6e22e">+                       self.remove_item(item_entity)
</span><span style="color:#a6e22e">+
</span><span style="color:#a6e22e">+                results.extend(item_use_results)
</span><span style="color:#a6e22e"></span>
        return results
</code></pre></div>

</div>
<div class="data-pane" data-pane="original">
  
<pre>    def use(self, item_entity, **kwargs):
        results = []

        item_component = item_entity.item

        if item_component.use_function is None:
            results.append({'message': Message('The {0} cannot be used'.format(item_entity.name), libtcod.yellow)})
        else:
            <span class="new-text">if item_component.targeting and not (kwargs.get('target_x') or kwargs.get('target_y')):
                results.append({'targeting': item_entity})
            else:</span>
                <span style="color: blue">kwargs = {**item_component.function_kwargs, **kwargs}
                item_use_results = item_component.use_function(self.owner, **kwargs)

                for item_use_result in item_use_results:
                    if item_use_result.get('consumed'):
                        self.remove_item(item_entity)

                results.extend(item_use_results)</span>

        return results</pre>

</div>

</div>


<p>Simplement, on vérifie si l&rsquo;objet a &ldquo;targetting&rdquo; (visée) sur True et, si c&rsquo;est
le cas, si nous avons reçu les variables <code>target_x</code> et <code>target_y</code>. Sinon, on
peut supposer que la cible n&rsquo;a pas été choisie et l&rsquo;état du jeu doit passer sur
visée. Si les variables sont reçues, on peut utiliser le sort normalement.</p>

<p>Maintenant, il faut modifier le moteur pour gérer ce nouveau type de sort.
Remarquez que le résultat renvoie une entité objet au moteur. C&rsquo;est parce que
le moteur aura besoin de se souvenir de l&rsquo;objet choisi. Aussi, nous aurons
besoin d&rsquo;une nouvelle variable juste avant la boucle principale pour conserver
l&rsquo;objet choisi s&rsquo;il a une visée.</p>

<div>
  <button class="btn btn-primary data-toggle-tab active" data-toggle-tab="diff">
    Diff
  </button>
  <button class="btn btn-secondary data-toggle-tab" data-toggle-tab="original">
    Original
  </button>

   <div class="data-pane active" data-pane="diff">
   <div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-diff" data-lang="diff">    ...
    game_state = GameStates.PLAYERS_TURN
    previous_game_state = game_state

<span style="color:#a6e22e">+   targeting_item = None
</span><span style="color:#a6e22e"></span>
    while not libtcod.console_is_window_closed():
        ...
            message = player_turn_result.get(&#39;message&#39;)
            dead_entity = player_turn_result.get(&#39;dead&#39;)
            item_added = player_turn_result.get(&#39;item_added&#39;)
            item_consumed = player_turn_result.get(&#39;consumed&#39;)
            item_dropped = player_turn_result.get(&#39;item_dropped&#39;)
<span style="color:#a6e22e">+           targeting = player_turn_result.get(&#39;targeting&#39;)
</span><span style="color:#a6e22e"></span>            ...

            if item_consumed:
                game_state = GameStates.ENEMY_TURN

<span style="color:#a6e22e">+           if targeting:
</span><span style="color:#a6e22e">+               previous_game_state = GameStates.PLAYERS_TURN
</span><span style="color:#a6e22e">+               game_state = GameStates.TARGETING
</span><span style="color:#a6e22e">+
</span><span style="color:#a6e22e">+               targeting_item = targeting
</span><span style="color:#a6e22e">+
</span><span style="color:#a6e22e">+               message_log.add_message(targeting_item.item.targeting_message)
</span></code></pre></div>

</div>
<div class="data-pane" data-pane="original">
  
<pre>    ...
    game_state = GameStates.PLAYERS_TURN
    previous_game_state = game_state

    <span class="new-text">targeting_item = None</span>

    while not libtcod.console_is_window_closed():
        ...
            message = player_turn_result.get('message')
            dead_entity = player_turn_result.get('dead')
            item_added = player_turn_result.get('item_added')
            item_consumed = player_turn_result.get('consumed')
            item_dropped = player_turn_result.get('item_dropped')
            <span class="new-text">targeting = player_turn_result.get('targeting')</span>
            ...

            if item_consumed:
                game_state = GameStates.ENEMY_TURN

            <span class="new-text">if targeting:
                previous_game_state = GameStates.PLAYERS_TURN
                game_state = GameStates.TARGETING

                targeting_item = targeting

                message_log.add_message(targeting_item.item.targeting_message)</span></pre>

</div>

</div>


<p>Maintenant notre état de jeu va basculer sur visée quand on choisit un objet
de l&rsquo;inventaire qui en nécessite une. Remarquez qu&rsquo;on fait quelque chose
d&rsquo;étrange avec le précédent état du jeu : on le règle sur le tour du joueur
plutôt que le précédent état du jeu. Cela évitera de réouvrir l&rsquo;inventaire
quand on annule la visée.</p>

<p>Maintenant il faut faire quelque chose des clics gauche et droit ajoutés plus
tôt. Si le joueur fait un clic gauche, nous lançons la fonction &ldquo;use&rdquo; à nouveau
cette fois avec les variables de la cible. Si le joueur fait un clic droit, nous
annulons la visée. Nous pouvons aussi ajouter l&rsquo;annulation de la visée à Escape.</p>

<div>
  <button class="btn btn-primary data-toggle-tab active" data-toggle-tab="diff">
    Diff
  </button>
  <button class="btn btn-secondary data-toggle-tab" data-toggle-tab="original">
    Original
  </button>

   <div class="data-pane active" data-pane="diff">
   <div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-diff" data-lang="diff">        ...
        if inventory_index is not None and previous_game_state != GameStates.PLAYER_DEAD and inventory_index &lt; len(
                player.inventory.items):
            ...

<span style="color:#a6e22e">+       if game_state == GameStates.TARGETING:
</span><span style="color:#a6e22e">+           if left_click:
</span><span style="color:#a6e22e">+               target_x, target_y = left_click
</span><span style="color:#a6e22e">+
</span><span style="color:#a6e22e">+               item_use_results = player.inventory.use(targeting_item, entities=entities, fov_map=fov_map,
</span><span style="color:#a6e22e">+                                                       target_x=target_x, target_y=target_y)
</span><span style="color:#a6e22e">+               player_turn_results.extend(item_use_results)
</span><span style="color:#a6e22e">+           elif right_click:
</span><span style="color:#a6e22e">+               player_turn_results.append({&#39;targeting_cancelled&#39;: True})
</span><span style="color:#a6e22e"></span>
        if exit:
            if game_state in (GameStates.SHOW_INVENTORY, GameStates.DROP_INVENTORY):
                game_state = previous_game_state
<span style="color:#a6e22e">+           elif game_state == GameStates.TARGETING:
</span><span style="color:#a6e22e">+               player_turn_results.append({&#39;targeting_cancelled&#39;: True})
</span><span style="color:#a6e22e"></span>            else:
                return True

        if fullscreen:
            ...
</code></pre></div>

</div>
<div class="data-pane" data-pane="original">
  
<pre>        ...
        if inventory_index is not None and previous_game_state != GameStates.PLAYER_DEAD and inventory_index < len(
                player.inventory.items):
            ...

        <span class="new-text">if game_state == GameStates.TARGETING:
            if left_click:
                target_x, target_y = left_click

                item_use_results = player.inventory.use(targeting_item, entities=entities, fov_map=fov_map,
                                                        target_x=target_x, target_y=target_y)
                player_turn_results.extend(item_use_results)
            elif right_click:
                player_turn_results.append({'targeting_cancelled': True})</span>

        if exit:
            if game_state in (GameStates.SHOW_INVENTORY, GameStates.DROP_INVENTORY):
                game_state = previous_game_state
            <span class="new-text">elif game_state == GameStates.TARGETING:
                player_turn_results.append({'targeting_cancelled': True})</span>
            else:
                return True

        if fullscreen:
            ...</pre>

</div>

</div>


<p>Add the following to make the target cancellation revert the game state:</p>

<div>
  <button class="btn btn-primary data-toggle-tab active" data-toggle-tab="diff">
    Diff
  </button>
  <button class="btn btn-secondary data-toggle-tab" data-toggle-tab="original">
    Original
  </button>

   <div class="data-pane active" data-pane="diff">
   <div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-diff" data-lang="diff">            targeting = player_turn_result.get(&#39;targeting&#39;)
<span style="color:#a6e22e">+           targeting_cancelled = player_turn_result.get(&#39;targeting_cancelled&#39;)
</span><span style="color:#a6e22e"></span>
            if message:
                ...

<span style="color:#a6e22e">+           if targeting_cancelled:
</span><span style="color:#a6e22e">+               game_state = previous_game_state
</span><span style="color:#a6e22e">+
</span><span style="color:#a6e22e">+               message_log.add_message(Message(&#39;Targeting cancelled&#39;))
</span></code></pre></div>

</div>
<div class="data-pane" data-pane="original">
  
<pre>            targeting = player_turn_result.get('targeting')
            <span class="new-text">targeting_cancelled = player_turn_result.get('targeting_cancelled')</span>

            if message:
                ...

            <span class="new-text">if targeting_cancelled:
                game_state = previous_game_state

                message_log.add_message(Message('Targeting cancelled'))</span></pre>

</div>

</div>


<p>Enfin, ajoutons le parchemin de boule de feu sur la carte. Modifiez
<code>place_entities</code> comme ceci :</p>

<div>
  <button class="btn btn-primary data-toggle-tab active" data-toggle-tab="diff">
    Diff
  </button>
  <button class="btn btn-secondary data-toggle-tab" data-toggle-tab="original">
    Original
  </button>

   <div class="data-pane active" data-pane="diff">
   <div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-diff" data-lang="diff">                ...
                item_chance = randint(0, 100)

                if item_chance &lt; 70:
                    item_component = Item(use_function=heal, amount=4)
                    item = Entity(x, y, &#39;!&#39;, libtcod.violet, &#39;Healing Potion&#39;, render_order=RenderOrder.ITEM,
                                  item=item_component)
<span style="color:#a6e22e">+               elif item_chance &lt; 85:
</span><span style="color:#a6e22e">+                   item_component = Item(use_function=cast_fireball, targeting=True, targeting_message=Message(
</span><span style="color:#a6e22e">+                       &#39;Left-click a target tile for the fireball, or right-click to cancel.&#39;, libtcod.light_cyan),
</span><span style="color:#a6e22e">+                                         damage=12, radius=3)
</span><span style="color:#a6e22e">+                   item = Entity(x, y, &#39;#&#39;, libtcod.red, &#39;Fireball Scroll&#39;, render_order=RenderOrder.ITEM,
</span><span style="color:#a6e22e">+                                 item=item_component)
</span><span style="color:#a6e22e"></span>                else:
                    item_component = Item(use_function=cast_lightning, damage=20, maximum_range=5)
                    item = Entity(x, y, &#39;#&#39;, libtcod.yellow, &#39;Lightning Scroll&#39;, render_order=RenderOrder.ITEM,
                                  item=item_component)
</code></pre></div>

</div>
<div class="data-pane" data-pane="original">
  
<pre>                ...
                item_chance = randint(0, 100)

                if item_chance < 70:
                    item_component = Item(use_function=heal, amount=4)
                    item = Entity(x, y, '!', libtcod.violet, 'Healing Potion', render_order=RenderOrder.ITEM,
                                  item=item_component)
                <span class="new-text">elif item_chance < 85:
                    item_component = Item(use_function=cast_fireball, targeting=True, targeting_message=Message(
                        'Left-click a target tile for the fireball, or right-click to cancel.', libtcod.light_cyan),
                                          damage=12, radius=3)
                    item = Entity(x, y, '#', libtcod.red, 'Fireball Scroll', render_order=RenderOrder.ITEM,
                                  item=item_component)</span>
                else:
                    item_component = Item(use_function=cast_lightning, damage=20, maximum_range=5)
                    item = Entity(x, y, '#', libtcod.yellow, 'Lightning Scroll', render_order=RenderOrder.ITEM,
                                  item=item_component)</pre>

</div>

</div>


<p>Vous devez importer <code>cast_fireball</code> et <code>Message</code> :</p>

<div>
  <button class="btn btn-primary data-toggle-tab active" data-toggle-tab="diff">
    Diff
  </button>
  <button class="btn btn-secondary data-toggle-tab" data-toggle-tab="original">
    Original
  </button>

   <div class="data-pane active" data-pane="diff">
   <div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-diff" data-lang="diff">...
from entity import Entity

<span style="color:#a6e22e">+from game_messages import Message
</span><span style="color:#a6e22e"></span>
<span style="color:#f92672">-from item_functions import cast_lightning, heal
</span><span style="color:#f92672"></span><span style="color:#a6e22e">+from item_functions import cast_fireball, cast_lightning, heal
</span><span style="color:#a6e22e"></span>
from map_objects.rectangle import Rect
...
</code></pre></div>

</div>
<div class="data-pane" data-pane="original">
  
<pre>...
from entity import Entity

<span class="new-text">from game_messages import Message</span>

from item_functions import <span class="new-text">cast_fireball,</span> cast_lightning, heal

from map_objects.rectangle import Rect
...</pre>

</div>

</div>


<p>Il faut encore un changement pour que <code>cast_fireball</code> puisse fonctionner :
nous avons besoin d&rsquo;une fonction <code>distance</code> dans <code>Entity</code> pour obtenir la
distance entre une entité et un point arbitraire.</p>

<div>
  <button class="btn btn-primary data-toggle-tab active" data-toggle-tab="diff">
    Diff
  </button>
  <button class="btn btn-secondary data-toggle-tab" data-toggle-tab="original">
    Original
  </button>

   <div class="data-pane active" data-pane="diff">
   <div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-diff" data-lang="diff">    def move_towards(self, target_x, target_y, game_map, entities):
        ...

<span style="color:#a6e22e">+   def distance(self, x, y):
</span><span style="color:#a6e22e">+       return math.sqrt((x - self.x) ** 2 + (y - self.y) ** 2)
</span><span style="color:#a6e22e"></span>
    def distance_to(self, other):
        ...
</code></pre></div>

</div>
<div class="data-pane" data-pane="original">
  
<pre>
    def move_towards(self, target_x, target_y, game_map, entities):
        ...

    <span class="new-text">def distance(self, x, y):
        return math.sqrt((x - self.x) ** 2 + (y - self.y) ** 2)</span>

    def distance_to(self, other):
        ...</pre>

</div>

</div>


<p>Lancez le jeu et vous devriez avoir un sort de boule de feu qui fonctionne.
Soyez prudent, le joueur prend des dégâts si vous lancez le sort trop proche
de lui.</p>

<p>Ajoutons un dernier sort pour s&rsquo;amuser : confusion. Cela va demander de changer
la visée de l&rsquo;AI pour quelques tours et la rétablir à la normale une fois que
le sort est terminé.</p>

<p>Commençons par ajouter un état &ldquo;confus&rdquo; à l&rsquo;AI dans <code>ai.py</code> :</p>

<div>
  <button class="btn btn-primary data-toggle-tab active" data-toggle-tab="diff">
    Diff
  </button>
  <button class="btn btn-secondary data-toggle-tab" data-toggle-tab="original">
    Original
  </button>

   <div class="data-pane active" data-pane="diff">
   <div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-diff" data-lang="diff">import tcod as libtcod

<span style="color:#a6e22e">+from random import randint
</span><span style="color:#a6e22e">+
</span><span style="color:#a6e22e">+from game_messages import Message
</span><span style="color:#a6e22e"></span>

class BasicMonster:
    ...


<span style="color:#a6e22e">+class ConfusedMonster:
</span><span style="color:#a6e22e">+   def __init__(self, previous_ai, number_of_turns=10):
</span><span style="color:#a6e22e">+       self.previous_ai = previous_ai
</span><span style="color:#a6e22e">+       self.number_of_turns = number_of_turns
</span><span style="color:#a6e22e">+
</span><span style="color:#a6e22e">+   def take_turn(self, target, fov_map, game_map, entities):
</span><span style="color:#a6e22e">+       results = []
</span><span style="color:#a6e22e">+
</span><span style="color:#a6e22e">+       if self.number_of_turns &gt; 0:
</span><span style="color:#a6e22e">+           random_x = self.owner.x + randint(0, 2) - 1
</span><span style="color:#a6e22e">+           random_y = self.owner.y + randint(0, 2) - 1
</span><span style="color:#a6e22e">+
</span><span style="color:#a6e22e">+           if random_x != self.owner.x and random_y != self.owner.y:
</span><span style="color:#a6e22e">+               self.owner.move_towards(random_x, random_y, game_map, entities)
</span><span style="color:#a6e22e">+
</span><span style="color:#a6e22e">+           self.number_of_turns -= 1
</span><span style="color:#a6e22e">+       else:
</span><span style="color:#a6e22e">+           self.owner.ai = self.previous_ai
</span><span style="color:#a6e22e">+           results.append({&#39;message&#39;: Message(&#39;The {0} is no longer confused!&#39;.format(self.owner.name), libtcod.red)})
</span><span style="color:#a6e22e">+
</span><span style="color:#a6e22e">+       return results
</span></code></pre></div>

</div>
<div class="data-pane" data-pane="original">
  
<pre>import tcod as libtcod

<span class="new-text">from random import randint

from game_messages import Message</span>


class BasicMonster:
    ...


<span class="new-text">class ConfusedMonster:
    def __init__(self, previous_ai, number_of_turns=10):
        self.previous_ai = previous_ai
        self.number_of_turns = number_of_turns

    def take_turn(self, target, fov_map, game_map, entities):
        results = []

        if self.number_of_turns > 0:
            random_x = self.owner.x + randint(0, 2) - 1
            random_y = self.owner.y + randint(0, 2) - 1

            if random_x != self.owner.x and random_y != self.owner.y:
                self.owner.move_towards(random_x, random_y, game_map, entities)

            self.number_of_turns -= 1
        else:
            self.owner.ai = self.previous_ai
            results.append({'message': Message('The {0} is no longer confused!'.format(self.owner.name), libtcod.red)})

        return results</span></pre>

</div>

</div>


<p>La classe est initialisée avec un nombre de tours durant lesquels l&rsquo;entité est
confuse. On garde en mémoire l&rsquo;état précédent de l&rsquo;AI pour y revenir une fois
que la confusion est terminée. Pour la méthode <code>take_turn</code>, l&rsquo;entité se déplace
de manière aléatoire (ou reste sur place) et le compteur diminue. Une fois que
le compteur atteint 0, l&rsquo;entité n&rsquo;est plus confuse et revient à son AI
précédente.</p>

<p>Maintenant le sort de confusion. Ajouter à <code>item_functions.py</code> les éléments
suivants :</p>

<div>
  <button class="btn btn-primary data-toggle-tab active" data-toggle-tab="diff">
    Diff
  </button>
  <button class="btn btn-secondary data-toggle-tab" data-toggle-tab="original">
    Original
  </button>

   <div class="data-pane active" data-pane="diff">
   <div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-diff" data-lang="diff">def cast_fireball(*args, **kwargs):
    ...

<span style="color:#a6e22e">+def cast_confuse(*args, **kwargs):
</span><span style="color:#a6e22e">+   entities = kwargs.get(&#39;entities&#39;)
</span><span style="color:#a6e22e">+   fov_map = kwargs.get(&#39;fov_map&#39;)
</span><span style="color:#a6e22e">+   target_x = kwargs.get(&#39;target_x&#39;)
</span><span style="color:#a6e22e">+   target_y = kwargs.get(&#39;target_y&#39;)
</span><span style="color:#a6e22e">+
</span><span style="color:#a6e22e">+   results = []
</span><span style="color:#a6e22e">+
</span><span style="color:#a6e22e">+   if not libtcod.map_is_in_fov(fov_map, target_x, target_y):
</span><span style="color:#a6e22e">+       results.append({&#39;consumed&#39;: False, &#39;message&#39;: Message(&#39;You cannot target a tile outside your field of view.&#39;, libtcod.yellow)})
</span><span style="color:#a6e22e">+       return results
</span><span style="color:#a6e22e">+
</span><span style="color:#a6e22e">+   for entity in entities:
</span><span style="color:#a6e22e">+       if entity.x == target_x and entity.y == target_y and entity.ai:
</span><span style="color:#a6e22e">+           confused_ai = ConfusedMonster(entity.ai, 10)
</span><span style="color:#a6e22e">+
</span><span style="color:#a6e22e">+           confused_ai.owner = entity
</span><span style="color:#a6e22e">+           entity.ai = confused_ai
</span><span style="color:#a6e22e">+
</span><span style="color:#a6e22e">+           results.append({&#39;consumed&#39;: True, &#39;message&#39;: Message(&#39;The eyes of the {0} look vacant, as he starts to stumble around!&#39;.format(entity.name), libtcod.light_green)})
</span><span style="color:#a6e22e">+
</span><span style="color:#a6e22e">+           break
</span><span style="color:#a6e22e">+   else:
</span><span style="color:#a6e22e">+       results.append({&#39;consumed&#39;: False, &#39;message&#39;: Message(&#39;There is no targetable enemy at that location.&#39;, libtcod.yellow)})
</span><span style="color:#a6e22e">+
</span><span style="color:#a6e22e">+   return results
</span><span style="color:#a6e22e">+
</span></code></pre></div>

</div>
<div class="data-pane" data-pane="original">
  
<pre>def cast_fireball(*args, **kwargs):
    ...

<span class="new-text">def cast_confuse(*args, **kwargs):
    entities = kwargs.get('entities')
    fov_map = kwargs.get('fov_map')
    target_x = kwargs.get('target_x')
    target_y = kwargs.get('target_y')

    results = []

    if not libtcod.map_is_in_fov(fov_map, target_x, target_y):
        results.append({'consumed': False, 'message': Message('You cannot target a tile outside your field of view.', libtcod.yellow)})
        return results

    for entity in entities:
        if entity.x == target_x and entity.y == target_y and entity.ai:
            confused_ai = ConfusedMonster(entity.ai, 10)

            confused_ai.owner = entity
            entity.ai = confused_ai

            results.append({'consumed': True, 'message': Message('The eyes of the {0} look vacant, as he starts to stumble around!'.format(entity.name), libtcod.light_green)})

            break
    else:
        results.append({'consumed': False, 'message': Message('There is no targetable enemy at that location.', libtcod.yellow)})

    return results
</span></pre>

</div>

</div>


<p>Nous devons importer la classe <code>ConfusedMonster</code> en haut du fichier :</p>

<div>
  <button class="btn btn-primary data-toggle-tab active" data-toggle-tab="diff">
    Diff
  </button>
  <button class="btn btn-secondary data-toggle-tab" data-toggle-tab="original">
    Original
  </button>

   <div class="data-pane active" data-pane="diff">
   <div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-diff" data-lang="diff">import tcod as libtcod

<span style="color:#a6e22e">+from components.ai import ConfusedMonster
</span><span style="color:#a6e22e"></span>
from game_messages import Message
...
</code></pre></div>

</div>
<div class="data-pane" data-pane="original">
  
<pre>import tcod as libtcod

<span class="new-text">from components.ai import ConfusedMonster</span>

from game_messages import Message
...</pre>

</div>

</div>


<p>Finally, we&rsquo;ll put the scroll on the map. First, import the
<code>cast_confuse</code> function:</p>

<div>
  <button class="btn btn-primary data-toggle-tab active" data-toggle-tab="diff">
    Diff
  </button>
  <button class="btn btn-secondary data-toggle-tab" data-toggle-tab="original">
    Original
  </button>

   <div class="data-pane active" data-pane="diff">
   <div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-diff" data-lang="diff">...
from game_messages import Message

<span style="color:#f92672">-from item_functions import cast_fireball, cast_lightning, heal
</span><span style="color:#f92672"></span><span style="color:#a6e22e">+from item_functions import cast_confuse, cast_fireball, cast_lightning, heal
</span><span style="color:#a6e22e"></span>
from map_objects.rectangle import Rect
...
</code></pre></div>

</div>
<div class="data-pane" data-pane="original">
  
<pre>...
from game_messages import Message

from item_functions import <span class="new-text">cast_confuse,</span> cast_fireball, cast_lightning, heal

from map_objects.rectangle import Rect
...</pre>

</div>

</div>


<p>Nous devons aussi modifier les chances d&rsquo;apparition de nos parchemins, de façon
à ce qu&rsquo;ils aient tous 10% de chance d&rsquo;apparaître.</p>

<div>
  <button class="btn btn-primary data-toggle-tab active" data-toggle-tab="diff">
    Diff
  </button>
  <button class="btn btn-secondary data-toggle-tab" data-toggle-tab="original">
    Original
  </button>

   <div class="data-pane active" data-pane="diff">
   <div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-diff" data-lang="diff">                if item_chance &lt; 70:
                    item_component = Item(use_function=heal, amount=4)
                    item = Entity(x, y, &#39;!&#39;, libtcod.violet, &#39;Healing Potion&#39;, render_order=RenderOrder.ITEM,
                                  item=item_component)
<span style="color:#f92672">-               elif item_chance &lt; 85:
</span><span style="color:#f92672"></span><span style="color:#a6e22e">+               elif item_chance &lt; 80:
</span><span style="color:#a6e22e"></span>                    item_component = Item(use_function=cast_fireball, targeting=True, targeting_message=Message(
                        &#39;Left-click a target tile for the fireball, or right-click to cancel.&#39;, libtcod.light_cyan),
                                          damage=12, radius=3)
                    item = Entity(x, y, &#39;#&#39;, libtcod.red, &#39;Fireball Scroll&#39;, render_order=RenderOrder.ITEM,
                                  item=item_component)
<span style="color:#a6e22e">+               elif item_chance &lt; 90:
</span><span style="color:#a6e22e">+                   item_component = Item(use_function=cast_confuse, targeting=True, targeting_message=Message(
</span><span style="color:#a6e22e">+                       &#39;Left-click an enemy to confuse it, or right-click to cancel.&#39;, libtcod.light_cyan))
</span><span style="color:#a6e22e">+                   item = Entity(x, y, &#39;#&#39;, libtcod.light_pink, &#39;Confusion Scroll&#39;, render_order=RenderOrder.ITEM,
</span><span style="color:#a6e22e">+                                 item=item_component)
</span></code></pre></div>

</div>
<div class="data-pane" data-pane="original">
  
<pre>                if item_chance < 70:
                    item_component = Item(use_function=heal, amount=4)
                    item = Entity(x, y, '!', libtcod.violet, 'Healing Potion', render_order=RenderOrder.ITEM,
                                  item=item_component)
                <span class="crossed-out-text">elif item_chance < 85:</span>
                <span class="new-text">elif item_chance < 80:</span>
                    item_component = Item(use_function=cast_fireball, targeting=True, targeting_message=Message(
                        'Left-click a target tile for the fireball, or right-click to cancel.', libtcod.light_cyan),
                                          damage=12, radius=3)
                    item = Entity(x, y, '#', libtcod.red, 'Fireball Scroll', render_order=RenderOrder.ITEM,
                                  item=item_component)
                <span class="new-text">elif item_chance < 90:
                    item_component = Item(use_function=cast_confuse, targeting=True, targeting_message=Message(
                        'Left-click an enemy to confuse it, or right-click to cancel.', libtcod.light_cyan))
                    item = Entity(x, y, '#', libtcod.light_pink, 'Confusion Scroll', render_order=RenderOrder.ITEM,
                                  item=item_component)</span></pre>

</div>

</div>


<p>Lancez le projet maintenant et vous devriez pouvoir lancer confusion sur les
ennemis. Les ennemis confus vont gacher leur tours en se déplaçant aléatoirement
ou en restant sur place.</p>

<p>C&rsquo;est tout pour aujourd&rsquo;hui. Nous avons maintenant trois parchemins différents
que le joueur peut employer contre les ennemis. N&rsquo;hésitez pas à en ajouter
d&rsquo;autres !</p>

<p>Si vous voulez voir le code actuel entièrement, <a href="https://github.com/TStand90/roguelike_tutorial_revised/tree/part9">cliquez ici</a>.</p>

<p><a href="/tutorials/tcod/part-10">Cliquez ici pour vous rendre à la partie suivante de ce tutoriel.</a></p>

<script src="/js/codetabs.js"></script>


    

    


</article>



        </div>

        <aside class="col-12 col-lg-3 ml-auto blog-sidebar">
    
    
        <section>
    
        
    
        
    
</section>
    
</aside>

      </div>
    </div>
    

    
      







<footer class="blog-footer w-100">
    <nav class="navbar navbar-light bg-light">
        <p class="w-100 text-center">Dernière mise à jour le 24 juillet 2019</p>
        <p class="w-100 text-center"><a href="#">Back to top</a></p>
    </nav>
</footer>

    

    
    
    <script src="https://code.jquery.com/jquery-3.3.1.slim.min.js" integrity="sha384-q8i/X+965DzO0rT7abK41JStQIAqVgRVzpbzo5smXKp4YfRvH+8abtTE1Pi6jizo" crossorigin="anonymous"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/popper.js/1.14.3/umd/popper.min.js" integrity="sha384-ZMP7rVo3mIykV+2+9J3UJ46jBk0WLaUAdn689aCwoqbBJiSnjAK/l8WvCWPIPm49" crossorigin="anonymous"></script>
    <script src="https://stackpath.bootstrapcdn.com/bootstrap/4.1.3/js/bootstrap.min.js" integrity="sha384-ChfqqxuZUCnJSK3+MXmPNIyE6ZbWh2IMqE241rYiqJxyMiZ6OW/JmZQ5stwEULTy" crossorigin="anonymous"></script>
  </body>
</html>
