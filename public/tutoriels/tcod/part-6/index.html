<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8">
<meta http-equiv="x-ua-compatible" content="ie=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

<meta property="og:title" content="Part 6 - Faire mal (et prendre des coups)" />
<meta property="og:description" content="La dernière partie du tutorial a préparé les combats, il est temps de les implémenter.
De manière à créer des entités &ldquo;tuables&rdquo;, plutôt que d&rsquo;ajouter des &ldquo;points de vie&rdquo; à chaque entité, nous allons créer un composant, appelé Fighter qui va contenir l&rsquo;information relative au combat : HP, max HP, attaque et défense. Si une entité peut combattre ce composant lui sera attaché et sinon, il n&rsquo;en aura pas. Cette manière de procéder est appelé composition et c&rsquo;est une alternative à la programmation par héritage habituelle." />
<meta property="og:type" content="article" />
<meta property="og:url" content="/tutoriels/tcod/part-6/" />
<meta property="article:published_time" content="2019-03-30T09:33:50-07:00"/>
<meta property="article:modified_time" content="2019-03-30T09:33:50-07:00"/>

<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Part 6 - Faire mal (et prendre des coups)"/>
<meta name="twitter:description" content="La dernière partie du tutorial a préparé les combats, il est temps de les implémenter.
De manière à créer des entités &ldquo;tuables&rdquo;, plutôt que d&rsquo;ajouter des &ldquo;points de vie&rdquo; à chaque entité, nous allons créer un composant, appelé Fighter qui va contenir l&rsquo;information relative au combat : HP, max HP, attaque et défense. Si une entité peut combattre ce composant lui sera attaché et sinon, il n&rsquo;en aura pas. Cette manière de procéder est appelé composition et c&rsquo;est une alternative à la programmation par héritage habituelle."/>



    <link rel="canonical" href="/tutoriels/tcod/part-6/">

    <title>
      
        Part 6 - Faire mal (et prendre des coups) | Tutoriel Roguelike
      
    </title>

    
    <link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.1.3/css/bootstrap.min.css" integrity="sha384-MCw98/SFnGE8fJT3GXwEOngsV7Zt27NXFoaoApmYm81iuXoPkFOJwJ8ERdknLPMO" crossorigin="anonymous">
    <link href="/css/style.css" rel="stylesheet">

    

    

    
  </head>
  <body>
    
      

<header class="blog-header">
    <nav class="navbar navbar-expand-md navbar-dark bg-dark">
        <a class="navbar-brand" href="/">
            Tutoriel Roguelike
        </a>
        <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNav" aria-controls="navbarNav" aria-expanded="false"
            aria-label="Toggle navigation">
            <span class="navbar-toggler-icon"></span>
        </button>
        <div class="collapse navbar-collapse justify-content-between" id="navbarNav">
            <ul class="navbar-nav">
                
                
                <li class="nav-item ">
                    
                        <a class="nav-link" href="/">Home</a>
                    
                </li>
                
                <li class="nav-item ">
                    
                        <a class="nav-link" href="/tutoriels/tcod/">Tutoriel TCOD</a>
                    
                </li>
                
                <li class="nav-item ">
                    
                        <a class="nav-link" href="/about/">A propos</a>
                    
                </li>
                
            </ul>
            
        </div>
    </nav>
</header>

    

    
    <div class="container">
      <div class="row">
        <div class="col-12 col-lg-8 blog-main">

          

<header>
    <h2 class="blog-post-title">
    <a class="text-dark" href="/tutoriels/tcod/part-6/">Part 6 - Faire mal (et prendre des coups)</a>
</h2>

    


<div class="blog-post-date text-secondary">
    
        <time datetime="2019-03-30">Mar 30, 2019</time>
    
    
</div>

    
    
    <hr>
</header>
<article class="blog-post">
    <p>La dernière partie du tutorial a préparé les combats, il est temps de les
implémenter.</p>

<p>De manière à créer des entités &ldquo;tuables&rdquo;, plutôt que d&rsquo;ajouter des &ldquo;points de
vie&rdquo; à chaque entité, nous allons créer un <strong>composant</strong>, appelé <code>Fighter</code> qui
va contenir l&rsquo;information relative au combat : HP, max HP, attaque et défense.
Si une entité peut combattre ce composant lui sera attaché et sinon, il n&rsquo;en
aura pas. Cette manière de procéder est appelé <strong>composition</strong> et c&rsquo;est une
alternative à la programmation par héritage habituelle.</p>

<p>Créer un paquet Python (un dossier avec un fichier vide __init__.py) appelé
<code>components</code>. Ajoutez-y un fichier <code>fighter.py</code> contenant le code suivant :</p>

<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-py3" data-lang="py3"><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Fighter</span>:
    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">__init__</span>(self, hp, defense, power):
        self<span style="color:#f92672">.</span>max_hp <span style="color:#f92672">=</span> hp
        self<span style="color:#f92672">.</span>hp <span style="color:#f92672">=</span> hp
        self<span style="color:#f92672">.</span>defense <span style="color:#f92672">=</span> defense
        self<span style="color:#f92672">.</span>power <span style="color:#f92672">=</span> power</code></pre></div>

<p>Ces variables devraient sembler familières à quiconque a joué à un RPG. HP
désigne la santé de l&rsquo;entité, defense attenue les dégats et power est la force
d&rsquo;attaque de l&rsquo;entité. Peut-être que le jeu que vous envisagez dispose d&rsquo;un
système de combat plus complexe mais nous resterons simple.</p>

<p>Un autre composant dont nous aurons besoin défini l&rsquo;AI des ennemis. Certaines
entités (les ennemis) aurons une AI, d&rsquo;autres (le joueur, les objets) n&rsquo;en
auront pas. Nous reglerons notre boucle de jeu pour donner un tour à chaque
entité qui a une AI de prendre un tour et les autres n&rsquo;auront pas de tour.</p>

<p>Créer un fichier dans <code>components</code> appelé <code>ai.py</code> et ajouter la classe suivante
dedans :</p>

<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-py3" data-lang="py3"><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">BasicMonster</span>:
    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">take_turn</span>(self):
        print(<span style="color:#e6db74">&#39;The &#39;</span> <span style="color:#f92672">+</span> self<span style="color:#f92672">.</span>owner<span style="color:#f92672">.</span>name <span style="color:#f92672">+</span> <span style="color:#e6db74">&#39; wonders when it will get to move.&#39;</span>)</code></pre></div>

<p>Nous avons défini une méthode de base appelée <code>take_turn</code> qui sera appelée
dans notre boucle de jeu dans un instant. C&rsquo;est juste un exemple pour l&rsquo;instant
mais, dès la fin du chapitre, la fonction <code>take_turn</code> va réellement déplacer
l&rsquo;entité.</p>

<p>Notre classe étant en place, nous allons porter notre attention sur la classe
<code>Entity</code> une fois encore. Nous devons lui passer les composants via le
constructeur comme nous avons fait à chaque fois. Modifiez la fonction <code>__init__</code>
dans <code>Entity</code> pour qu&rsquo;elle ressemble à :</p>

<div>
  <button class="btn btn-primary data-toggle-tab active" data-toggle-tab="diff">
    Diff
  </button>
  <button class="btn btn-secondary data-toggle-tab" data-toggle-tab="original">
    Original
  </button>

   <div class="data-pane active" data-pane="diff">
   <div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-diff" data-lang="diff">class Entity:
<span style="color:#f92672">-   def __init__(self, x, y, char, color, name, blocks=False):
</span><span style="color:#f92672"></span><span style="color:#a6e22e">+   def __init__(self, x, y, char, color, name, blocks=False, fighter=None, ai=None):
</span><span style="color:#a6e22e"></span>        self.x = x
        self.y = y
        self.char = char
        self.color = color
        self.name = name
        self.blocks = blocks
<span style="color:#a6e22e">+       self.fighter = fighter
</span><span style="color:#a6e22e">+       self.ai = ai
</span><span style="color:#a6e22e">+
</span><span style="color:#a6e22e">+       if self.fighter:
</span><span style="color:#a6e22e">+           self.fighter.owner = self
</span><span style="color:#a6e22e">+
</span><span style="color:#a6e22e">+       if self.ai:
</span><span style="color:#a6e22e">+           self.ai.owner = self
</span></code></pre></div>

</div>
<div class="data-pane" data-pane="original">
  
<pre>class Entity:
    <span class="crossed-out-text">def __init__(self, x, y, char, color, name, blocks=False):</span>
    <span class="new-text">def __init__(self, x, y, char, color, name, blocks=False, fighter=None, ai=None):</span>
        self.x = x
        self.y = y
        self.char = char
        self.color = color
        self.name = name
        self.blocks = blocks
        <span class="new-text">self.fighter = fighter
        self.ai = ai

        if self.fighter:
            self.fighter.owner = self

        if self.ai:
            self.ai.owner = self</span></pre>

</div>

</div>


<p>Ainsi les composants <code>fighter</code> et <code>ai</code> sont optionnels et les entités qui n&rsquo;en
ont pas pas besoin n&rsquo;en dépendront pas pour faire quoi que ce soit.</p>

<p>Pourquoi devoir régler le propriétaire du composant sur <code>self</code> ? Parce que nous
aurons besoin d&rsquo;accéder à l&rsquo;entité depuis le composant. Dans notre extrait de
code précédent pour le <code>BasicMonster</code>, nous avons pu accéder au nom (&ldquo;name&rdquo;) de
l&rsquo;entité en référençant le propriétaire (&ldquo;owner&rdquo;). Nous devons simplement nous
assurer de régler le propriétaire à l&rsquo;initialisation de l&rsquo;entité.</p>

<p>Maintenant nous allons devoir ajouter notre nouveau composant à chaque entité
que nous avons crée jusque là. Commençons par la plus facile : le joueur. Le
joueur n&rsquo;a pas besoin d&rsquo;une AI (parce que nous contrôlons directement l&rsquo;objet
joueur) mais il lui faut un composant <code>Fighter</code>.</p>

<p>En premier, importer le composant <code>Fighter</code> dans <code>engine.py</code> :</p>

<div>
  <button class="btn btn-primary data-toggle-tab active" data-toggle-tab="diff">
    Diff
  </button>
  <button class="btn btn-secondary data-toggle-tab" data-toggle-tab="original">
    Original
  </button>

   <div class="data-pane active" data-pane="diff">
   <div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-diff" data-lang="diff">import tcod as libtcod

<span style="color:#a6e22e">+from components.fighter import Fighter
</span><span style="color:#a6e22e"></span>from entity import Entity, get_blocking_entities_at_location
</code></pre></div>

</div>
<div class="data-pane" data-pane="original">
  
<pre>import tcod as libtcod

<span class="new-text">from components.fighter import Fighter</span>
from entity import Entity, get_blocking_entities_at_location</pre>

</div>

</div>


<p>Ensuite, créons le composant et ajoutons le à l&rsquo;entité du joueur.</p>

<div>
  <button class="btn btn-primary data-toggle-tab active" data-toggle-tab="diff">
    Diff
  </button>
  <button class="btn btn-secondary data-toggle-tab" data-toggle-tab="original">
    Original
  </button>

   <div class="data-pane active" data-pane="diff">
   <div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-diff" data-lang="diff"><span style="color:#a6e22e">+   fighter_component = Fighter(hp=30, defense=2, power=5)
</span><span style="color:#a6e22e"></span><span style="color:#f92672">-   player = Entity(0, 0, &#39;@&#39;, libtcod.white, &#39;Player&#39;, blocks=True)
</span><span style="color:#f92672"></span><span style="color:#a6e22e">+   player = Entity(0, 0, &#39;@&#39;, libtcod.white, &#39;Player&#39;, blocks=True, fighter=fighter_component)
</span><span style="color:#a6e22e"></span>    entities = [player]
    ...
</code></pre></div>

</div>
<div class="data-pane" data-pane="original">
  
        <pre>
    <span class="new-text">fighter_component = Fighter(hp=30, defense=2, power=5)</span>
    <span class="crossed-out-text">player = Entity(0, 0, '@', libtcod.white, 'Player', blocks=True)</span>
    <span class="new-text">player = Entity(0, 0, '@', libtcod.white, 'Player', blocks=True, fighter=fighter_component)</span>
    entities = [player]
    ...</pre>

</div>

</div>


<p>Et maintenant pour les monstres. Nous aurons besoin des composants Fighter
et BasicMonster pour ceux là.</p>

<div>
  <button class="btn btn-primary data-toggle-tab active" data-toggle-tab="diff">
    Diff
  </button>
  <button class="btn btn-secondary data-toggle-tab" data-toggle-tab="original">
    Original
  </button>

   <div class="data-pane active" data-pane="diff">
   <div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-diff" data-lang="diff">                if randint(0, 100) &lt; 80:
<span style="color:#a6e22e">+                   fighter_component = Fighter(hp=10, defense=0, power=3)
</span><span style="color:#a6e22e">+                   ai_component = BasicMonster()
</span><span style="color:#a6e22e"></span>
<span style="color:#f92672">-                   monster = Entity(x, y, &#39;o&#39;, libtcod.desaturated_green, &#39;Orc&#39;, blocks=True)
</span><span style="color:#f92672"></span><span style="color:#a6e22e">+                   monster = Entity(x, y, &#39;o&#39;, libtcod.desaturated_green, &#39;Orc&#39;, blocks=True,
</span><span style="color:#a6e22e">+                                    fighter=fighter_component, ai=ai_component)
</span><span style="color:#a6e22e"></span>                else:
<span style="color:#a6e22e">+                   fighter_component = Fighter(hp=16, defense=1, power=4)
</span><span style="color:#a6e22e">+                   ai_component = BasicMonster()
</span><span style="color:#a6e22e"></span>
<span style="color:#f92672">-                   monster = Entity(x, y, &#39;T&#39;, libtcod.darker_green, &#39;Troll&#39;, blocks=True)
</span><span style="color:#f92672"></span><span style="color:#a6e22e">+                   monster = Entity(x, y, &#39;T&#39;, libtcod.darker_green, &#39;Troll&#39;, blocks=True, fighter=fighter_component,
</span><span style="color:#a6e22e">+                                    ai=ai_component)
</span></code></pre></div>

</div>
<div class="data-pane" data-pane="original">
  
<pre>
                if randint(0, 100) < 80:
                    <span class="new-text">fighter_component = Fighter(hp=10, defense=0, power=3)
                    ai_component = BasicMonster()</span>

                    <span class="crossed-out-text">monster = Entity(x, y, 'o', libtcod.desaturated_green, 'Orc', blocks=True)</span>
                    <span class="new-text">monster = Entity(x, y, 'o', libtcod.desaturated_green, 'Orc', blocks=True,
                                     fighter=fighter_component, ai=ai_component)</span>
                else:
                    <span class="new-text">fighter_component = Fighter(hp=16, defense=1, power=4)
                    ai_component = BasicMonster()</span>

                    <span class="crossed-out-text">monster = Entity(x, y, 'T', libtcod.darker_green, 'Troll', blocks=True)</span>
                    <span class="new-text">monster = Entity(x, y, 'T', libtcod.darker_green, 'Troll', blocks=True, fighter=fighter_component,
                                     ai=ai_component)</span></pre>

</div>

</div>


<p>Souvenez-vous d&rsquo;importer les classes nécessaires en haut.</p>

<div>
  <button class="btn btn-primary data-toggle-tab active" data-toggle-tab="diff">
    Diff
  </button>
  <button class="btn btn-secondary data-toggle-tab" data-toggle-tab="original">
    Original
  </button>

   <div class="data-pane active" data-pane="diff">
   <div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-diff" data-lang="diff">import tcod as libtcod
from random import randint

<span style="color:#a6e22e">+from components.ai import BasicMonster
</span><span style="color:#a6e22e">+from components.fighter import Fighter
</span><span style="color:#a6e22e"></span>
from entity import Entity

from map_objects.rectangle import Rect
from map_objects.tile import Tile
</code></pre></div>

</div>
<div class="data-pane" data-pane="original">
  
<pre>import tcod as libtcod
from random import randint

<span class="new-text">from components.ai import BasicMonster
from components.fighter import Fighter</span>

from entity import Entity

from map_objects.rectangle import Rect
from map_objects.tile import Tile</pre>

</div>

</div>


<p>Maintenant nous pouvons modifier la boucle qui parcourt les tours des monstres
pour utiliser la fonction <code>take_turn</code>.</p>

<div>
  <button class="btn btn-primary data-toggle-tab active" data-toggle-tab="diff">
    Diff
  </button>
  <button class="btn btn-secondary data-toggle-tab" data-toggle-tab="original">
    Original
  </button>

   <div class="data-pane active" data-pane="diff">
   <div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-diff" data-lang="diff">        ...
        if game_state == GameStates.ENEMY_TURN:
            for entity in entities:
<span style="color:#f92672">-               if entity != player:
</span><span style="color:#f92672"></span><span style="color:#a6e22e">+               if entity.ai:
</span><span style="color:#a6e22e"></span><span style="color:#f92672">-                   print(&#39;The &#39; + entity.name + &#39; ponders the meaning of its existence.&#39;)
</span><span style="color:#f92672"></span><span style="color:#a6e22e">+                   entity.ai.take_turn()
</span><span style="color:#a6e22e"></span>
            game_state = GameStates.PLAYERS_TURN
            ...
</code></pre></div>

</div>
<div class="data-pane" data-pane="original">
  
<pre>        ...
        if game_state == GameStates.ENEMY_TURN:
            for entity in entities:
                <span class="crossed-out-text">if entity != player:</span>
                <span class="new-text">if entity.ai:</span>
                    <span class="crossed-out-text">print('The ' + entity.name + ' ponders the meaning of its existence.')</span>
                    <span class="new-text">entity.ai.take_turn()</span>

            game_state = GameStates.PLAYERS_TURN
            ...</pre>

</div>

</div>


<p>Nous n&rsquo;avons pas changé grand chose (on affiche toujours quelque chose
plutôt de donner vraiment un tour aux monstres) mais on avance. Remarquez que
plutôt que de vérifier si l&rsquo;entité n&rsquo;est pas le joueur, nous vérifions si elle
a un composant AI. Le joueur n&rsquo;en a pas donc la boucle le passe. Ce sera aussi
le cas des objets que nous implémenterons plus tard, ils n&rsquo;auront pas de &ldquo;tour&rdquo;.</p>

<p>Maintenant, implémentons l&rsquo;AI. Notre AI sera très simple (et même stupide). Si
l&rsquo;ennemi peut &ldquo;voir&rdquo; le joueur, elle va déplacer se déplacer vers le joueur et
si elle est proche du joueur elle va l&rsquo;attaquer. Nous n&rsquo;implémenterons pas le
FOV de l&rsquo;ennemi dans ce tutoriel. À la place, nous supposons simplement que si
vous pouvez voir l&rsquo;ennemi, alors il peut aussi vous voir.</p>

<p>Mettons une simple fonction de mouvement en place. Ajouter le code suivant
dans la classe <code>Entity</code>.</p>

<div>
  <button class="btn btn-primary data-toggle-tab active" data-toggle-tab="diff">
    Diff
  </button>
  <button class="btn btn-secondary data-toggle-tab" data-toggle-tab="original">
    Original
  </button>

   <div class="data-pane active" data-pane="diff">
   <div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-diff" data-lang="diff">    def move(self, dx, dy):
        ...

<span style="color:#a6e22e">+   def move_towards(self, target_x, target_y, game_map, entities):
</span><span style="color:#a6e22e">+       dx = target_x - self.x
</span><span style="color:#a6e22e">+       dy = target_y - self.y
</span><span style="color:#a6e22e">+       distance = math.sqrt(dx ** 2 + dy ** 2)
</span><span style="color:#a6e22e">+
</span><span style="color:#a6e22e">+       dx = int(round(dx / distance))
</span><span style="color:#a6e22e">+       dy = int(round(dy / distance))
</span><span style="color:#a6e22e">+
</span><span style="color:#a6e22e">+       if not (game_map.is_blocked(self.x + dx, self.y + dy) or
</span><span style="color:#a6e22e">+                   get_blocking_entities_at_location(entities, self.x + dx, self.y + dy)):
</span><span style="color:#a6e22e">+           self.move(dx, dy)
</span></code></pre></div>

</div>
<div class="data-pane" data-pane="original">
  
<pre>    def move(self, dx, dy):
        ...

    <span class="new-text">def move_towards(self, target_x, target_y, game_map, entities):
        dx = target_x - self.x
        dy = target_y - self.y
        distance = math.sqrt(dx ** 2 + dy ** 2)

        dx = int(round(dx / distance))
        dy = int(round(dy / distance))

        if not (game_map.is_blocked(self.x + dx, self.y + dy) or
                    get_blocking_entities_at_location(entities, self.x + dx, self.y + dy)):
            self.move(dx, dy)</span></pre>

</div>

</div>


<p>Nous avons aussi besoin d&rsquo;une fonction pour obtenir la distance entre l&rsquo;entité
et sa cible.</p>

<div>
  <button class="btn btn-primary data-toggle-tab active" data-toggle-tab="diff">
    Diff
  </button>
  <button class="btn btn-secondary data-toggle-tab" data-toggle-tab="original">
    Original
  </button>

   <div class="data-pane active" data-pane="diff">
   <div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-diff" data-lang="diff">    def move_towards(self, target_x, target_y, game_map, entities):
        ...

<span style="color:#a6e22e">+   def distance_to(self, other):
</span><span style="color:#a6e22e">+       dx = other.x - self.x
</span><span style="color:#a6e22e">+       dy = other.y - self.y
</span><span style="color:#a6e22e">+       return math.sqrt(dx ** 2 + dy ** 2)
</span></code></pre></div>

</div>
<div class="data-pane" data-pane="original">
  
<pre>    def move_towards(self, target_x, target_y, game_map, entities):
        ...

    <span class="new-text">def distance_to(self, other):
        dx = other.x - self.x
        dy = other.y - self.y
        return math.sqrt(dx ** 2 + dy ** 2)</span></pre>

</div>

</div>


<p>Ces deux fonctions utilisent le module <code>math</code> donc nous devons l&rsquo;importer.</p>

<div>
  <button class="btn btn-primary data-toggle-tab active" data-toggle-tab="diff">
    Diff
  </button>
  <button class="btn btn-secondary data-toggle-tab" data-toggle-tab="original">
    Original
  </button>

   <div class="data-pane active" data-pane="diff">
   <div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-diff" data-lang="diff"><span style="color:#a6e22e">+import math
</span><span style="color:#a6e22e"></span>

class Entity:
    ...
</code></pre></div>

</div>
<div class="data-pane" data-pane="original">
  
<pre><span class="new-text">import math</span>


class Entity:
    ...</pre>

</div>

</div>


<p>Remplaçons notre fonction <code>take_turn</code> d&rsquo;exemple avec celle qui va réellement
déplacer l&rsquo;entité.</p>

<div>
  <button class="btn btn-primary data-toggle-tab active" data-toggle-tab="diff">
    Diff
  </button>
  <button class="btn btn-secondary data-toggle-tab" data-toggle-tab="original">
    Original
  </button>

   <div class="data-pane active" data-pane="diff">
   <div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-diff" data-lang="diff">import tcod as libtcod


class BasicMonster:
<span style="color:#f92672">-   def take_turn(self):
</span><span style="color:#f92672"></span><span style="color:#a6e22e">+   def take_turn(self, target, fov_map, game_map, entities):
</span><span style="color:#a6e22e"></span><span style="color:#f92672">-       print(&#39;The &#39; + self.owner.name + &#39; wonders when it will get to move.&#39;)
</span><span style="color:#f92672"></span><span style="color:#a6e22e">+       monster = self.owner
</span><span style="color:#a6e22e">+       if libtcod.map_is_in_fov(fov_map, monster.x, monster.y):
</span><span style="color:#a6e22e">+
</span><span style="color:#a6e22e">+           if monster.distance_to(target) &gt;= 2:
</span><span style="color:#a6e22e">+               monster.move_towards(target.x, target.y, game_map, entities)
</span><span style="color:#a6e22e">+
</span><span style="color:#a6e22e">+           elif target.fighter.hp &gt; 0:
</span><span style="color:#a6e22e">+               print(&#39;The {0} insults you! Your ego is damaged!&#39;.format(monster.name))
</span></code></pre></div>

</div>
<div class="data-pane" data-pane="original">
  
<pre><span class="new-text">import tcod as libtcod</span>


class BasicMonster:
    <span class="crossed-out-text">def take_turn(self):</span>
    <span class="new-text">def take_turn(self, target, fov_map, game_map, entities):</span>
        <span class="crossed-out-text">print('The ' + self.owner.name + ' wonders when it will get to move.')</span>
        <span class="new-text">monster = self.owner
        if libtcod.map_is_in_fov(fov_map, monster.x, monster.y):

            if monster.distance_to(target) >= 2:
                monster.move_towards(target.x, target.y, game_map, entities)

            elif target.fighter.hp > 0:
                print('The {0} insults you! Your ego is damaged!'.format(monster.name))</span></pre>

</div>

</div>


<p>Nous devons aussi mettre à jour l&rsquo;appel de <code>take_turn</code> dans <code>engine.py</code></p>

<div>
  <button class="btn btn-primary data-toggle-tab active" data-toggle-tab="diff">
    Diff
  </button>
  <button class="btn btn-secondary data-toggle-tab" data-toggle-tab="original">
    Original
  </button>

   <div class="data-pane active" data-pane="diff">
   <div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-diff" data-lang="diff"><span style="color:#f92672">-                   entity.ai.take_turn()
</span><span style="color:#f92672"></span><span style="color:#a6e22e">+                   entity.ai.take_turn(player, fov_map, game_map, entities)
</span></code></pre></div>

</div>
<div class="data-pane" data-pane="original">
  
<pre>                    <span class="crossed-out-text">entity.ai.take_turn()</span>
                    <span class="new-text">entity.ai.take_turn(player, fov_map, game_map, entities)</span></pre>

</div>

</div>


<p>Maintenant notre ennemi va poursuivre le joueur et, s&rsquo;il le rattrape lui hurler
des insultes !</p>

<p>Si vous lancez le jeu projet, vous remarquerez quelque chose d&rsquo;étrange à propos
de nos monstres : ils peuvent vous insulter depuis une case en diagonale mais
le joueur et les ennemis ne peuvent se déplacer que dans des directions
cardinales (nord, sud, est, ouest). Si les ennemis nous attaquaient vraiment
ils auraient un avantage injuste. Cela pourrait être un gameplay intéressant
mais nous le fixerons en permettant le déplacement et l&rsquo;attaque dans les 8
directions pour toutes les entités.</p>

<p>Pour le joueur c&rsquo;est assez simple, nous devons mettre à jour <code>handle_keys</code> pour
permettre un mouvement diagonal. Modifiez la partie mouvement de cette fonction
ainsi :</p>

<div>
  <button class="btn btn-primary data-toggle-tab active" data-toggle-tab="diff">
    Diff
  </button>
  <button class="btn btn-secondary data-toggle-tab" data-toggle-tab="original">
    Original
  </button>

   <div class="data-pane active" data-pane="diff">
   <div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-diff" data-lang="diff">def handle_keys(key):
<span style="color:#a6e22e">+   key_char = chr(key.c)
</span><span style="color:#a6e22e"></span>
<span style="color:#f92672">-   if key.vk == libtcod.KEY_UP:
</span><span style="color:#f92672"></span><span style="color:#a6e22e">+   if key.vk == libtcod.KEY_UP or key_char == &#39;k&#39;:
</span><span style="color:#a6e22e"></span>        return {&#39;move&#39;: (0, -1)}
<span style="color:#f92672">-  elif key.vk == libtcod.KEY_DOWN:
</span><span style="color:#f92672"></span><span style="color:#a6e22e">+   elif key.vk == libtcod.KEY_DOWN or key_char == &#39;j&#39;:
</span><span style="color:#a6e22e"></span>        return {&#39;move&#39;: (0, 1)}
<span style="color:#f92672">-   elif key.vk == libtcod.KEY_LEFT:
</span><span style="color:#f92672"></span><span style="color:#a6e22e">+   elif key.vk == libtcod.KEY_LEFT or key_char == &#39;h&#39;:
</span><span style="color:#a6e22e"></span>        return {&#39;move&#39;: (-1, 0)}
<span style="color:#f92672">-   elif key.vk == libtcod.KEY_RIGHT:
</span><span style="color:#f92672"></span><span style="color:#a6e22e">+   elif key.vk == libtcod.KEY_RIGHT or key_char == &#39;l&#39;:
</span><span style="color:#a6e22e"></span>        return {&#39;move&#39;: (1, 0)}
<span style="color:#a6e22e">+   elif key_char == &#39;y&#39;:
</span><span style="color:#a6e22e">+       return {&#39;move&#39;: (-1, -1)}
</span><span style="color:#a6e22e">+   elif key_char == &#39;u&#39;:
</span><span style="color:#a6e22e">+       return {&#39;move&#39;: (1, -1)}
</span><span style="color:#a6e22e">+   elif key_char == &#39;b&#39;:
</span><span style="color:#a6e22e">+       return {&#39;move&#39;: (-1, 1)}
</span><span style="color:#a6e22e">+   elif key_char == &#39;n&#39;:
</span><span style="color:#a6e22e">+       return {&#39;move&#39;: (1, 1)}
</span><span style="color:#a6e22e"></span>
    ...
</code></pre></div>

</div>
<div class="data-pane" data-pane="original">
  
<pre>def handle_keys(key):
    <span class="new-text">key_char = chr(key.c)</span>

    if key.vk == libtcod.KEY_UP<span class="new-text"> or key_char == 'k'</span>:
        return {'move': (0, -1)}
    elif key.vk == libtcod.KEY_DOWN<span class="new-text"> or key_char == 'j'</span>:
        return {'move': (0, 1)}
    elif key.vk == libtcod.KEY_LEFT<span class="new-text"> or key_char == 'h'</span>:
        return {'move': (-1, 0)}
    elif key.vk == libtcod.KEY_RIGHT<span class="new-text"> or key_char == 'l'</span>:
        return {'move': (1, 0)}
    <span class="new-text">elif key_char == 'y':
        return {'move': (-1, -1)}
    elif key_char == 'u':
        return {'move': (1, -1)}
    elif key_char == 'b':
        return {'move': (-1, 1)}
    elif key_char == 'n':
        return {'move': (1, 1)}</span>

    ...</pre>

</div>

</div>


<p>La première ligne récupère le caractère pressé sur le clavier. Cela sera commode
dans de futures étapes, quand nous allons écouter les commandes pour
l&rsquo;inventaire et ramasser les objets.</p>

<p>Pour les mouvements diagonaux, nous avons implémenté les &ldquo;vim keys&rdquo; du
déplacement et conservé les fleches pour les déplacements cardinaux. Les &ldquo;vim
keys&rdquo; permettent de se déplacer en diagonale sans utiliser le pavé numérique.
De nombreux roguelikes implémentent les déplacements dans 8 directions via le
pavé numérique mais je préfère jouer sur un portable qui n&rsquo;en a pas, aussi les
&ldquo;vim keys&rdquo; sont commodes.</p>

<p>Déplacer les ennemis dans huit directions sera un peu plus délicat. Pour ça,
nous allons utiliser un algorithme de recherche de chemin appelé A-star. Je vais
simplement copier le code puis les <a href="http://www.roguebasin.com/index.php?title=Complete_Roguelike_Tutorial,_using_Python%2Blibtcod,_extras#A.2A_Pathfinding">extra de Roguebasin</a>.
Je n&rsquo;entrerai pas dans le détail à ce propos mais si vous voulez comprendre son
fonctionnement, <a href="https://en.wikipedia.org/wiki/A*_search_algorithm">cliquez ici</a>.</p>

<div>
  <button class="btn btn-primary data-toggle-tab active" data-toggle-tab="diff">
    Diff
  </button>
  <button class="btn btn-secondary data-toggle-tab" data-toggle-tab="original">
    Original
  </button>

   <div class="data-pane active" data-pane="diff">
   <div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-diff" data-lang="diff">    def move_towards(self, target_x, target_y, game_map, entities):
    ...

<span style="color:#a6e22e">+   def move_astar(self, target, entities, game_map):
</span><span style="color:#a6e22e">+       # Create a FOV map that has the dimensions of the map
</span><span style="color:#a6e22e">+       fov = libtcod.map_new(game_map.width, game_map.height)
</span><span style="color:#a6e22e">+
</span><span style="color:#a6e22e">+       # Scan the current map each turn and set all the walls as unwalkable
</span><span style="color:#a6e22e">+       for y1 in range(game_map.height):
</span><span style="color:#a6e22e">+           for x1 in range(game_map.width):
</span><span style="color:#a6e22e">+               libtcod.map_set_properties(fov, x1, y1, not game_map.tiles[x1][y1].block_sight,
</span><span style="color:#a6e22e">+                                          not game_map.tiles[x1][y1].blocked)
</span><span style="color:#a6e22e">+
</span><span style="color:#a6e22e">+       # Scan all the objects to see if there are objects that must be navigated around
</span><span style="color:#a6e22e">+       # Check also that the object isn&#39;t self or the target (so that the start and the end points are free)
</span><span style="color:#a6e22e">+       # The AI class handles the situation if self is next to the target so it will not use this A* function anyway
</span><span style="color:#a6e22e">+       for entity in entities:
</span><span style="color:#a6e22e">+           if entity.blocks and entity != self and entity != target:
</span><span style="color:#a6e22e">+               # Set the tile as a wall so it must be navigated around
</span><span style="color:#a6e22e">+               libtcod.map_set_properties(fov, entity.x, entity.y, True, False)
</span><span style="color:#a6e22e">+
</span><span style="color:#a6e22e">+       # Allocate a A* path
</span><span style="color:#a6e22e">+       # The 1.41 is the normal diagonal cost of moving, it can be set as 0.0 if diagonal moves are prohibited
</span><span style="color:#a6e22e">+       my_path = libtcod.path_new_using_map(fov, 1.41)
</span><span style="color:#a6e22e">+
</span><span style="color:#a6e22e">+       # Compute the path between self&#39;s coordinates and the target&#39;s coordinates
</span><span style="color:#a6e22e">+       libtcod.path_compute(my_path, self.x, self.y, target.x, target.y)
</span><span style="color:#a6e22e">+
</span><span style="color:#a6e22e">+       # Check if the path exists, and in this case, also the path is shorter than 25 tiles
</span><span style="color:#a6e22e">+       # The path size matters if you want the monster to use alternative longer paths (for example through other rooms) if for example the player is in a corridor
</span><span style="color:#a6e22e">+       # It makes sense to keep path size relatively low to keep the monsters from running around the map if there&#39;s an alternative path really far away
</span><span style="color:#a6e22e">+       if not libtcod.path_is_empty(my_path) and libtcod.path_size(my_path) &lt; 25:
</span><span style="color:#a6e22e">+           # Find the next coordinates in the computed full path
</span><span style="color:#a6e22e">+           x, y = libtcod.path_walk(my_path, True)
</span><span style="color:#a6e22e">+           if x or y:
</span><span style="color:#a6e22e">+               # Set self&#39;s coordinates to the next path tile
</span><span style="color:#a6e22e">+               self.x = x
</span><span style="color:#a6e22e">+               self.y = y
</span><span style="color:#a6e22e">+       else:
</span><span style="color:#a6e22e">+           # Keep the old move function as a backup so that if there are no paths (for example another monster blocks a corridor)
</span><span style="color:#a6e22e">+           # it will still try to move towards the player (closer to the corridor opening)
</span><span style="color:#a6e22e">+           self.move_towards(target.x, target.y, game_map, entities)
</span><span style="color:#a6e22e">+
</span><span style="color:#a6e22e">+           # Delete the path to free memory
</span><span style="color:#a6e22e">+       libtcod.path_delete(my_path)
</span></code></pre></div>

</div>
<div class="data-pane" data-pane="original">
  
<pre>    def move_towards(self, target_x, target_y, game_map, entities):
    ...

    <span class="new-text">def move_astar(self, target, entities, game_map):
        # Create a FOV map that has the dimensions of the map
        fov = libtcod.map_new(game_map.width, game_map.height)

        # Scan the current map each turn and set all the walls as unwalkable
        for y1 in range(game_map.height):
            for x1 in range(game_map.width):
                libtcod.map_set_properties(fov, x1, y1, not game_map.tiles[x1][y1].block_sight,
                                           not game_map.tiles[x1][y1].blocked)

        # Scan all the objects to see if there are objects that must be navigated around
        # Check also that the object isn't self or the target (so that the start and the end points are free)
        # The AI class handles the situation if self is next to the target so it will not use this A* function anyway
        for entity in entities:
            if entity.blocks and entity != self and entity != target:
                # Set the tile as a wall so it must be navigated around
                libtcod.map_set_properties(fov, entity.x, entity.y, True, False)

        # Allocate a A* path
        # The 1.41 is the normal diagonal cost of moving, it can be set as 0.0 if diagonal moves are prohibited
        my_path = libtcod.path_new_using_map(fov, 1.41)

        # Compute the path between self's coordinates and the target's coordinates
        libtcod.path_compute(my_path, self.x, self.y, target.x, target.y)

        # Check if the path exists, and in this case, also the path is shorter than 25 tiles
        # The path size matters if you want the monster to use alternative longer paths (for example through other rooms) if for example the player is in a corridor
        # It makes sense to keep path size relatively low to keep the monsters from running around the map if there's an alternative path really far away
        if not libtcod.path_is_empty(my_path) and libtcod.path_size(my_path) < 25:
            # Find the next coordinates in the computed full path
            x, y = libtcod.path_walk(my_path, True)
            if x or y:
                # Set self's coordinates to the next path tile
                self.x = x
                self.y = y
        else:
            # Keep the old move function as a backup so that if there are no paths (for example another monster blocks a corridor)
            # it will still try to move towards the player (closer to the corridor opening)
            self.move_towards(target.x, target.y, game_map, entities)

            # Delete the path to free memory
        libtcod.path_delete(my_path)</span></pre>

</div>

</div>


<p>Pour faire fonctionner ça, nous devons importer <code>libtcod</code> dans <code>entity.py</code> :</p>

<div>
  <button class="btn btn-primary data-toggle-tab active" data-toggle-tab="diff">
    Diff
  </button>
  <button class="btn btn-secondary data-toggle-tab" data-toggle-tab="original">
    Original
  </button>

   <div class="data-pane active" data-pane="diff">
   <div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-diff" data-lang="diff"><span style="color:#a6e22e">+import tcod as libtcod
</span><span style="color:#a6e22e"></span>
import math
...
</code></pre></div>

</div>
<div class="data-pane" data-pane="original">
  
<pre><span class="new-text">import tcod as libtcod</span>

import math
...</pre>

</div>

</div>


<p>Remarquez que si l&rsquo;algorithme est incapable de trouver un chemin il va revenir
à notre fonction de mouvement précédente. Nous en avons donc toujours besoin.</p>

<p>Modifiez la fonction <code>take_turn</code> de <code>BasicMonster</code> pour utiliser cette nouvelle
fonction.</p>

<div>
  <button class="btn btn-primary data-toggle-tab active" data-toggle-tab="diff">
    Diff
  </button>
  <button class="btn btn-secondary data-toggle-tab" data-toggle-tab="original">
    Original
  </button>

   <div class="data-pane active" data-pane="diff">
   <div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-diff" data-lang="diff">            ...
            if monster.distance_to(target) &gt;= 2:
<span style="color:#a6e22e">+               monster.move_astar(target, entities, game_map)
</span><span style="color:#a6e22e"></span><span style="color:#f92672">-               monster.move_towards(target.x, target.y, game_map, entities)
</span><span style="color:#f92672"></span>            ...
</code></pre></div>

</div>
<div class="data-pane" data-pane="original">
  
<pre>            ...
            if monster.distance_to(target) >= 2:
                <span class="new-text">monster.move_astar(target, entities, game_map)</span>
                <span style="color: red; text-decoration: line-through;">monster.move_towards(target.x, target.y, game_map, entities)</span>
            ...</pre>

</div>

</div>


<p>Maintenant le joueur et les ennemis peuvent se déplacer en diagonale. Ceci étant
fait, il est temps d&rsquo;implémenter un système de combat. Commençons par ajouter
une méthode au <code>Fighter</code> qui permette à l&rsquo;entité de prendre des dégats.</p>

<div>
  <button class="btn btn-primary data-toggle-tab active" data-toggle-tab="diff">
    Diff
  </button>
  <button class="btn btn-secondary data-toggle-tab" data-toggle-tab="original">
    Original
  </button>

   <div class="data-pane active" data-pane="diff">
   <div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-diff" data-lang="diff">class Fighter:
    def __init__(self, hp, defense, power):
        ...

<span style="color:#a6e22e">+   def take_damage(self, amount):
</span><span style="color:#a6e22e">+       self.hp -= amount
</span></code></pre></div>

</div>
<div class="data-pane" data-pane="original">
  
<pre>class Fighter:
    def __init__(self, hp, defense, power):
        ...

    <span class="new-text">def take_damage(self, amount):
        self.hp -= amount</span></pre>

</div>

</div>


<p>Plutôt simple. Maintenant la fonction d&rsquo;attaque, toujours dans <code>Fighter</code> :</p>

<div>
  <button class="btn btn-primary data-toggle-tab active" data-toggle-tab="diff">
    Diff
  </button>
  <button class="btn btn-secondary data-toggle-tab" data-toggle-tab="original">
    Original
  </button>

   <div class="data-pane active" data-pane="diff">
   <div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-diff" data-lang="diff">    ...

<span style="color:#a6e22e">+   def attack(self, target):
</span><span style="color:#a6e22e">+       damage = self.power - target.fighter.defense
</span><span style="color:#a6e22e">+
</span><span style="color:#a6e22e">+       if damage &gt; 0:
</span><span style="color:#a6e22e">+           target.fighter.take_damage(damage)
</span><span style="color:#a6e22e">+           print(&#39;{0} attacks {1} for {2} hit points.&#39;.format(self.owner.name.capitalize(), target.name, str(damage)))
</span><span style="color:#a6e22e">+       else:
</span><span style="color:#a6e22e">+           print(&#39;{0} attacks {1} but does no damage.&#39;.format(self.owner.name.capitalize(), target.name))
</span></code></pre></div>

</div>
<div class="data-pane" data-pane="original">
  
<pre>    ...

    <span class="new-text">def attack(self, target):
        damage = self.power - target.fighter.defense

        if damage > 0:
            target.fighter.take_damage(damage)
            print('{0} attacks {1} for {2} hit points.'.format(self.owner.name.capitalize(), target.name, str(damage)))
        else:
            print('{0} attacks {1} but does no damage.'.format(self.owner.name.capitalize(), target.name))</span></pre>

</div>

</div>


<p>Rien de très complexe dans ce système. On prend la puissance d&rsquo;attaque (power)
de l&rsquo;agresseur et on soustraie la défense du défenseur pour obtenir les dégâts
effectués. Si le dégât est supérieur à zéro, alors la cible reçoit des dégâts.</p>

<p>Nous pouvons enfin remplacer notre exemple antérieur ! Modifier l&rsquo;exemple
du joueur dans <code>engine.py</code> :</p>

<div>
  <button class="btn btn-primary data-toggle-tab active" data-toggle-tab="diff">
    Diff
  </button>
  <button class="btn btn-secondary data-toggle-tab" data-toggle-tab="original">
    Original
  </button>

   <div class="data-pane active" data-pane="diff">
   <div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-diff" data-lang="diff">                if target:
<span style="color:#f92672">-                   print(&#39;You kick the &#39; + target.name + &#39; in the shins, much to its annoyance!&#39;)
</span><span style="color:#f92672"></span><span style="color:#a6e22e">+                   player.fighter.attack(target)
</span></code></pre></div>

</div>
<div class="data-pane" data-pane="original">
  
<pre>                if target:
                    <span class="crossed-out-text">print('You kick the ' + target.name + ' in the shins, much to its annoyance!')</span>
                    <span class="new-text">player.fighter.attack(target)</span></pre>

</div>

</div>


<p>&hellip; et pour l&rsquo;exemple de l&rsquo;ennemi dans <code>BasicMonster</code></p>

<div>
  <button class="btn btn-primary data-toggle-tab active" data-toggle-tab="diff">
    Diff
  </button>
  <button class="btn btn-secondary data-toggle-tab" data-toggle-tab="original">
    Original
  </button>

   <div class="data-pane active" data-pane="diff">
   <div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-diff" data-lang="diff">            ...
            elif target.fighter.hp &gt; 0:
<span style="color:#f92672">-               print(&#39;The {0} insults you! Your ego is damaged!&#39;.format(monster.name))
</span><span style="color:#f92672"></span><span style="color:#a6e22e">+               monster.fighter.attack(target)
</span></code></pre></div>

</div>
<div class="data-pane" data-pane="original">
  
<pre>            ...
            elif target.fighter.hp > 0:
                <span class="crossed-out-text">print('The {0} insults you! Your ego is damaged!'.format(monster.name))</span>
                <span class="new-text">monster.fighter.attack(target)</span></pre>

</div>

</div>


<p>Maintenant on peut attaquer les ennemis et ils peuvent rendre les coups !</p>

<p>Aussi amusant que cela soit, nous devons marquer une pause et réfléchir au
design. Pour l&rsquo;instant, nous affichons nos messages dans la console et, dans
l&rsquo;étape suivante, nous utiliserons un journal de message plus classique. Aussi
nous devrons modifier l&rsquo;état du jeu quand le joueur est tué en combat. Les
fonctions <code>attack</code> et <code>take_damage</code> doivent-elles recevoir le journal de message
ou l&rsquo;état du jeu comme paramètre ? Doivent-elles manipuler ces objets ?</p>

<p>Il existe de multiples manières de traiter cela, pour ce tutoriel, nous allons
implémenter une liste <code>results</code> pour les fonctions de ce genre qui sera retourné
à <code>engine.py</code> et sera traité dans ce fichier. Nous faisons déjà quelque chose
de similaire dans <code>handle_keys</code>, cette fonction renvoie le résultat d&rsquo;une touche
pressée, elle ne <em>déplace pas</em> le joueur.</p>

<p>Modifiez les fonctions <code>take_damage</code> et <code>attack</code> pour renvoyer un tableau de
résultats plutôt que d&rsquo;afficher quoi que ce soit.</p>

<div>
  <button class="btn btn-primary data-toggle-tab active" data-toggle-tab="diff">
    Diff
  </button>
  <button class="btn btn-secondary data-toggle-tab" data-toggle-tab="original">
    Original
  </button>

   <div class="data-pane active" data-pane="diff">
   <div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-diff" data-lang="diff">    def take_damage(self, amount):
<span style="color:#a6e22e">+       results = []
</span><span style="color:#a6e22e"></span>
        self.hp -= amount

<span style="color:#a6e22e">+       if self.hp &lt;= 0:
</span><span style="color:#a6e22e">+           results.append({&#39;dead&#39;: self.owner})
</span><span style="color:#a6e22e">+
</span><span style="color:#a6e22e">+       return results
</span><span style="color:#a6e22e"></span>
    def attack(self, target):
<span style="color:#a6e22e">+       results = []
</span><span style="color:#a6e22e"></span>
        damage = self.power - target.fighter.defense

        if damage &gt; 0:
<span style="color:#f92672">-           target.fighter.take_damage(damage)
</span><span style="color:#f92672">-           print(&#39;{0} attacks {1} for {2} hit points.&#39;.format(self.owner.name.capitalize(), target.name, str(damage)))
</span><span style="color:#f92672"></span><span style="color:#a6e22e">+           results.append({&#39;message&#39;: &#39;{0} attacks {1} for {2} hit points.&#39;.format(
</span><span style="color:#a6e22e">+               self.owner.name.capitalize(), target.name, str(damage))})
</span><span style="color:#a6e22e">+           results.extend(target.fighter.take_damage(damage))
</span><span style="color:#a6e22e"></span>        else:
<span style="color:#f92672">-           print(&#39;{0} attacks {1} but does no damage.&#39;.format(self.owner.name.capitalize(), target.name))
</span><span style="color:#f92672"></span><span style="color:#a6e22e">+           results.append({&#39;message&#39;: &#39;{0} attacks {1} but does no damage.&#39;.format(
</span><span style="color:#a6e22e">+               self.owner.name.capitalize(), target.name)})
</span><span style="color:#a6e22e">+
</span><span style="color:#a6e22e">+       return results
</span></code></pre></div>

</div>
<div class="data-pane" data-pane="original">
  
<pre>
    def take_damage(self, amount):
        <span class="new-text">results = []</span>

        self.hp -= amount

        <span class="new-text">if self.hp <= 0:
            results.append({'dead': self.owner})

        return results</span>

    def attack(self, target):
        <span class="new-text">results = []</span>

        damage = self.power - target.fighter.defense

        if damage > 0:
            <span style="color: red; text-decoration: line-through;">target.fighter.take_damage(damage)</span>
            <span style="color: red; text-decoration: line-through;">print('{0} attacks {1} for {2} hit points.'.format(self.owner.name.capitalize(), target.name, str(damage)))</span>
            <span class="new-text">results.append({'message': '{0} attacks {1} for {2} hit points.'.format(
                self.owner.name.capitalize(), target.name, str(damage))})
            results.extend(target.fighter.take_damage(damage))</span>
        else:
            <span style="color: red; text-decoration: line-through;">print('{0} attacks {1} but does no damage.'.format(self.owner.name.capitalize(), target.name))</span>
            <span class="new-text">results.append({'message': '{0} attacks {1} but does no damage.'.format(
                self.owner.name.capitalize(), target.name)})

        return results</span></pre>

</div>

</div>


<p>Découpons cette étape quelques morceaux. Dans <code>take_damage</code>, on ajoute un
dictionnaire à <code>results</code> si l&rsquo;entité meurt après avoir pris des dégâts. la
liste résultante est renvoyée dans tous les cas (elle peut être vide).</p>

<p>Dans <code>attack</code>, nous créeons à nouveau une liste appelée <code>results</code> et nous y
ajoutons notre message qu&rsquo;un dégât ait été pris ou non. Remarquez que dans le
bloc <code>if</code> nous utilisons <code>extend</code> pour ajouter les résultat de <code>take_damage</code>
à notre liste <code>results</code>.</p>

<p>La méthode <code>extend</code> est similaire à <code>append</code> mais elle garde la liste plate.
Ainsi nous évitons d&rsquo;avoir quelque chose comme <code>[{'message': 'something'},
[{'message': 'something else'}]]</code>. Nous obtenons plutôt quelque chose comme :
[{&lsquo;message&rsquo;: &lsquo;something&rsquo;}, {&lsquo;message&rsquo;: &lsquo;something else&rsquo;}]`. Cela va simplifier
la boucle sur nos résultats.</p>

<p>Appliquons cette logique à la fonction <code>take_turn</code> de <code>BasicMonster</code>.</p>

<div>
  <button class="btn btn-primary data-toggle-tab active" data-toggle-tab="diff">
    Diff
  </button>
  <button class="btn btn-secondary data-toggle-tab" data-toggle-tab="original">
    Original
  </button>

   <div class="data-pane active" data-pane="diff">
   <div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-diff" data-lang="diff">class BasicMonster:
    def take_turn(self, target, fov_map, game_map, entities):
<span style="color:#a6e22e">+       results = []
</span><span style="color:#a6e22e"></span>
        monster = self.owner
        if libtcod.map_is_in_fov(fov_map, monster.x, monster.y):

            if monster.distance_to(target) &gt;= 2:
                monster.move_astar(target, entities, game_map)

            elif target.fighter.hp &gt; 0:
<span style="color:#f92672">-               monster.fighter.attack(target)
</span><span style="color:#f92672"></span><span style="color:#a6e22e">+               attack_results = monster.fighter.attack(target)
</span><span style="color:#a6e22e">+               results.extend(attack_results)
</span><span style="color:#a6e22e">+
</span><span style="color:#a6e22e">+       return results
</span></code></pre></div>

</div>
<div class="data-pane" data-pane="original">
  
<pre>class BasicMonster:
    def take_turn(self, target, fov_map, game_map, entities):
        <span class="new-text">results = []</span>

        monster = self.owner
        if libtcod.map_is_in_fov(fov_map, monster.x, monster.y):

            if monster.distance_to(target) >= 2:
                monster.move_astar(target, entities, game_map)

            elif target.fighter.hp > 0:
                <span class="crossed-out-text">monster.fighter.attack(target)</span>
                <span class="new-text">attack_results = monster.fighter.attack(target)
                results.extend(attack_results)

        return results</span></pre>

</div>

</div>


<p>Que <em>faisons nous</em> avec cette liste <code>results</code> ? Modifiez <code>engine.py</code> pour réagir
aux résultats d&rsquo;une attaque.</p>

<div>
  <button class="btn btn-primary data-toggle-tab active" data-toggle-tab="diff">
    Diff
  </button>
  <button class="btn btn-secondary data-toggle-tab" data-toggle-tab="original">
    Original
  </button>

   <div class="data-pane active" data-pane="diff">
   <div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-diff" data-lang="diff">        ...
        fullscreen = action.get(&#39;fullscreen&#39;)

<span style="color:#a6e22e">+       player_turn_results = []
</span><span style="color:#a6e22e"></span>
        if move and game_state == GameStates.PLAYERS_TURN:
            dx, dy = move
            destination_x = player.x + dx
            destination_y = player.y + dy

            if not game_map.is_blocked(destination_x, destination_y):
                target = get_blocking_entities_at_location(entities, destination_x, destination_y)

                if target:
<span style="color:#f92672">-                   player.fighter.attack(target)
</span><span style="color:#f92672"></span><span style="color:#a6e22e">+                   attack_results = player.fighter.attack(target)
</span><span style="color:#a6e22e">+                   player_turn_results.extend(attack_results)
</span><span style="color:#a6e22e"></span>                else:
                    player.move(dx, dy)

                    fov_recompute = True

                game_state = GameStates.ENEMY_TURN

        if exit:
            return True

        if fullscreen:
            libtcod.console_set_fullscreen(not libtcod.console_is_fullscreen())

<span style="color:#a6e22e">+       for player_turn_result in player_turn_results:
</span><span style="color:#a6e22e">+           message = player_turn_result.get(&#39;message&#39;)
</span><span style="color:#a6e22e">+           dead_entity = player_turn_result.get(&#39;dead&#39;)
</span><span style="color:#a6e22e">+
</span><span style="color:#a6e22e">+           if message:
</span><span style="color:#a6e22e">+               print(message)
</span><span style="color:#a6e22e">+
</span><span style="color:#a6e22e">+           if dead_entity:
</span><span style="color:#a6e22e">+               pass # We&#39;ll do something here momentarily
</span><span style="color:#a6e22e"></span>
        if game_state == GameStates.ENEMY_TURN:
            for entity in entities:
                if entity.ai:
<span style="color:#f92672">-                   entity.ai.take_turn(player, fov_map, game_map, entities)
</span><span style="color:#f92672"></span><span style="color:#a6e22e">+                   enemy_turn_results = entity.ai.take_turn(player, fov_map, game_map, entities)
</span><span style="color:#a6e22e">+
</span><span style="color:#a6e22e">+                   for enemy_turn_result in enemy_turn_results:
</span><span style="color:#a6e22e">+                       message = enemy_turn_result.get(&#39;message&#39;)
</span><span style="color:#a6e22e">+                       dead_entity = enemy_turn_result.get(&#39;dead&#39;)
</span><span style="color:#a6e22e">+
</span><span style="color:#a6e22e">+                       if message:
</span><span style="color:#a6e22e">+                           print(message)
</span><span style="color:#a6e22e">+
</span><span style="color:#a6e22e">+                       if dead_entity:
</span><span style="color:#a6e22e">+                           pass
</span><span style="color:#a6e22e">+
</span><span style="color:#a6e22e">+           else:
</span><span style="color:#a6e22e"></span>                game_state = GameStates.PLAYERS_TURN
</code></pre></div>

</div>
<div class="data-pane" data-pane="original">
  
<pre>        ...
        fullscreen = action.get('fullscreen')

        <span class="new-text">player_turn_results = []</span>

        if move and game_state == GameStates.PLAYERS_TURN:
            dx, dy = move
            destination_x = player.x + dx
            destination_y = player.y + dy

            if not game_map.is_blocked(destination_x, destination_y):
                target = get_blocking_entities_at_location(entities, destination_x, destination_y)

                if target:
                    <span style="color: red; text-decoration: line-through;">player.fighter.attack(target)</span>
                    <span class="new-text">attack_results = player.fighter.attack(target)
                    player_turn_results.extend(attack_results)</span>
                else:
                    player.move(dx, dy)

                    fov_recompute = True

                game_state = GameStates.ENEMY_TURN

        if exit:
            return True

        if fullscreen:
            libtcod.console_set_fullscreen(not libtcod.console_is_fullscreen())

        <span class="new-text">for player_turn_result in player_turn_results:
            message = player_turn_result.get('message')
            dead_entity = player_turn_result.get('dead')

            if message:
                print(message)

            if dead_entity:
                pass # We'll do something here momentarily</span>

        if game_state == GameStates.ENEMY_TURN:
            for entity in entities:
                if entity.ai:
                    <span class="crossed-out-text">entity.ai.take_turn(player, fov_map, game_map, entities)</span>
                    <span class="new-text">enemy_turn_results = entity.ai.take_turn(player, fov_map, game_map, entities)

                    for enemy_turn_result in enemy_turn_results:
                        message = enemy_turn_result.get('message')
                        dead_entity = enemy_turn_result.get('dead')

                        if message:
                            print(message)

                        if dead_entity:
                            pass

            else:</span>
                <span style="color: blue">game_state = GameStates.PLAYERS_TURN</span></pre>

</div>

</div>


<p><em>* Remarque : il y a encore une expression for-else. Il n&rsquo;y a aucun <code>break</code>
pour l&rsquo;instant donc le bloc <code>else</code> sera toujours exécuté. Mais nous l&rsquo;ajouterons
dans un instant.</em></p>

<p>Il n&rsquo;y a pas eu beaucoup  de changement mais nous avons mis en place ce qu&rsquo;il
faut pour la mort du joueur ou d&rsquo;une autre entité. Implémentons ça maintenant.
Créons un nouveau fichier appelé <code>death_functions.py</code> et ajoutons y deux
fonctions :</p>

<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-py3" data-lang="py3"><span style="color:#f92672">import</span> tcod <span style="color:#66d9ef">as</span> libtcod

<span style="color:#f92672">from</span> game_states <span style="color:#66d9ef">import</span> GameStates


<span style="color:#66d9ef">def</span> <span style="color:#a6e22e">kill_player</span>(player):
    player<span style="color:#f92672">.</span>char <span style="color:#f92672">=</span> <span style="color:#e6db74">&#39;%&#39;</span>
    player<span style="color:#f92672">.</span>color <span style="color:#f92672">=</span> libtcod<span style="color:#f92672">.</span>dark_red

    <span style="color:#66d9ef">return</span> <span style="color:#e6db74">&#39;You died!&#39;</span>, GameStates<span style="color:#f92672">.</span>PLAYER_DEAD


<span style="color:#66d9ef">def</span> <span style="color:#a6e22e">kill_monster</span>(monster):
    death_message <span style="color:#f92672">=</span> <span style="color:#e6db74">&#39;</span><span style="color:#e6db74">{0}</span><span style="color:#e6db74"> is dead!&#39;</span><span style="color:#f92672">.</span>format(monster<span style="color:#f92672">.</span>name<span style="color:#f92672">.</span>capitalize())

    monster<span style="color:#f92672">.</span>char <span style="color:#f92672">=</span> <span style="color:#e6db74">&#39;%&#39;</span>
    monster<span style="color:#f92672">.</span>color <span style="color:#f92672">=</span> libtcod<span style="color:#f92672">.</span>dark_red
    monster<span style="color:#f92672">.</span>blocks <span style="color:#f92672">=</span> <span style="color:#66d9ef">False</span>
    monster<span style="color:#f92672">.</span>fighter <span style="color:#f92672">=</span> <span style="color:#66d9ef">None</span>
    monster<span style="color:#f92672">.</span>ai <span style="color:#f92672">=</span> <span style="color:#66d9ef">None</span>
    monster<span style="color:#f92672">.</span>name <span style="color:#f92672">=</span> <span style="color:#e6db74">&#39;remains of &#39;</span> <span style="color:#f92672">+</span> monster<span style="color:#f92672">.</span>name

    <span style="color:#66d9ef">return</span> death_message</code></pre></div>

<p>Ces deux fonctions vont s&rsquo;occuper de la mort du joueur et des monstres.
Elles sont différentes parce que la mort d&rsquo;un monstre n&rsquo;est pas quelque chose
de dramatique (nous en tuerons quelques uns&hellip;) mais la mort du joueur est
<em>très</em> importante (c&rsquo;est un roguelike après tout !).</p>

<p>Modifiez <code>engine.py</code> pour utiliser ces deux fonctions. Remplacez la section
<code>pass</code> comme ceci :</p>

<div>
  <button class="btn btn-primary data-toggle-tab active" data-toggle-tab="diff">
    Diff
  </button>
  <button class="btn btn-secondary data-toggle-tab" data-toggle-tab="original">
    Original
  </button>

   <div class="data-pane active" data-pane="diff">
   <div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-diff" data-lang="diff">            ...
            if dead_entity:
<span style="color:#f92672">-               pass
</span><span style="color:#f92672"></span><span style="color:#a6e22e">+               if dead_entity == player:
</span><span style="color:#a6e22e">+                   message, game_state = kill_player(dead_entity)
</span><span style="color:#a6e22e">+               else:
</span><span style="color:#a6e22e">+                   message = kill_monster(dead_entity)
</span><span style="color:#a6e22e">+
</span><span style="color:#a6e22e">+               print(message)
</span><span style="color:#a6e22e"></span>
        if game_state == GameStates.ENEMY_TURN:
            for entity in entities:
                if entity.ai:
                    enemy_turn_results = entity.ai.take_turn(player, fov_map, game_map, entities)

                    for enemy_turn_result in enemy_turn_results:
                        message = enemy_turn_result.get(&#39;message&#39;)
                        dead_entity = enemy_turn_result.get(&#39;dead&#39;)

                        if message:
                            print(message)

                        if dead_entity:
<span style="color:#f92672">-                           pass
</span><span style="color:#f92672"></span><span style="color:#a6e22e">+                           if dead_entity == player:
</span><span style="color:#a6e22e">+                               message, game_state = kill_player(dead_entity)
</span><span style="color:#a6e22e">+                           else:
</span><span style="color:#a6e22e">+                               message = kill_monster(dead_entity)
</span><span style="color:#a6e22e">+
</span><span style="color:#a6e22e">+                           print(message)
</span><span style="color:#a6e22e">+
</span><span style="color:#a6e22e">+                           if game_state == GameStates.PLAYER_DEAD:
</span><span style="color:#a6e22e">+                               break
</span><span style="color:#a6e22e">+
</span><span style="color:#a6e22e">+                   if game_state == GameStates.PLAYER_DEAD:
</span><span style="color:#a6e22e">+                       break
</span><span style="color:#a6e22e"></span>            else:
                game_state = GameStates.PLAYERS_TURN
</code></pre></div>

</div>
<div class="data-pane" data-pane="original">
  
<pre>            ...
            if dead_entity:
                <span style="color: red; text-decoration: line-through;">pass</span>
                <span class="new-text">if dead_entity == player:
                    message, game_state = kill_player(dead_entity)
                else:
                    message = kill_monster(dead_entity)

                print(message)</span>

        if game_state == GameStates.ENEMY_TURN:
            for entity in entities:
                if entity.ai:
                    enemy_turn_results = entity.ai.take_turn(player, fov_map, game_map, entities)

                    for enemy_turn_result in enemy_turn_results:
                        message = enemy_turn_result.get('message')
                        dead_entity = enemy_turn_result.get('dead')

                        if message:
                            print(message)

                        if dead_entity:
                            <span style="color: red; text-decoration: line-through;">pass</span>
                            <span class="new-text">if dead_entity == player:
                                message, game_state = kill_player(dead_entity)
                            else:
                                message = kill_monster(dead_entity)

                            print(message)

                            if game_state == GameStates.PLAYER_DEAD:
                                break

                    if game_state == GameStates.PLAYER_DEAD:
                        break</span>
            else:
                game_state = GameStates.PLAYERS_TURN</pre>

</div>

</div>


<p><em>*Remarque : il y a l&rsquo;expression break qui va éviter le &lsquo;else&rsquo; de notre
&lsquo;for-else&rsquo;. Pourquoi ? Parce que si le joueur meurt nous ne voulons pas lui
rendre de tour une fois que les ennemis auront tous joué. D&rsquo;autre part il n&rsquo;y
aucune raison de continuer, le jeu est terminé.</em></p>

<p>Souvenez-vous d&rsquo;importer la fonction qui tue en haut de <code>engine.py</code> :</p>

<div>
  <button class="btn btn-primary data-toggle-tab active" data-toggle-tab="diff">
    Diff
  </button>
  <button class="btn btn-secondary data-toggle-tab" data-toggle-tab="original">
    Original
  </button>

   <div class="data-pane active" data-pane="diff">
   <div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-diff" data-lang="diff">...
from components.fighter import Fighter
<span style="color:#a6e22e">+from death_functions import kill_monster, kill_player
</span><span style="color:#a6e22e"></span>from entity import Entity, get_blocking_entities_at_location
...
</code></pre></div>

</div>
<div class="data-pane" data-pane="original">
  
<pre>...
from components.fighter import Fighter
<span class="new-text">from death_functions import kill_monster, kill_player</span>
from entity import Entity, get_blocking_entities_at_location
...</pre>

</div>

</div>


<p>Aussi, nous devons ajouter la valeur <code>PLAYER_DEAD</code> à <code>GameStates</code> :</p>

<div>
  <button class="btn btn-primary data-toggle-tab active" data-toggle-tab="diff">
    Diff
  </button>
  <button class="btn btn-secondary data-toggle-tab" data-toggle-tab="original">
    Original
  </button>

   <div class="data-pane active" data-pane="diff">
   <div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-diff" data-lang="diff">class GameStates(Enum):
    PLAYERS_TURN = 1
    ENEMY_TURN = 2
<span style="color:#a6e22e">+   PLAYER_DEAD = 3
</span></code></pre></div>

</div>
<div class="data-pane" data-pane="original">
  
<pre>class GameStates(Enum):
    PLAYERS_TURN = 1
    ENEMY_TURN = 2
    <span class="new-text">PLAYER_DEAD = 3</span></pre>

</div>

</div>


<p>Lancez le projet maintenant. Les entités, y compris le joueur, vont mourir en
arrivant à 0 HP ! Quand le joueur meurt, on ne peut plus le déplacer mais on
peut toujours quitter le jeu. Nous avons enfin un vrai système de combat !</p>

<p>C&rsquo;est déjà un long chapitre mais nettoyons un peu les choses. Pour l&rsquo;instant
nous ne savons pas combien le joueur a de HP avant sa mort. Plutôt que de
demander au joueur de faire les calculs mentalement nous pouvons ajouter une
petite barre de vie avec le code suivant à la fin de <code>render_all</code> juste avant
l&rsquo;expression &lsquo;blit&rsquo; (remarquez que le joueur doit être passé à <code>render_all</code>
pour l&rsquo;instant).</p>

<div>
  <button class="btn btn-primary data-toggle-tab active" data-toggle-tab="diff">
    Diff
  </button>
  <button class="btn btn-secondary data-toggle-tab" data-toggle-tab="original">
    Original
  </button>

   <div class="data-pane active" data-pane="diff">
   <div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-diff" data-lang="diff"><span style="color:#f92672">-def render_all(con, entities, game_map, fov_map, fov_recompute, screen_width, screen_height, colors):
</span><span style="color:#f92672"></span><span style="color:#a6e22e">+def render_all(con, entities, player, game_map, fov_map, fov_recompute, screen_width, screen_height, colors):
</span><span style="color:#a6e22e"></span>    ...
    for entity in entities:
        draw_entity(con, entity, fov_map)

<span style="color:#a6e22e">+   libtcod.console_set_default_foreground(con, libtcod.white)
</span><span style="color:#a6e22e">+   libtcod.console_print_ex(con, 1, screen_height - 2, libtcod.BKGND_NONE, libtcod.LEFT,
</span><span style="color:#a6e22e">+                        &#39;HP: {0:02}/{1:02}&#39;.format(player.fighter.hp, player.fighter.max_hp))
</span><span style="color:#a6e22e"></span>
    libtcod.console_blit(con, 0, 0, screen_width, screen_height, 0, 0, 0)
</code></pre></div>

</div>
<div class="data-pane" data-pane="original">
  
<pre><span class="crossed-out-text">def render_all(con, entities, game_map, fov_map, fov_recompute, screen_width, screen_height, colors):</span>
<span class="new-text">def render_all(con, entities, player, game_map, fov_map, fov_recompute, screen_width, screen_height, colors):</span>
    ...
    for entity in entities:
        draw_entity(con, entity, fov_map)

    <span class="new-text">libtcod.console_set_default_foreground(con, libtcod.white)
    libtcod.console_print_ex(con, 1, screen_height - 2, libtcod.BKGND_NONE, libtcod.LEFT,
                         'HP: {0:02}/{1:02}'.format(player.fighter.hp, player.fighter.max_hp))</span>

    libtcod.console_blit(con, 0, 0, screen_width, screen_height, 0, 0, 0)</pre>

</div>

</div>


<p>Mettez l&rsquo;appel de <code>render_all</code> à jouer dans <code>engine.py</code></p>

<div>
  <button class="btn btn-primary data-toggle-tab active" data-toggle-tab="diff">
    Diff
  </button>
  <button class="btn btn-secondary data-toggle-tab" data-toggle-tab="original">
    Original
  </button>

   <div class="data-pane active" data-pane="diff">
   <div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-diff" data-lang="diff"><span style="color:#f92672">-render_all(con, entities, game_map, fov_map, fov_recompute, screen_width, screen_height, colors)
</span><span style="color:#f92672"></span><span style="color:#a6e22e">+render_all(con, entities, player, game_map, fov_map, fov_recompute, screen_width, screen_height, colors)
</span></code></pre></div>

</div>
<div class="data-pane" data-pane="original">
  
<pre><span class="crossed-out-text">render_all(con, entities, game_map, fov_map, fov_recompute, screen_width, screen_height, colors)</span>
<span class="new-text">render_all(con, entities, player, game_map, fov_map, fov_recompute, screen_width, screen_height, colors)</span></pre>

</div>

</div>


<p>Une chose que vous avez certainement déjà remarqué est que les corps des ennemis
décédés &ldquo;recouvrent&rdquo; le joueur si on se déplace dessus. De toute évidence ce
n&rsquo;est le comportement souhaité. Les entités qui agissent devraient toujours
apparaître au dessus des cadavres, des objets et des autres choses du donjon.
Pour résoudre ce problème ajoutons un Enum aux entités. Il décrira l&rsquo;ordre dans
lequel elles doivent être dessinées. Les éléments faible priorité seront
dessinées en premier pour s&rsquo;assurer qu&rsquo;elles n&rsquo;apparaissent jamais au dessus des
autres.</p>

<p>Ajoutez le code suivant à <code>render_functions.py</code> :</p>

<div>
  <button class="btn btn-primary data-toggle-tab active" data-toggle-tab="diff">
    Diff
  </button>
  <button class="btn btn-secondary data-toggle-tab" data-toggle-tab="original">
    Original
  </button>

   <div class="data-pane active" data-pane="diff">
   <div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-diff" data-lang="diff">import tcod as libtcod

<span style="color:#a6e22e">+from enum import Enum
</span><span style="color:#a6e22e">+
</span><span style="color:#a6e22e">+
</span><span style="color:#a6e22e">+class RenderOrder(Enum):
</span><span style="color:#a6e22e">+   CORPSE = 1
</span><span style="color:#a6e22e">+   ITEM = 2
</span><span style="color:#a6e22e">+   ACTOR = 3
</span><span style="color:#a6e22e"></span>

def render_all(con, entities, player, game_map, fov_map, fov_recompute, screen_width, screen_height, colors):
    ...
</code></pre></div>

</div>
<div class="data-pane" data-pane="original">
  
<pre>import tcod as libtcod

<span class="new-text">from enum import Enum


class RenderOrder(Enum):
    CORPSE = 1
    ITEM = 2
    ACTOR = 3</span>


def render_all(con, entities, player, game_map, fov_map, fov_recompute, screen_width, screen_height, colors):
    ...</pre>

</div>

</div>


<p>Now modify the <code>__init__</code> function in <code>Entity</code> to take this into
account.</p>

<div>
  <button class="btn btn-primary data-toggle-tab active" data-toggle-tab="diff">
    Diff
  </button>
  <button class="btn btn-secondary data-toggle-tab" data-toggle-tab="original">
    Original
  </button>

   <div class="data-pane active" data-pane="diff">
   <div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-diff" data-lang="diff">import tcod as libtcod
import math

<span style="color:#a6e22e">+from render_functions import RenderOrder
</span><span style="color:#a6e22e"></span>

class Entity:
    &#34;&#34;&#34;
    A generic object to represent players, enemies, items, etc.
    &#34;&#34;&#34;
<span style="color:#f92672">-   def __init__(self, x, y, char, color, name, blocks=False, fighter=None, ai=None):
</span><span style="color:#f92672"></span><span style="color:#a6e22e">+   def __init__(self, x, y, char, color, name, blocks=False, render_order=RenderOrder.CORPSE, fighter=None, ai=None):
</span><span style="color:#a6e22e"></span>        self.x = x
        self.y = y
        self.char = char
        self.color = color
        self.name = name
        self.blocks = blocks
<span style="color:#a6e22e">+       self.render_order = render_order
</span><span style="color:#a6e22e"></span>        self.fighter = fighter
        ...
</code></pre></div>

</div>
<div class="data-pane" data-pane="original">
  
<pre>import tcod as libtcod
import math

<span class="new-text">from render_functions import RenderOrder</span>


class Entity:
    """
    A generic object to represent players, enemies, items, etc.
    """
    def __init__(self, x, y, char, color, name, blocks=False, <span class="new-text">render_order=RenderOrder.CORPSE,</span> fighter=None, ai=None):
        self.x = x
        self.y = y
        self.char = char
        self.color = color
        self.name = name
        self.blocks = blocks
        <span class="new-text">self.render_order = render_order</span>
        self.fighter = fighter
        ...</pre>

</div>

</div>


<p>Maintenant modifions l&rsquo;initialisation des entités en commençant par <code>engine.py</code>.</p>

<div>
  <button class="btn btn-primary data-toggle-tab active" data-toggle-tab="diff">
    Diff
  </button>
  <button class="btn btn-secondary data-toggle-tab" data-toggle-tab="original">
    Original
  </button>

   <div class="data-pane active" data-pane="diff">
   <div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-diff" data-lang="diff"><span style="color:#f92672">-player = Entity(0, 0, &#39;@&#39;, libtcod.white, &#39;Player&#39;, blocks=True, fighter=fighter_component)
</span><span style="color:#f92672"></span><span style="color:#a6e22e">+player = Entity(0, 0, &#39;@&#39;, libtcod.white, &#39;Player&#39;, blocks=True, render_order=RenderOrder.ACTOR, fighter=fighter_component)
</span></code></pre></div>

</div>
<div class="data-pane" data-pane="original">
  
<pre>player = Entity(0, 0, '@', libtcod.white, 'Player', blocks=True, <span class="new-text">render_order=RenderOrder.ACTOR,</span> fighter=fighter_component)</pre>

</div>

</div>


<p>&hellip; N&rsquo;oublions pas les imports sur le bord de la route :</p>

<div>
  <button class="btn btn-primary data-toggle-tab active" data-toggle-tab="diff">
    Diff
  </button>
  <button class="btn btn-secondary data-toggle-tab" data-toggle-tab="original">
    Original
  </button>

   <div class="data-pane active" data-pane="diff">
   <div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-diff" data-lang="diff"><span style="color:#f92672">-from render_functions import clear_all, render_all
</span><span style="color:#f92672"></span><span style="color:#a6e22e">+from render_functions import clear_all, render_all, RenderOrder
</span></code></pre></div>

</div>
<div class="data-pane" data-pane="original">
  
<pre>from render_functions import clear_all, render_all<span class="new-text">, RenderOrder</span></pre>

</div>

</div>


<p>Et maintenant les monstres de <code>game_map.py</code> :</p>

<div>
  <button class="btn btn-primary data-toggle-tab active" data-toggle-tab="diff">
    Diff
  </button>
  <button class="btn btn-secondary data-toggle-tab" data-toggle-tab="original">
    Original
  </button>

   <div class="data-pane active" data-pane="diff">
   <div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-diff" data-lang="diff">                if randint(0, 100) &lt; 80:
                    fighter_component = Fighter(hp=10, defense=0, power=3)
                    ai_component = BasicMonster()

<span style="color:#f92672">-                   monster = Entity(x, y, &#39;o&#39;, libtcod.desaturated_green, &#39;Orc&#39;, blocks=True,
</span><span style="color:#f92672">-                                    fighter=fighter_component, ai=ai_component)
</span><span style="color:#f92672"></span><span style="color:#a6e22e">+                   monster = Entity(x, y, &#39;o&#39;, libtcod.desaturated_green, &#39;Orc&#39;, blocks=True,
</span><span style="color:#a6e22e">+                                    render_order=RenderOrder.ACTOR, fighter=fighter_component, ai=ai_component)
</span><span style="color:#a6e22e"></span>                else:
                    fighter_component = Fighter(hp=16, defense=1, power=4)
                    ai_component = BasicMonster()

<span style="color:#f92672">-                   monster = Entity(x, y, &#39;T&#39;, libtcod.darker_green, &#39;Troll&#39;, blocks=True, fighter=fighter_component,
</span><span style="color:#f92672">-                                    ai=ai_component)
</span><span style="color:#f92672"></span><span style="color:#a6e22e">+                   monster = Entity(x, y, &#39;T&#39;, libtcod.darker_green, &#39;Troll&#39;, blocks=True, fighter=fighter_component,
</span><span style="color:#a6e22e">+                                    render_order=RenderOrder.ACTOR, ai=ai_component)
</span></code></pre></div>

</div>
<div class="data-pane" data-pane="original">
  
<pre>                if randint(0, 100) < 80:
                    fighter_component = Fighter(hp=10, defense=0, power=3)
                    ai_component = BasicMonster()

                    <span class="crossed-out-text">monster = Entity(x, y, 'o', libtcod.desaturated_green, 'Orc', blocks=True,</span>
                                     <span class="crossed-out-text">fighter=fighter_component, ai=ai_component)</span>
                    <span class="new-text">monster = Entity(x, y, 'o', libtcod.desaturated_green, 'Orc', blocks=True,
                                     render_order=RenderOrder.ACTOR, fighter=fighter_component, ai=ai_component)</span>
                else:
                    fighter_component = Fighter(hp=16, defense=1, power=4)
                    ai_component = BasicMonster()

                    <span class="crossed-out-text">monster = Entity(x, y, 'T', libtcod.darker_green, 'Troll', blocks=True, fighter=fighter_component,</span>
                                     <span class="crossed-out-text">ai=ai_component)</span>
                    <span class="new-text">monster = Entity(x, y, 'T', libtcod.darker_green, 'Troll', blocks=True, fighter=fighter_component,
                                     render_order=RenderOrder.ACTOR, ai=ai_component)</span></pre>

</div>

</div>


<p>&hellip; And the import:</p>

<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-py3" data-lang="py3"><span style="color:#f92672">from</span> render_functions <span style="color:#66d9ef">import</span> RenderOrder</code></pre></div>

<p>We&rsquo;ll also need to change the Entity&rsquo;s <code>render_order</code> when they die.</p>

<div>
  <button class="btn btn-primary data-toggle-tab active" data-toggle-tab="diff">
    Diff
  </button>
  <button class="btn btn-secondary data-toggle-tab" data-toggle-tab="original">
    Original
  </button>

   <div class="data-pane active" data-pane="diff">
   <div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-diff" data-lang="diff">    monster.ai = None
    monster.name = &#39;remains of &#39; + monster.name
<span style="color:#a6e22e">+   monster.render_order = RenderOrder.CORPSE
</span></code></pre></div>

</div>
<div class="data-pane" data-pane="original">
  
    <pre>    monster.ai = None
    monster.name = 'remains of ' + monster.name
    <span class="new-text">monster.render_order = RenderOrder.CORPSE</span></pre>

</div>

</div>


<p>And, you guessed it, make sure you import:</p>

<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-py3" data-lang="py3"><span style="color:#f92672">from</span> render_functions <span style="color:#66d9ef">import</span> RenderOrder</code></pre></div>

<p>** Note: We&rsquo;re not changing the <code>render_order</code> on the player when it
dies; we actually <strong>want</strong> that corpse on top so we&rsquo;ll see it. It&rsquo;s more
dramatic that way!*</p>

<p>Now let&rsquo;s implement the part in <code>render_all</code> that will actually take
this new variable into account.</p>

<div>
  <button class="btn btn-primary data-toggle-tab active" data-toggle-tab="diff">
    Diff
  </button>
  <button class="btn btn-secondary data-toggle-tab" data-toggle-tab="original">
    Original
  </button>

   <div class="data-pane active" data-pane="diff">
   <div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-diff" data-lang="diff">    if fov_recompute:
        ...

<span style="color:#a6e22e">+   entities_in_render_order = sorted(entities, key=lambda x: x.render_order.value)
</span><span style="color:#a6e22e"></span>
<span style="color:#f92672">-   for entity in entities:
</span><span style="color:#f92672"></span><span style="color:#a6e22e">+   for entity in entities_in_render_order:
</span><span style="color:#a6e22e"></span>        draw_entity(con, entity, fov_map)
    ...
</code></pre></div>

</div>
<div class="data-pane" data-pane="original">
  
<pre>    if fov_recompute:
        ...

    <span class="new-text">entities_in_render_order = sorted(entities, key=lambda x: x.render_order.value)</span>

    <span class="crossed-out-text">for entity in entities:</span>
    <span class="new-text">for entity in entities_in_render_order:</span>
        draw_entity(con, entity, fov_map)
    ...</pre>

</div>

</div>


<p>Maintenant les cadavres seront dessinés en premier, ensuite les objets (quand
nous les aurons ajouté) et enfin les entités. Cela nous assure qu&rsquo;on verra
d&rsquo;abord les choses importantes.</p>

<p>Et c&rsquo;est fait ! Ce fut une sacré étape mais vous en êtes sorti indemne !
Lancez le projet et regardez combien de temps vous surviviez dans ce donjon
maudit qui est maintenant mortel. Avec un sytème de combat en place, nous avons
franchis un grand pas vers un vrai jeu roguelike.</p>

<p>Si vous voulez voir le code actuel entièrement, <a href="https://github.com/TStand90/roguelike_tutorial_revised/tree/part6">cliquez ici</a>.</p>

<p><a href="/tutorials/tcod/part-7">Cliquez ici pour vous rendre à la partie suivante de ce tutoriel.</a></p>

<script src="/js/codetabs.js"></script>


    

    


</article>



        </div>

        <aside class="col-12 col-lg-3 ml-auto blog-sidebar">
    
    
        <section>
    
        
    
        
    
</section>
    
</aside>

      </div>
    </div>
    

    
      







<footer class="blog-footer w-100">
    <nav class="navbar navbar-light bg-light">
        <p class="w-100 text-center">Dernière mise à jour le 24 juillet 2019</p>
        <p class="w-100 text-center"><a href="#">Back to top</a></p>
    </nav>
</footer>

    

    
    
    <script src="https://code.jquery.com/jquery-3.3.1.slim.min.js" integrity="sha384-q8i/X+965DzO0rT7abK41JStQIAqVgRVzpbzo5smXKp4YfRvH+8abtTE1Pi6jizo" crossorigin="anonymous"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/popper.js/1.14.3/umd/popper.min.js" integrity="sha384-ZMP7rVo3mIykV+2+9J3UJ46jBk0WLaUAdn689aCwoqbBJiSnjAK/l8WvCWPIPm49" crossorigin="anonymous"></script>
    <script src="https://stackpath.bootstrapcdn.com/bootstrap/4.1.3/js/bootstrap.min.js" integrity="sha384-ChfqqxuZUCnJSK3+MXmPNIyE6ZbWh2IMqE241rYiqJxyMiZ6OW/JmZQ5stwEULTy" crossorigin="anonymous"></script>
  </body>
</html>
