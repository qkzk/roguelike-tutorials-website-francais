<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8">
<meta http-equiv="x-ua-compatible" content="ie=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

<meta property="og:title" content="Part 11 - Explorer les profondeurs du donjons" />
<meta property="og:description" content="Notre jeu ne sera pas un jeu d&rsquo;exploration de donjon tant qu&rsquo;on n&rsquo;aura qu&rsquo;un niveau à parcourir. Dans ce chapitre, nous permettrons au joueur de descendre d&rsquo;un niveau et nous mettrons un simple système de niveau en place afin de rendre l&rsquo;exploration plus gratifiante.
Commençons par modifier GameMap pour retenir la profondeur actuelle. Cela nous aidera quand nous écrirons nos escaliers. Ouvrez game_map et réalisez les modifications suivantes :
 Diff  Original  class GameMap: - def __init__(self, width, height): &#43; def __init__(self, width, height, dungeon_level=1):  self." />
<meta property="og:type" content="article" />
<meta property="og:url" content="/tutoriels/tcod/part-11/" />
<meta property="article:published_time" content="2019-03-30T09:34:06-07:00"/>
<meta property="article:modified_time" content="2019-03-30T09:34:06-07:00"/>

<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Part 11 - Explorer les profondeurs du donjons"/>
<meta name="twitter:description" content="Notre jeu ne sera pas un jeu d&rsquo;exploration de donjon tant qu&rsquo;on n&rsquo;aura qu&rsquo;un niveau à parcourir. Dans ce chapitre, nous permettrons au joueur de descendre d&rsquo;un niveau et nous mettrons un simple système de niveau en place afin de rendre l&rsquo;exploration plus gratifiante.
Commençons par modifier GameMap pour retenir la profondeur actuelle. Cela nous aidera quand nous écrirons nos escaliers. Ouvrez game_map et réalisez les modifications suivantes :
 Diff  Original  class GameMap: - def __init__(self, width, height): &#43; def __init__(self, width, height, dungeon_level=1):  self."/>



    <link rel="canonical" href="/tutoriels/tcod/part-11/">

    <title>
      
        Part 11 - Explorer les profondeurs du donjons | Tutoriel Roguelike
      
    </title>

    
    <link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.1.3/css/bootstrap.min.css" integrity="sha384-MCw98/SFnGE8fJT3GXwEOngsV7Zt27NXFoaoApmYm81iuXoPkFOJwJ8ERdknLPMO" crossorigin="anonymous">
    <link href="/css/style.css" rel="stylesheet">

    

    

    
  </head>
  <body>
    
      

<header class="blog-header">
    <nav class="navbar navbar-expand-md navbar-dark bg-dark">
        <a class="navbar-brand" href="/">
            Tutoriel Roguelike
        </a>
        <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNav" aria-controls="navbarNav" aria-expanded="false"
            aria-label="Toggle navigation">
            <span class="navbar-toggler-icon"></span>
        </button>
        <div class="collapse navbar-collapse justify-content-between" id="navbarNav">
            <ul class="navbar-nav">
                
                
                <li class="nav-item ">
                    
                        <a class="nav-link" href="/">Home</a>
                    
                </li>
                
                <li class="nav-item ">
                    
                        <a class="nav-link" href="/tutoriels/tcod/">Tutoriel TCOD</a>
                    
                </li>
                
                <li class="nav-item ">
                    
                        <a class="nav-link" href="/about/">A propos</a>
                    
                </li>
                
            </ul>
            
        </div>
    </nav>
</header>

    

    
    <div class="container">
      <div class="row">
        <div class="col-12 col-lg-8 blog-main">

          

<header>
    <h2 class="blog-post-title">
    <a class="text-dark" href="/tutoriels/tcod/part-11/">Part 11 - Explorer les profondeurs du donjons</a>
</h2>

    


<div class="blog-post-date text-secondary">
    
        <time datetime="2019-03-30">Mar 30, 2019</time>
    
    
</div>

    
    
    <hr>
</header>
<article class="blog-post">
    <p>Notre jeu ne sera pas un jeu d&rsquo;exploration de donjon tant qu&rsquo;on n&rsquo;aura qu&rsquo;un
niveau à parcourir. Dans ce chapitre, nous permettrons au joueur de descendre
d&rsquo;un niveau et nous mettrons un simple système de niveau en place afin de
rendre l&rsquo;exploration plus gratifiante.</p>

<p>Commençons par modifier <code>GameMap</code> pour retenir la profondeur actuelle. Cela
nous aidera quand nous écrirons nos escaliers. Ouvrez <code>game_map</code> et réalisez
les modifications suivantes :</p>

<div>
  <button class="btn btn-primary data-toggle-tab active" data-toggle-tab="diff">
    Diff
  </button>
  <button class="btn btn-secondary data-toggle-tab" data-toggle-tab="original">
    Original
  </button>

   <div class="data-pane active" data-pane="diff">
   <div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-diff" data-lang="diff">class GameMap:
<span style="color:#f92672">-   def __init__(self, width, height):
</span><span style="color:#f92672"></span><span style="color:#a6e22e">+   def __init__(self, width, height, dungeon_level=1):
</span><span style="color:#a6e22e"></span>        self.width = width
        self.height = height
        self.tiles = self.initialize_tiles()

<span style="color:#a6e22e">+       self.dungeon_level = dungeon_level
</span></code></pre></div>

</div>
<div class="data-pane" data-pane="original">
  
<pre>class GameMap:
    def __init__(self, width, height<span class="new-text">, dungeon_level=1</span>):
        self.width = width
        self.height = height
        self.tiles = self.initialize_tiles()

        <span class="new-text">self.dungeon_level = dungeon_level</span></pre>

</div>

</div>


<p>Les escaliers en eux-même seront d&rsquo;autres entités, comme vous pouviez vous y
attendre. Nous allons créer un nouveau composant qui règle cela en dehors des
autres et qu&rsquo;on appelle <code>Stairs</code> (escaliers). Créez un fichier appelé
<code>stairs.py</code> et ajoutez-y la classe suivante :</p>

<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-py3" data-lang="py3"><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Stairs</span>:
    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">__init__</span>(self, floor):
        self<span style="color:#f92672">.</span>floor <span style="color:#f92672">=</span> floor</code></pre></div>

<p>La variable étage nous indique à quel étage nous allons arriver si on emprunte
les marches. Notre ne permet que de descendre mais vous pouvez aussi l&rsquo;utiliser
pour monter d&rsquo;un étage.</p>

<p>Comme notre autres composants, on doit le passer à <code>Entity</code>.</p>

<div>
  <button class="btn btn-primary data-toggle-tab active" data-toggle-tab="diff">
    Diff
  </button>
  <button class="btn btn-secondary data-toggle-tab" data-toggle-tab="original">
    Original
  </button>

   <div class="data-pane active" data-pane="diff">
   <div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-diff" data-lang="diff">class Entity:
    def __init__(self, x, y, char, color, name, blocks=False, render_order=RenderOrder.CORPSE, fighter=None, ai=None,
<span style="color:#f92672">-                item=None, inventory=None):
</span><span style="color:#f92672"></span><span style="color:#a6e22e">+                item=None, inventory=None, stairs=None):
</span><span style="color:#a6e22e"></span>        self.x = x
        self.y = y
        self.char = char
        self.color = color
        self.name = name
        self.blocks = blocks
        self.render_order = render_order
        self.fighter = fighter
        self.ai = ai
        self.item = item
        self.inventory = inventory
<span style="color:#a6e22e">+       self.stairs = stairs
</span><span style="color:#a6e22e"></span>
        if self.fighter:
            self.fighter.owner = self

        if self.ai:
            self.ai.owner = self

        if self.item:
            self.item.owner = self

        if self.inventory:
            self.inventory.owner = self

<span style="color:#a6e22e">+       if self.stairs:
</span><span style="color:#a6e22e">+           self.stairs.owner = self
</span></code></pre></div>

</div>
<div class="data-pane" data-pane="original">
  
<pre>class Entity:
    def __init__(self, x, y, char, color, name, blocks=False, render_order=RenderOrder.CORPSE, fighter=None, ai=None,
                 item=None, inventory=None<span class="new-text">, stairs=None</span>):
        self.x = x
        self.y = y
        self.char = char
        self.color = color
        self.name = name
        self.blocks = blocks
        self.render_order = render_order
        self.fighter = fighter
        self.ai = ai
        self.item = item
        self.inventory = inventory
        <span class="new-text">self.stairs = stairs</span>

        if self.fighter:
            self.fighter.owner = self

        if self.ai:
            self.ai.owner = self

        if self.item:
            self.item.owner = self

        if self.inventory:
            self.inventory.owner = self

        <span class="new-text">if self.stairs:
            self.stairs.owner = self</span></pre>

</div>

</div>


<p>Pour placer nos escaliers, on utilise notre fonction <code>make_map</code>. Pour garder
les choses simples on placera toujours les escaliers au milieu de la dernière
pièce crée. Modifiez la fonction ainsi :</p>

<div>
  <button class="btn btn-primary data-toggle-tab active" data-toggle-tab="diff">
    Diff
  </button>
  <button class="btn btn-secondary data-toggle-tab" data-toggle-tab="original">
    Original
  </button>

   <div class="data-pane active" data-pane="diff">
   <div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-diff" data-lang="diff">    def make_map(self, max_rooms, room_min_size, room_max_size, map_width, map_height, player, entities,
                 max_monsters_per_room, max_items_per_room):
        rooms = []
        num_rooms = 0

<span style="color:#a6e22e">+       center_of_last_room_x = None
</span><span style="color:#a6e22e">+       center_of_last_room_y = None
</span><span style="color:#a6e22e"></span>
        for r in range(max_rooms):
            # random width and height
            w = randint(room_min_size, room_max_size)
            h = randint(room_min_size, room_max_size)
            # random position without going out of the boundaries of the map
            x = randint(0, map_width - w - 1)
            y = randint(0, map_height - h - 1)

            # &#34;Rect&#34; class makes rectangles easier to work with
            new_room = Rect(x, y, w, h)

            # run through the other rooms and see if they intersect with this one
            for other_room in rooms:
                if new_room.intersect(other_room):
                    break
            else:
                # this means there are no intersections, so this room is valid

                # &#34;paint&#34; it to the map&#39;s tiles
                self.create_room(new_room)

                # center coordinates of new room, will be useful later
                (new_x, new_y) = new_room.center()

<span style="color:#a6e22e">+               center_of_last_room_x = new_x
</span><span style="color:#a6e22e">+               center_of_last_room_y = new_y
</span><span style="color:#a6e22e"></span>
                if num_rooms == 0:
                    # this is the first room, where the player starts at
                    player.x = new_x
                    player.y = new_y
                else:
                    # all rooms after the first:
                    # connect it to the previous room with a tunnel

                    # center coordinates of previous room
                    (prev_x, prev_y) = rooms[num_rooms - 1].center()

                    # flip a coin (random number that is either 0 or 1)
                    if randint(0, 1) == 1:
                        # first move horizontally, then vertically
                        self.create_h_tunnel(prev_x, new_x, prev_y)
                        self.create_v_tunnel(prev_y, new_y, new_x)
                    else:
                        # first move vertically, then horizontally
                        self.create_v_tunnel(prev_y, new_y, prev_x)
                        self.create_h_tunnel(prev_x, new_x, new_y)

                self.place_entities(new_room, entities, max_monsters_per_room, max_items_per_room)

                # finally, append the new room to the list
                rooms.append(new_room)
                num_rooms += 1

<span style="color:#a6e22e">+       stairs_component = Stairs(self.dungeon_level + 1)
</span><span style="color:#a6e22e">+       down_stairs = Entity(center_of_last_room_x, center_of_last_room_y, &#39;&gt;&#39;, libtcod.white, &#39;Stairs&#39;,
</span><span style="color:#a6e22e">+                            render_order=RenderOrder.STAIRS, stairs=stairs_component)
</span><span style="color:#a6e22e">+       entities.append(down_stairs)
</span></code></pre></div>

</div>
<div class="data-pane" data-pane="original">
  
<pre>    def make_map(self, max_rooms, room_min_size, room_max_size, map_width, map_height, player, entities,
                 max_monsters_per_room, max_items_per_room):
        rooms = []
        num_rooms = 0

        <span class="new-text">center_of_last_room_x = None
        center_of_last_room_y = None</span>

        for r in range(max_rooms):
            # random width and height
            w = randint(room_min_size, room_max_size)
            h = randint(room_min_size, room_max_size)
            # random position without going out of the boundaries of the map
            x = randint(0, map_width - w - 1)
            y = randint(0, map_height - h - 1)

            # "Rect" class makes rectangles easier to work with
            new_room = Rect(x, y, w, h)

            # run through the other rooms and see if they intersect with this one
            for other_room in rooms:
                if new_room.intersect(other_room):
                    break
            else:
                # this means there are no intersections, so this room is valid

                # "paint" it to the map's tiles
                self.create_room(new_room)

                # center coordinates of new room, will be useful later
                (new_x, new_y) = new_room.center()

                <span class="new-text">center_of_last_room_x = new_x
                center_of_last_room_y = new_y</span>

                if num_rooms == 0:
                    # this is the first room, where the player starts at
                    player.x = new_x
                    player.y = new_y
                else:
                    # all rooms after the first:
                    # connect it to the previous room with a tunnel

                    # center coordinates of previous room
                    (prev_x, prev_y) = rooms[num_rooms - 1].center()

                    # flip a coin (random number that is either 0 or 1)
                    if randint(0, 1) == 1:
                        # first move horizontally, then vertically
                        self.create_h_tunnel(prev_x, new_x, prev_y)
                        self.create_v_tunnel(prev_y, new_y, new_x)
                    else:
                        # first move vertically, then horizontally
                        self.create_v_tunnel(prev_y, new_y, prev_x)
                        self.create_h_tunnel(prev_x, new_x, new_y)

                self.place_entities(new_room, entities, max_monsters_per_room, max_items_per_room)

                # finally, append the new room to the list
                rooms.append(new_room)
                num_rooms += 1

        <span class="new-text">stairs_component = Stairs(self.dungeon_level + 1)
        down_stairs = Entity(center_of_last_room_x, center_of_last_room_y, '>', libtcod.white, 'Stairs',
                             render_order=RenderOrder.STAIRS, stairs=stairs_component)
        entities.append(down_stairs)</span></pre>

</div>

</div>


<p>Assurez-vous d&rsquo;importer <code>Stairs</code> en haut :</p>

<div>
  <button class="btn btn-primary data-toggle-tab active" data-toggle-tab="diff">
    Diff
  </button>
  <button class="btn btn-secondary data-toggle-tab" data-toggle-tab="original">
    Original
  </button>

   <div class="data-pane active" data-pane="diff">
   <div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-diff" data-lang="diff">...
from components.ai import BasicMonster
from components.fighter import Fighter
from components.item import Item
<span style="color:#a6e22e">+from components.stairs import Stairs
</span><span style="color:#a6e22e"></span>...
</code></pre></div>

</div>
<div class="data-pane" data-pane="original">
  
<pre>...
from components.ai import BasicMonster
from components.fighter import Fighter
from components.item import Item
<span class="new-text">from components.stairs import Stairs</span>
...</pre>

</div>

</div>


<p>Nous créons deux nouvelles variables pour conserver la position du centre
de la dernière pièce et nous les utilisons pour placer notre escalier. Les
escaliers en eux même sont simplement dans un tuple qui contient les coordonnées
x et y.</p>

<p>Remarquez que dans le code précédent, nous utilisons une nouvelle valeur dans
l&rsquo;enum <code>RenderOrder</code>. Nous devrons l&rsquo;ajouter à <code>RenderOrder</code>. Les escaliers
doivent apparaître en dessous du reste et ils doivent occuper la première
valeur. Les autres devront être décalé d&rsquo;un étage.</p>

<div>
  <button class="btn btn-primary data-toggle-tab active" data-toggle-tab="diff">
    Diff
  </button>
  <button class="btn btn-secondary data-toggle-tab" data-toggle-tab="original">
    Original
  </button>

   <div class="data-pane active" data-pane="diff">
   <div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-diff" data-lang="diff">class RenderOrder(Enum):
<span style="color:#a6e22e">+   STAIRS = 1
</span><span style="color:#a6e22e"></span><span style="color:#f92672">-   CORPSE = 1
</span><span style="color:#f92672"></span><span style="color:#a6e22e">+   CORPSE = 2
</span><span style="color:#a6e22e"></span><span style="color:#f92672">-   ITEM = 2
</span><span style="color:#f92672"></span><span style="color:#a6e22e">+   ITEM = 3
</span><span style="color:#a6e22e"></span><span style="color:#f92672">-   ACTOR = 3
</span><span style="color:#f92672"></span><span style="color:#a6e22e">+   ACTOR = 4
</span></code></pre></div>

</div>
<div class="data-pane" data-pane="original">
  
<pre>class RenderOrder(Enum):
    <span class="new-text">STAIRS = 1</span>
    <span class="crossed-out-text">CORPSE = 1</span>
    <span class="new-text">CORPSE = 2</span>
    <span class="crossed-out-text">ITEM = 2</span>
    <span class="new-text">ITEM = 3</span>
    <span class="crossed-out-text">ACTOR = 3</span>
    <span class="new-text">ACTOR = 4</span></pre>

</div>

</div>


<p>Remarquez que si vous utilisez Python 3.6 ou une version plus récente, vous
pouvez vous simplifier la tâche en utilisant la nouvelle fonction <code>auto()</code></p>

<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-py3" data-lang="py3"><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">RenderOrder</span>(Enum):
    STAIRS <span style="color:#f92672">=</span> auto()
    CORPSE <span style="color:#f92672">=</span> auto()
    ITEM <span style="color:#f92672">=</span> auto()
    ACTOR <span style="color:#f92672">=</span> auto()</code></pre></div>

<p>Une difficulté avec notre implémentation actuelle est qu&rsquo;on ne peut voir les
escaliers que s&rsquo;ils sont dans le champ de vision du joueur. Cela peut sembler
cohérent de prime abord mais imaginez que le joueur ait découvert les escaliers
et s&rsquo;en éloigne. Ils n&rsquo;apparaitront plus sur la carte ! Il serait mieux qu&rsquo;une
fois découverts, les escaliers soient toujours dessinés.</p>

<p>Pour rendre cela possible, nous pouvons modifier la fonction <code>draw_entity</code> dans
<code>render_functions</code>.</p>

<div>
  <button class="btn btn-primary data-toggle-tab active" data-toggle-tab="diff">
    Diff
  </button>
  <button class="btn btn-secondary data-toggle-tab" data-toggle-tab="original">
    Original
  </button>

   <div class="data-pane active" data-pane="diff">
   <div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-diff" data-lang="diff"><span style="color:#f92672">-def draw_entity(con, entity, fov_map):
</span><span style="color:#f92672"></span><span style="color:#a6e22e">+def draw_entity(con, entity, fov_map, game_map):
</span><span style="color:#a6e22e"></span><span style="color:#f92672">-   if libtcod.map_is_in_fov(fov_map, entity.x, entity.y):
</span><span style="color:#f92672"></span><span style="color:#a6e22e">+   if libtcod.map_is_in_fov(fov_map, entity.x, entity.y) or (entity.stairs and game_map.tiles[entity.x][entity.y].explored):
</span><span style="color:#a6e22e"></span>        libtcod.console_set_default_foreground(con, entity.color)
        libtcod.console_put_char(con, entity.x, entity.y, entity.char, libtcod.BKGND_NONE)
</code></pre></div>

</div>
<div class="data-pane" data-pane="original">
  
<pre><span class="crossed-out-text">def draw_entity(con, entity, fov_map):</span>
<span class="new-text">def draw_entity(con, entity, fov_map, game_map):</span>
    <span class="crossed-out-text">if libtcod.map_is_in_fov(fov_map, entity.x, entity.y):</span>
    <span class="new-text">if libtcod.map_is_in_fov(fov_map, entity.x, entity.y) or (entity.stairs and game_map.tiles[entity.x][entity.y].explored):</span>
        libtcod.console_set_default_foreground(con, entity.color)
        libtcod.console_put_char(con, entity.x, entity.y, entity.char, libtcod.BKGND_NONE)</pre>

</div>

</div>


<p>Nous vérifions maintenant si une entité à le composant &lsquo;escaliers&rsquo; et si la
carte a été explorée. Si c&rsquo;est le cas, on dessine l&rsquo;entité qu&rsquo;elle soit toujours
dans le champ de vision ou non. Cela fonctionne même si une autre entité est
sur les escaliers.</p>

<p>Remarquez que nous passons l&rsquo;objet <code>game_map</code> à <code>draw_entity</code>. Nous devons
aussi mettre à jour notre appel de <code>draw_entity</code> dans <code>render_all</code>.</p>

<div>
  <button class="btn btn-primary data-toggle-tab active" data-toggle-tab="diff">
    Diff
  </button>
  <button class="btn btn-secondary data-toggle-tab" data-toggle-tab="original">
    Original
  </button>

   <div class="data-pane active" data-pane="diff">
   <div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-diff" data-lang="diff">    for entity in entities_in_render_order:
<span style="color:#f92672">-       draw_entity(con, entity, fov_map)
</span><span style="color:#f92672"></span><span style="color:#a6e22e">+       draw_entity(con, entity, fov_map, game_map)
</span></code></pre></div>

</div>
<div class="data-pane" data-pane="original">
  
<pre>    for entity in entities_in_render_order:
        draw_entity(con, entity, fov_map<span class="new-text">, game_map</span>)</pre>

</div>

</div>


<p>Lancez le jeu maintenant et vous devriez voir des escaliers (si vous parvenez
à les trouver avant de rencontrer votre créateur&hellip;). Maintenant faisons en
sorte qu&rsquo;ils fassent quelque chose.</p>

<p>D&rsquo;abord ajoutons un gestionnaire pour descendre les marches dans
<code>input_handlers.py</code>. Ajoutez ce qui suit à la fonction
<code>handle_player_turn_keys</code>.</p>

<div>
  <button class="btn btn-primary data-toggle-tab active" data-toggle-tab="diff">
    Diff
  </button>
  <button class="btn btn-secondary data-toggle-tab" data-toggle-tab="original">
    Original
  </button>

   <div class="data-pane active" data-pane="diff">
   <div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-diff" data-lang="diff">    ...
    elif key_char == &#39;d&#39;:
        return {&#39;drop_inventory&#39;: True}

<span style="color:#a6e22e">+   elif key.vk == libtcod.KEY_ENTER:
</span><span style="color:#a6e22e">+       return {&#39;take_stairs&#39;: True}
</span><span style="color:#a6e22e"></span>
    if key.vk == libtcod.KEY_ENTER and key.lalt:
        ...
</code></pre></div>

</div>
<div class="data-pane" data-pane="original">
  
<pre>    ...
    elif key_char == 'd':
        return {'drop_inventory': True}

    <span class="new-text">elif key.vk == libtcod.KEY_ENTER:
        return {'take_stairs': True}</span>

    if key.vk == libtcod.KEY_ENTER and key.lalt:
        ...</pre>

</div>

</div>


<p><em>*Remarquez : j&rsquo;ai utilisé la touche Enter plutôt que l&rsquo;habituelle touche &lsquo;&gt;&rsquo;.
C&rsquo;est parce que le code du tutoriel Roguebasin pour la touche &lsquo;&gt;&rsquo; ne fonctionne
pas.</em></p>

<p>Ceci étant fait, nous devons implémenter le code pour déplacer le joueur à
l&rsquo;étage inférieur. Nous devons générer une nouvelle carte, créer une nouvelle
liste d&rsquo;entité et incrémenter un entier qui représente le niveau. Ce n&rsquo;est pas
aussi compliqué que ça en a l&rsquo;air ! Les choses se compliquent un peu si vous
voulez permettre au joueur de remonter mais pour la simplicité de ce tutoriel
nous allons supposer qu&rsquo;une fois descendu d&rsquo;un étage, vous ne pouvez plus
remonter.</p>

<p>Maintenant écrivons la fontion qui va nous descendre d&rsquo;un étage. Ajoutez la
suite à la fin de <code>game_map.py</code> :</p>

<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-py3" data-lang="py3">    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">next_floor</span>(self, player, message_log, constants):
        self<span style="color:#f92672">.</span>dungeon_level <span style="color:#f92672">+=</span> <span style="color:#ae81ff">1</span>
        entities <span style="color:#f92672">=</span> [player]

        self<span style="color:#f92672">.</span>tiles <span style="color:#f92672">=</span> self<span style="color:#f92672">.</span>initialize_tiles()
        self<span style="color:#f92672">.</span>make_map(constants[<span style="color:#e6db74">&#39;max_rooms&#39;</span>], constants[<span style="color:#e6db74">&#39;room_min_size&#39;</span>], constants[<span style="color:#e6db74">&#39;room_max_size&#39;</span>],
                      constants[<span style="color:#e6db74">&#39;map_width&#39;</span>], constants[<span style="color:#e6db74">&#39;map_height&#39;</span>], player, entities,
                      constants[<span style="color:#e6db74">&#39;max_monsters_per_room&#39;</span>], constants[<span style="color:#e6db74">&#39;max_items_per_room&#39;</span>])

        player<span style="color:#f92672">.</span>fighter<span style="color:#f92672">.</span>heal(player<span style="color:#f92672">.</span>fighter<span style="color:#f92672">.</span>max_hp <span style="color:#f92672">//</span> <span style="color:#ae81ff">2</span>)

        message_log<span style="color:#f92672">.</span>add_message(Message(<span style="color:#e6db74">&#39;You take a moment to rest, and recover your strength.&#39;</span>, libtcod<span style="color:#f92672">.</span>light_violet))

        <span style="color:#66d9ef">return</span> entities</code></pre></div>

<p>La fonction commence par incrémenter le niveau du donjon. La liste <code>entities</code>
est crée depuis zéro, elle ne contient que le joueur. Ensuite nous appelons
<code>make_map</code> pour générer un nouveau niveau comme nous l&rsquo;avons fait au début du
jeu. Nous rendons aussi au joueur la moitié de ses HP pour le récompenser de
ses efforts et nous ajoutons un message dans ce sens. Ensuite nous renvoyons
la liste <code>entities</code> pour qu&rsquo;elle soit utilisée par <code>engine.py</code></p>

<p>Enfin, modifions <code>engine.py</code> pour utiliser cette nouvelle fonction.</p>

<div>
  <button class="btn btn-primary data-toggle-tab active" data-toggle-tab="diff">
    Diff
  </button>
  <button class="btn btn-secondary data-toggle-tab" data-toggle-tab="original">
    Original
  </button>

   <div class="data-pane active" data-pane="diff">
   <div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-diff" data-lang="diff">        ...
        inventory_index = action.get(&#39;inventory_index&#39;)
<span style="color:#a6e22e">+       take_stairs = action.get(&#39;take_stairs&#39;)
</span><span style="color:#a6e22e"></span>        exit = action.get(&#39;exit&#39;)
        ...
        if inventory_index is not None and previous_game_state != GameStates.PLAYER_DEAD and inventory_index &lt; len(
            ...

<span style="color:#a6e22e">+       if take_stairs and game_state == GameStates.PLAYERS_TURN:
</span><span style="color:#a6e22e">+           for entity in entities:
</span><span style="color:#a6e22e">+               if entity.stairs and entity.x == player.x and entity.y == player.y:
</span><span style="color:#a6e22e">+                   entities = game_map.next_floor(player, message_log, constants)
</span><span style="color:#a6e22e">+                   fov_map = initialize_fov(game_map)
</span><span style="color:#a6e22e">+                   fov_recompute = True
</span><span style="color:#a6e22e">+                   libtcod.console_clear(con)
</span><span style="color:#a6e22e">+
</span><span style="color:#a6e22e">+                   break
</span><span style="color:#a6e22e">+           else:
</span><span style="color:#a6e22e">+               message_log.add_message(Message(&#39;There are no stairs here.&#39;, libtcod.yellow))
</span><span style="color:#a6e22e"></span>
        if game_state == GameStates.TARGETING:
            ...
</code></pre></div>

</div>
<div class="data-pane" data-pane="original">
  
<pre>
        ...
        inventory_index = action.get('inventory_index')
        <span class="new-text">take_stairs = action.get('take_stairs')</span>
        exit = action.get('exit')
        ...
        if inventory_index is not None and previous_game_state != GameStates.PLAYER_DEAD and inventory_index < len(
            ...

        <span class="new-text">if take_stairs and game_state == GameStates.PLAYERS_TURN:
            for entity in entities:
                if entity.stairs and entity.x == player.x and entity.y == player.y:
                    entities = game_map.next_floor(player, message_log, constants)
                    fov_map = initialize_fov(game_map)
                    fov_recompute = True
                    libtcod.console_clear(con)

                    break
            else:
                message_log.add_message(Message('There are no stairs here.', libtcod.yellow))</span>

        if game_state == GameStates.TARGETING:
            ...</pre>

</div>

</div>


<p>Si le joueur se tient sur les escaliers, nous appelons <code>next_floor</code> réglons
la liste <code>entities</code> sur de nouvelles valeurs. Nous nettoyons aussi l&rsquo;écran
de façon à ce que la carte ne soit plus découverte et nous forçons le champ
de vision à être recalculé. S&rsquo;il n&rsquo;y a pas d&rsquo;escaliers, nous l&rsquo;indiquons au
joueur.</p>

<p>Nous pouvons simplement afficher la profondeur juste en dessous de la barre de
HP en générant la fonction <code>render_all</code> comme ceci :</p>

<div>
  <button class="btn btn-primary data-toggle-tab active" data-toggle-tab="diff">
    Diff
  </button>
  <button class="btn btn-secondary data-toggle-tab" data-toggle-tab="original">
    Original
  </button>

   <div class="data-pane active" data-pane="diff">
   <div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-diff" data-lang="diff">    ...
    render_bar(panel, 1, 1, bar_width, &#39;HP&#39;, player.fighter.hp, player.fighter.max_hp,
               libtcod.light_red, libtcod.darker_red)
<span style="color:#a6e22e">+   libtcod.console_print_ex(panel, 1, 3, libtcod.BKGND_NONE, libtcod.LEFT,
</span><span style="color:#a6e22e">+                            &#39;Dungeon level: {0}&#39;.format(game_map.dungeon_level))
</span><span style="color:#a6e22e"></span>
    libtcod.console_set_default_foreground(panel, libtcod.light_gray)
    ...
</code></pre></div>

</div>
<div class="data-pane" data-pane="original">
  
<pre>
    ...
    render_bar(panel, 1, 1, bar_width, 'HP', player.fighter.hp, player.fighter.max_hp,
               libtcod.light_red, libtcod.darker_red)
    <span class="new-text">libtcod.console_print_ex(panel, 1, 3, libtcod.BKGND_NONE, libtcod.LEFT,
                             'Dungeon level: {0}'.format(game_map.dungeon_level))</span>

    libtcod.console_set_default_foreground(panel, libtcod.light_gray)
    ...
</pre>

</div>

</div>


<p>Et c&rsquo;est tout ! Nous pouvons enfin plonger dans la différents niveaux.
Néanmoins, la façon dont le jeu fonctionne ne rend pas cette exploration très
intéressante. De manière à faire ressembler notre jeu aux roguelikes nous
devons faire deux choses : donner au personnage un moyen de progresser (en
changeant de niveau ou en équipant du matériel) et rendre les monstres plus
menaçant au fur et à mesure qu&rsquo;on descend. Nous allons nous concentrer sur le
premier dans ce chapitre et nous aborderons le second volet dans le chapitre
suivant.</p>

<p>La plupart des roguelikes (et des RPG en général) récompensent le joueur avec
de l&rsquo;expérience une fois un monstre vaincu. Une fois un certain total
d&rsquo;expérience atteint, le joueur gagne un niveau et devient plus fort. De manière
à y parvenir, nous devons faire plusieurs choses. Commençons par modifier
le composant <code>Fighter</code> pour contenir une nouvelle variable <code>xp</code>. Cela
représente les poits d&rsquo;expérience acquis quand un monstre est tué (mais pas
ceux de l&rsquo;entité elle-même, nous reviendrons là dessus plus tard).</p>

<div>
  <button class="btn btn-primary data-toggle-tab active" data-toggle-tab="diff">
    Diff
  </button>
  <button class="btn btn-secondary data-toggle-tab" data-toggle-tab="original">
    Original
  </button>

   <div class="data-pane active" data-pane="diff">
   <div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-diff" data-lang="diff">class Fighter:
<span style="color:#f92672">-   def __init__(self, hp, defense, power):
</span><span style="color:#f92672"></span><span style="color:#a6e22e">+   def __init__(self, hp, defense, power, xp=0):
</span><span style="color:#a6e22e"></span>        self.max_hp = hp
        self.hp = hp
        self.defense = defense
        self.power = power
<span style="color:#a6e22e">+       self.xp = xp
</span></code></pre></div>

</div>
<div class="data-pane" data-pane="original">
  
<pre>class Fighter:
    def __init__(self, hp, defense, power<span class="new-text">, xp=0</span>):
        self.max_hp = hp
        self.hp = hp
        self.defense = defense
        self.power = power
        <span class="new-text">self.xp = xp</span></pre>

</div>

</div>


<p>Nous n&rsquo;avons pas besoin de modifier le composant fighter du joueur mais nous
devons modifier le composant de nos ennemis. Ouvrez <code>game_map.py</code> et modifiez la
fonction <code>place_entities</code> pour inclure les points d&rsquo;expérience de chaque
composant.</p>

<div>
  <button class="btn btn-primary data-toggle-tab active" data-toggle-tab="diff">
    Diff
  </button>
  <button class="btn btn-secondary data-toggle-tab" data-toggle-tab="original">
    Original
  </button>

   <div class="data-pane active" data-pane="diff">
   <div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-diff" data-lang="diff">                ...
                if randint(0, 100) &lt; 80:
<span style="color:#f92672">-                   fighter_component = Fighter(hp=10, defense=0, power=3)
</span><span style="color:#f92672"></span><span style="color:#a6e22e">+                   fighter_component = Fighter(hp=10, defense=0, power=3, xp=35)
</span><span style="color:#a6e22e"></span>                    ai_component = BasicMonster()

                    monster = Entity(x, y, &#39;o&#39;, libtcod.desaturated_green, &#39;Orc&#39;, blocks=True,
                                     render_order=RenderOrder.ACTOR, fighter=fighter_component, ai=ai_component)
                else:
<span style="color:#f92672">-                   fighter_component = Fighter(hp=16, defense=1, power=4)
</span><span style="color:#f92672"></span><span style="color:#a6e22e">+                   fighter_component = Fighter(hp=16, defense=1, power=4, xp=100)
</span><span style="color:#a6e22e"></span>                    ai_component = BasicMonster()

                    monster = Entity(x, y, &#39;T&#39;, libtcod.darker_green, &#39;Troll&#39;, blocks=True, fighter=fighter_component,
                                     render_order=RenderOrder.ACTOR, ai=ai_component)
                ...
</code></pre></div>

</div>
<div class="data-pane" data-pane="original">
  
<pre>                ...
                if randint(0, 100) < 80:
                    fighter_component = Fighter(hp=10, defense=0, power=3<span class="new-text">, xp=35</span>)
                    ai_component = BasicMonster()

                    monster = Entity(x, y, 'o', libtcod.desaturated_green, 'Orc', blocks=True,
                                     render_order=RenderOrder.ACTOR, fighter=fighter_component, ai=ai_component)
                else:
                    fighter_component = Fighter(hp=16, defense=1, power=4<span class="new-text">, xp=100</span>)
                    ai_component = BasicMonster()

                    monster = Entity(x, y, 'T', libtcod.darker_green, 'Troll', blocks=True, fighter=fighter_component,
                                     render_order=RenderOrder.ACTOR, ai=ai_component)
                ...</pre>

</div>

</div>


<p>L&rsquo;expérience du joueur sera légèrement différente parce qu&rsquo;elle doit tenir
compte d&rsquo;un cumul total. Nous devons aussi connaître le nombre de points
nécessaire avant d&rsquo;atteindre le prochain niveau. Créons un nouveau composant
pour conserver ces informations que nous appellerons <code>Level</code> (niveau). Créez un
nouveau fichier dans <code>components</code> appelé <code>level.py</code> et ajoutez le code suivant :</p>

<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-py3" data-lang="py3"><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Level</span>:
    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">__init__</span>(self, current_level<span style="color:#f92672">=</span><span style="color:#ae81ff">1</span>, current_xp<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>, level_up_base<span style="color:#f92672">=</span><span style="color:#ae81ff">200</span>, level_up_factor<span style="color:#f92672">=</span><span style="color:#ae81ff">150</span>):
        self<span style="color:#f92672">.</span>current_level <span style="color:#f92672">=</span> current_level
        self<span style="color:#f92672">.</span>current_xp <span style="color:#f92672">=</span> current_xp
        self<span style="color:#f92672">.</span>level_up_base <span style="color:#f92672">=</span> level_up_base
        self<span style="color:#f92672">.</span>level_up_factor <span style="color:#f92672">=</span> level_up_factor

    <span style="color:#a6e22e">@property</span>
    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">experience_to_next_level</span>(self):
        <span style="color:#66d9ef">return</span> self<span style="color:#f92672">.</span>level_up_base <span style="color:#f92672">+</span> self<span style="color:#f92672">.</span>current_level <span style="color:#f92672">*</span> self<span style="color:#f92672">.</span>level_up_factor

    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">add_xp</span>(self, xp):
        self<span style="color:#f92672">.</span>current_xp <span style="color:#f92672">+=</span> xp

        <span style="color:#66d9ef">if</span> self<span style="color:#f92672">.</span>current_xp <span style="color:#f92672">&gt;</span> self<span style="color:#f92672">.</span>experience_to_next_level:
            self<span style="color:#f92672">.</span>current_xp <span style="color:#f92672">-=</span> self<span style="color:#f92672">.</span>experience_to_next_level
            self<span style="color:#f92672">.</span>current_level <span style="color:#f92672">+=</span> <span style="color:#ae81ff">1</span>

            <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">True</span>
        <span style="color:#66d9ef">else</span>:
            <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">False</span></code></pre></div>

<p>J&rsquo;ai réglé toutes les variables de cette sur les valeurs par défaut qui me
conviennent et je vous invite à choisir les vôtres. Il est certainement plus
judicieux de déplacer ces variables vers notre dictionnaire de constantes mais
afin de gagner du temps je les ai placées là.</p>

<p>Le niveau courant, <code>current_level</code>, est le niveau du joueur. Il commence
toujours à un sauf si nous chargeons une partie. <code>current_xp</code> est une somme
cumulée des points d&rsquo;expérience. Elle est remise à zéro quand on gagne un
niveau. <code>level_up_base</code> et <code>level_up_factor</code> sont employées dans la formule
de gain de niveau.</p>

<p>Quand le joueur gagne des points d&rsquo;expérience, on vérifie si l&rsquo;expérience est
supérieure au seuil ajouté au niveau multiplié par le facteur. Cela rend
la progression plus lente au fur et à mesure qu&rsquo;on gagne des niveaux.
Si l&rsquo;expérience dépasse ce seuil, on reset <code>current_xp</code> et on renvoie <code>True</code>
(ce que notre moteur interprétera comme le gain d&rsquo;un niveau par le joueur).</p>

<p>Le seuil actuel de gain de niveau est géré par la propriété
<code>experience_to_next_level</code>. Qu&rsquo;est ce qu&rsquo;une propriété ? C&rsquo;est grosso-modo une
variable en lecture seule à laquelle on peut facilement accéder et qui réside
dans la classe de l&rsquo;objet créé. À chaque accès <code>experience_to_next_level</code> aura
la dernière valeur aussi il suffit de dire
<code>player.level.experience_to_next_level</code> pour obtenir la bonne valeur.</p>

<p>Ajoutons ce nouveau composant à <code>Entity</code> :</p>

<div>
  <button class="btn btn-primary data-toggle-tab active" data-toggle-tab="diff">
    Diff
  </button>
  <button class="btn btn-secondary data-toggle-tab" data-toggle-tab="original">
    Original
  </button>

   <div class="data-pane active" data-pane="diff">
   <div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-diff" data-lang="diff">class Entity:
    def __init__(self, x, y, char, color, name, blocks=False, render_order=RenderOrder.CORPSE, fighter=None, ai=None,
<span style="color:#f92672">-                item=None, inventory=None, stairs=None):
</span><span style="color:#f92672"></span><span style="color:#a6e22e">+                item=None, inventory=None, stairs=None, level=None):
</span><span style="color:#a6e22e"></span>        self.x = x
        self.y = y
        self.char = char
        self.color = color
        self.name = name
        self.blocks = blocks
        self.render_order = render_order
        self.fighter = fighter
        self.ai = ai
        self.item = item
        self.inventory = inventory
        self.stairs = stairs
<span style="color:#a6e22e">+       self.level = level
</span><span style="color:#a6e22e"></span>
        if self.fighter:
            self.fighter.owner = self

        if self.ai:
            self.ai.owner = self

        if self.item:
            self.item.owner = self

        if self.inventory:
            self.inventory.owner = self

        if self.stairs:
            self.stairs.owner = self

<span style="color:#a6e22e">+       if self.level:
</span><span style="color:#a6e22e">+           self.level.owner = self
</span></code></pre></div>

</div>
<div class="data-pane" data-pane="original">
  
<pre>class Entity:
    def __init__(self, x, y, char, color, name, blocks=False, render_order=RenderOrder.CORPSE, fighter=None, ai=None,
                 item=None, inventory=None, stairs=None<span class="new-text">, level=None</span>):
        self.x = x
        self.y = y
        self.char = char
        self.color = color
        self.name = name
        self.blocks = blocks
        self.render_order = render_order
        self.fighter = fighter
        self.ai = ai
        self.item = item
        self.inventory = inventory
        self.stairs = stairs
        <span class="new-text">self.level = level</span>

        if self.fighter:
            self.fighter.owner = self

        if self.ai:
            self.ai.owner = self

        if self.item:
            self.item.owner = self

        if self.inventory:
            self.inventory.owner = self

        if self.stairs:
            self.stairs.owner = self

        <span class="new-text">if self.level:
            self.level.owner = self</span></pre>

</div>

</div>


<p>Nous devons maintenant l&rsquo;ajouter à l&rsquo;objet <code>player</code>. Ouvrez
<code>initialize_new_game.py</code> et réalisez les changements suivants :</p>

<div>
  <button class="btn btn-primary data-toggle-tab active" data-toggle-tab="diff">
    Diff
  </button>
  <button class="btn btn-secondary data-toggle-tab" data-toggle-tab="original">
    Original
  </button>

   <div class="data-pane active" data-pane="diff">
   <div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-diff" data-lang="diff">    fighter_component = Fighter(hp=30, defense=2, power=5)
    inventory_component = Inventory(26)
<span style="color:#a6e22e">+   level_component = Level()
</span><span style="color:#a6e22e"></span>    player = Entity(0, 0, &#39;@&#39;, libtcod.white, &#39;Player&#39;, blocks=True, render_order=RenderOrder.ACTOR,
<span style="color:#f92672">-                   fighter=fighter_component, inventory=inventory_component)
</span><span style="color:#f92672"></span><span style="color:#a6e22e">+                   fighter=fighter_component, inventory=inventory_component, level=level_component)
</span></code></pre></div>

</div>
<div class="data-pane" data-pane="original">
  
<pre>
    fighter_component = Fighter(hp=30, defense=2, power=5)
    inventory_component = Inventory(26)
    <span class="new-text">level_component = Level()</span>
    player = Entity(0, 0, '@', libtcod.white, 'Player', blocks=True, render_order=RenderOrder.ACTOR,
                    fighter=fighter_component, inventory=inventory_component<span class="new-text">, level=level_component</span>)
</pre>

</div>

</div>


<p>Souvenez vous d&rsquo;importez <code>Level</code> en haut :</p>

<div>
  <button class="btn btn-primary data-toggle-tab active" data-toggle-tab="diff">
    Diff
  </button>
  <button class="btn btn-secondary data-toggle-tab" data-toggle-tab="original">
    Original
  </button>

   <div class="data-pane active" data-pane="diff">
   <div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-diff" data-lang="diff">from components.fighter import Fighter
from components.inventory import Inventory
<span style="color:#a6e22e">+from components.level import Level
</span></code></pre></div>

</div>
<div class="data-pane" data-pane="original">
  
<pre>
from components.fighter import Fighter
from components.inventory import Inventory
<span class="new-text">from components.level import Level</span>
</pre>

</div>

</div>


<p>Par tradition dans les RPG le gain d&rsquo;expérience se fait à la mort du monstre.
Nous pouvons renvoyer le montant d&rsquo;xp avec le résultat de la méthode
<code>take_damage</code> du composant <code>Fighter</code>.</p>

<div>
  <button class="btn btn-primary data-toggle-tab active" data-toggle-tab="diff">
    Diff
  </button>
  <button class="btn btn-secondary data-toggle-tab" data-toggle-tab="original">
    Original
  </button>

   <div class="data-pane active" data-pane="diff">
   <div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-diff" data-lang="diff">    def take_damage(self, amount):
        results = []

        self.hp -= amount

        if self.hp &lt;= 0:
<span style="color:#f92672">-           results.append({&#39;dead&#39;: self.owner})
</span><span style="color:#f92672"></span><span style="color:#a6e22e">+           results.append({&#39;dead&#39;: self.owner, &#39;xp&#39;: self.xp})
</span><span style="color:#a6e22e"></span>
        return results
</code></pre></div>

</div>
<div class="data-pane" data-pane="original">
  
<pre>    def take_damage(self, amount):
        results = []

        self.hp -= amount

        if self.hp <= 0:
            results.append({'dead': self.owner<span class="new-text">, 'xp': self.xp</span>})

        return results</pre>

</div>

</div>


<p>Et maintenant intégrons ce résultat dans  <code>engine.py</code> :</p>

<div>
  <button class="btn btn-primary data-toggle-tab active" data-toggle-tab="diff">
    Diff
  </button>
  <button class="btn btn-secondary data-toggle-tab" data-toggle-tab="original">
    Original
  </button>

   <div class="data-pane active" data-pane="diff">
   <div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-diff" data-lang="diff">            ...
            targeting_cancelled = player_turn_result.get(&#39;targeting_cancelled&#39;)
<span style="color:#a6e22e">+           xp = player_turn_result.get(&#39;xp&#39;)
</span><span style="color:#a6e22e"></span>
            if message:
                ...
</code></pre></div>

</div>
<div class="data-pane" data-pane="original">
  
<pre>            ...
            targeting_cancelled = player_turn_result.get('targeting_cancelled')
            <span class="new-text">xp = player_turn_result.get('xp')</span>

            if message:
                ...</pre>

</div>

</div>


<div>
  <button class="btn btn-primary data-toggle-tab active" data-toggle-tab="diff">
    Diff
  </button>
  <button class="btn btn-secondary data-toggle-tab" data-toggle-tab="original">
    Original
  </button>

   <div class="data-pane active" data-pane="diff">
   <div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-diff" data-lang="diff">            ...
            if targeting_cancelled:
                ...

<span style="color:#a6e22e">+           if xp:
</span><span style="color:#a6e22e">+               leveled_up = player.level.add_xp(xp)
</span><span style="color:#a6e22e">+               message_log.add_message(Message(&#39;You gain {0} experience points.&#39;.format(xp)))
</span><span style="color:#a6e22e">+
</span><span style="color:#a6e22e">+               if leveled_up:
</span><span style="color:#a6e22e">+                   message_log.add_message(Message(
</span><span style="color:#a6e22e">+                       &#39;Your battle skills grow stronger! You reached level {0}&#39;.format(
</span><span style="color:#a6e22e">+                           player.level.current_level) + &#39;!&#39;, libtcod.yellow))
</span><span style="color:#a6e22e">+                   previous_game_state = game_state
</span><span style="color:#a6e22e">+                   game_state = GameStates.LEVEL_UP
</span><span style="color:#a6e22e"></span>
        if game_state == GameStates.ENEMY_TURN:
            ...
</code></pre></div>

</div>
<div class="data-pane" data-pane="original">
  
<pre>            ...
            if targeting_cancelled:
                ...

            <span class="new-text">if xp:
                leveled_up = player.level.add_xp(xp)
                message_log.add_message(Message('You gain {0} experience points.'.format(xp)))

                if leveled_up:
                    message_log.add_message(Message(
                        'Your battle skills grow stronger! You reached level {0}'.format(
                            player.level.current_level) + '!', libtcod.yellow))
                    previous_game_state = game_state
                    game_state = GameStates.LEVEL_UP</span>

        if game_state == GameStates.ENEMY_TURN:
            ...</pre>

</div>

</div>


<p>De toute évidence nous devons ajouter l&rsquo;état du jeu <code>LEVEL_UP</code> à notre enum
<code>GameStates</code>.</p>

<div>
  <button class="btn btn-primary data-toggle-tab active" data-toggle-tab="diff">
    Diff
  </button>
  <button class="btn btn-secondary data-toggle-tab" data-toggle-tab="original">
    Original
  </button>

   <div class="data-pane active" data-pane="diff">
   <div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-diff" data-lang="diff">class GameStates(Enum):
    PLAYERS_TURN = 1
    ENEMY_TURN = 2
    PLAYER_DEAD = 3
    SHOW_INVENTORY = 4
    DROP_INVENTORY = 5
    TARGETING = 6
<span style="color:#a6e22e">+   LEVEL_UP = 7
</span></code></pre></div>

</div>
<div class="data-pane" data-pane="original">
  
<pre>class GameStates(Enum):
    PLAYERS_TURN = 1
    ENEMY_TURN = 2
    PLAYER_DEAD = 3
    SHOW_INVENTORY = 4
    DROP_INVENTORY = 5
    TARGETING = 6
    <span class="new-text">LEVEL_UP = 7</span></pre>

</div>

</div>


<p>Que se passe-t-il quand le joueur gagne un niveau ? Notre système sera plutôt
simple : le joueur aura le choix entre améliorer ses HP, son attaque ou sa
défense. Un menu va apparaître, proposant à l&rsquo;utilisateur de choisir parmi
une de ces améliorations et ne se fermera qu&rsquo;une fois la sélection effectuée.</p>

<p>Créons une nouvelle fonction de menu, intitulée <code>level_up_menu</code> qui va afficher
nos options :</p>

<div>
  <button class="btn btn-primary data-toggle-tab active" data-toggle-tab="diff">
    Diff
  </button>
  <button class="btn btn-secondary data-toggle-tab" data-toggle-tab="original">
    Original
  </button>

   <div class="data-pane active" data-pane="diff">
   <div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-diff" data-lang="diff">def main_menu(con, background_image, screen_width, screen_height):
    ...

<span style="color:#a6e22e">+def level_up_menu(con, header, player, menu_width, screen_width, screen_height):
</span><span style="color:#a6e22e">+   options = [&#39;Constitution (+20 HP, from {0})&#39;.format(player.fighter.max_hp),
</span><span style="color:#a6e22e">+              &#39;Strength (+1 attack, from {0})&#39;.format(player.fighter.power),
</span><span style="color:#a6e22e">+              &#39;Agility (+1 defense, from {0})&#39;.format(player.fighter.defense)]
</span><span style="color:#a6e22e">+
</span><span style="color:#a6e22e">+   menu(con, header, options, menu_width, screen_width, screen_height)
</span><span style="color:#a6e22e"></span>

def message_box(con, header, width, screen_width, screen_height):
    ...
</code></pre></div>

</div>
<div class="data-pane" data-pane="original">
  
<pre>def main_menu(con, background_image, screen_width, screen_height):
    ...

<span class="new-text">def level_up_menu(con, header, player, menu_width, screen_width, screen_height):
    options = ['Constitution (+20 HP, from {0})'.format(player.fighter.max_hp),
               'Strength (+1 attack, from {0})'.format(player.fighter.power),
               'Agility (+1 defense, from {0})'.format(player.fighter.defense)]

    menu(con, header, options, menu_width, screen_width, screen_height)</span>


def message_box(con, header, width, screen_width, screen_height):
    ...</pre>

</div>

</div>


<p>Modifiez la fonction <code>render_all</code> pour afficher ce menu après avoir importé
la fonction <code>level_up_menu</code>.</p>

<div>
  <button class="btn btn-primary data-toggle-tab active" data-toggle-tab="diff">
    Diff
  </button>
  <button class="btn btn-secondary data-toggle-tab" data-toggle-tab="original">
    Original
  </button>

   <div class="data-pane active" data-pane="diff">
   <div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-diff" data-lang="diff">import tcod as libtcod

from enum import Enum

from game_states import GameStates

<span style="color:#f92672">-from menus import inventory_menu
</span><span style="color:#f92672"></span><span style="color:#a6e22e">+from menus import inventory_menu, level_up_menu
</span><span style="color:#a6e22e"></span>...
</code></pre></div>

</div>
<div class="data-pane" data-pane="original">
  
<pre>import tcod as libtcod

from enum import Enum

from game_states import GameStates

from menus import inventory_menu<span class="new-text">, level_up_menu</span>
...</pre>

</div>

</div>


<div>
  <button class="btn btn-primary data-toggle-tab active" data-toggle-tab="diff">
    Diff
  </button>
  <button class="btn btn-secondary data-toggle-tab" data-toggle-tab="original">
    Original
  </button>

   <div class="data-pane active" data-pane="diff">
   <div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-diff" data-lang="diff">    if game_state in (GameStates.SHOW_INVENTORY, GameStates.DROP_INVENTORY):
        ...

<span style="color:#a6e22e">+   elif game_state == GameStates.LEVEL_UP:
</span><span style="color:#a6e22e">+       level_up_menu(con, &#39;Level up! Choose a stat to raise:&#39;, player, 40, screen_width, screen_height)
</span></code></pre></div>

</div>
<div class="data-pane" data-pane="original">
  
<pre>
    if game_state in (GameStates.SHOW_INVENTORY, GameStates.DROP_INVENTORY):
        ...

    <span class="new-text">elif game_state == GameStates.LEVEL_UP:
        level_up_menu(con, 'Level up! Choose a stat to raise:', player, 40, screen_width, screen_height)</span>
</pre>

</div>

</div>


<p>Bien sûr, nous devrons gérer la saisie dans ce menu. Ouvrez <code>input_handlers.py</code>
et ajoutez la fonction suivante :</p>

<div>
  <button class="btn btn-primary data-toggle-tab active" data-toggle-tab="diff">
    Diff
  </button>
  <button class="btn btn-secondary data-toggle-tab" data-toggle-tab="original">
    Original
  </button>

   <div class="data-pane active" data-pane="diff">
   <div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-diff" data-lang="diff">def handle_main_menu(key):
    ...

<span style="color:#a6e22e">+def handle_level_up_menu(key):
</span><span style="color:#a6e22e">+   if key:
</span><span style="color:#a6e22e">+       key_char = chr(key.c)
</span><span style="color:#a6e22e">+
</span><span style="color:#a6e22e">+       if key_char == &#39;a&#39;:
</span><span style="color:#a6e22e">+           return {&#39;level_up&#39;: &#39;hp&#39;}
</span><span style="color:#a6e22e">+       elif key_char == &#39;b&#39;:
</span><span style="color:#a6e22e">+           return {&#39;level_up&#39;: &#39;str&#39;}
</span><span style="color:#a6e22e">+       elif key_char == &#39;c&#39;:
</span><span style="color:#a6e22e">+           return {&#39;level_up&#39;: &#39;def&#39;}
</span><span style="color:#a6e22e">+
</span><span style="color:#a6e22e">+   return {}
</span><span style="color:#a6e22e"></span>

def handle_mouse(mouse):
    ...
</code></pre></div>

</div>
<div class="data-pane" data-pane="original">
  
<pre>def handle_main_menu(key):
    ...

<span class="new-text">def handle_level_up_menu(key):
    if key:
        key_char = chr(key.c)

        if key_char == 'a':
            return {'level_up': 'hp'}
        elif key_char == 'b':
            return {'level_up': 'str'}
        elif key_char == 'c':
            return {'level_up': 'def'}

    return {}</span>


def handle_mouse(mouse):
    ...</pre>

</div>

</div>


<p>Modifiez la fonction <code>handle_keys</code> pour employer ce nouveau gestionnaire :</p>

<div>
  <button class="btn btn-primary data-toggle-tab active" data-toggle-tab="diff">
    Diff
  </button>
  <button class="btn btn-secondary data-toggle-tab" data-toggle-tab="original">
    Original
  </button>

   <div class="data-pane active" data-pane="diff">
   <div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-diff" data-lang="diff">def handle_keys(key, game_state):
    if game_state == GameStates.PLAYERS_TURN:
        return handle_player_turn_keys(key)
    elif game_state == GameStates.PLAYER_DEAD:
        return handle_player_dead_keys(key)
    elif game_state == GameStates.TARGETING:
        return handle_targeting_keys(key)
    elif game_state in (GameStates.SHOW_INVENTORY, GameStates.DROP_INVENTORY):
        return handle_inventory_keys(key)
<span style="color:#a6e22e">+   elif game_state == GameStates.LEVEL_UP:
</span><span style="color:#a6e22e">+       return handle_level_up_menu(key)
</span><span style="color:#a6e22e"></span>
    return {}
</code></pre></div>

</div>
<div class="data-pane" data-pane="original">
  
<pre>def handle_keys(key, game_state):
    if game_state == GameStates.PLAYERS_TURN:
        return handle_player_turn_keys(key)
    elif game_state == GameStates.PLAYER_DEAD:
        return handle_player_dead_keys(key)
    elif game_state == GameStates.TARGETING:
        return handle_targeting_keys(key)
    elif game_state in (GameStates.SHOW_INVENTORY, GameStates.DROP_INVENTORY):
        return handle_inventory_keys(key)
    <span class="new-text">elif game_state == GameStates.LEVEL_UP:
        return handle_level_up_menu(key)</span>

    return {}</pre>

</div>

</div>


<p>Notre nouveau gestionnaire étant réalisé, nous devons employer ce résultat
dans <code>engine.py</code> :</p>

<div>
  <button class="btn btn-primary data-toggle-tab active" data-toggle-tab="diff">
    Diff
  </button>
  <button class="btn btn-secondary data-toggle-tab" data-toggle-tab="original">
    Original
  </button>

   <div class="data-pane active" data-pane="diff">
   <div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-diff" data-lang="diff">        ...
        take_stairs = action.get(&#39;take_stairs&#39;)
<span style="color:#a6e22e">+       level_up = action.get(&#39;level_up&#39;)
</span><span style="color:#a6e22e"></span>        exit = action.get(&#39;exit&#39;)
        ...
</code></pre></div>

</div>
<div class="data-pane" data-pane="original">
  
<pre>        ...
        take_stairs = action.get('take_stairs')
        <span class="new-text">level_up = action.get('level_up')</span>
        exit = action.get('exit')
        ...</pre>

</div>

</div>


<div>
  <button class="btn btn-primary data-toggle-tab active" data-toggle-tab="diff">
    Diff
  </button>
  <button class="btn btn-secondary data-toggle-tab" data-toggle-tab="original">
    Original
  </button>

   <div class="data-pane active" data-pane="diff">
   <div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-diff" data-lang="diff">        if take_stairs and game_state == GameStates.PLAYERS_TURN:
            ...

<span style="color:#a6e22e">+       if level_up:
</span><span style="color:#a6e22e">+           if level_up == &#39;hp&#39;:
</span><span style="color:#a6e22e">+               player.fighter.max_hp += 20
</span><span style="color:#a6e22e">+               player.fighter.hp += 20
</span><span style="color:#a6e22e">+           elif level_up == &#39;str&#39;:
</span><span style="color:#a6e22e">+               player.fighter.power += 1
</span><span style="color:#a6e22e">+           elif level_up == &#39;def&#39;:
</span><span style="color:#a6e22e">+               player.fighter.defense += 1
</span><span style="color:#a6e22e">+
</span><span style="color:#a6e22e">+           game_state = previous_game_state
</span><span style="color:#a6e22e"></span>
        if game_state == GameStates.TARGETING:
            ...
</code></pre></div>

</div>
<div class="data-pane" data-pane="original">
  
<pre>        if take_stairs and game_state == GameStates.PLAYERS_TURN:
            ...

        <span class="new-text">if level_up:
            if level_up == 'hp':
                player.fighter.max_hp += 20
                player.fighter.hp += 20
            elif level_up == 'str':
                player.fighter.power += 1
            elif level_up == 'def':
                player.fighter.defense += 1

            game_state = previous_game_state</span>

        if game_state == GameStates.TARGETING:
            ...</pre>

</div>

</div>


<p>De manière à aider le joueur à connaître sa progression, créons et écran
de statistiques du personnage (&ldquo;character screen&rdquo;) qui affichera les valeurs
courantes. Cela va demander un nouvel état du jeu aussi ajoutons le maintenant.</p>

<div>
  <button class="btn btn-primary data-toggle-tab active" data-toggle-tab="diff">
    Diff
  </button>
  <button class="btn btn-secondary data-toggle-tab" data-toggle-tab="original">
    Original
  </button>

   <div class="data-pane active" data-pane="diff">
   <div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-diff" data-lang="diff">class GameStates(Enum):
    PLAYERS_TURN = 1
    ENEMY_TURN = 2
    PLAYER_DEAD = 3
    SHOW_INVENTORY = 4
    DROP_INVENTORY = 5
    TARGETING = 6
    LEVEL_UP = 7
<span style="color:#a6e22e">+   CHARACTER_SCREEN = 8
</span></code></pre></div>

</div>
<div class="data-pane" data-pane="original">
  
<pre>class GameStates(Enum):
    PLAYERS_TURN = 1
    ENEMY_TURN = 2
    PLAYER_DEAD = 3
    SHOW_INVENTORY = 4
    DROP_INVENTORY = 5
    TARGETING = 6
    LEVEL_UP = 7
    <span class="new-text">CHARACTER_SCREEN = 8</span></pre>

</div>

</div>


<p>Nous devrions afficher l&rsquo;écran quand la touche &lsquo;c&rsquo; est enfoncée. Ajoutons cette
touche à <code>handle_player_turn_keys</code> :</p>

<div>
  <button class="btn btn-primary data-toggle-tab active" data-toggle-tab="diff">
    Diff
  </button>
  <button class="btn btn-secondary data-toggle-tab" data-toggle-tab="original">
    Original
  </button>

   <div class="data-pane active" data-pane="diff">
   <div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-diff" data-lang="diff">    ...
    elif key.vk == libtcod.KEY_ENTER:
        return {&#39;take_stairs&#39;: True}

<span style="color:#a6e22e">+   elif key_char == &#39;c&#39;:
</span><span style="color:#a6e22e">+       return {&#39;show_character_screen&#39;: True}
</span><span style="color:#a6e22e"></span>
    if key.vk == libtcod.KEY_ENTER and key.lalt:
        ...
</code></pre></div>

</div>
<div class="data-pane" data-pane="original">
  
<pre>    ...
    elif key.vk == libtcod.KEY_ENTER:
        return {'take_stairs': True}

    <span class="new-text">elif key_char == 'c':
        return {'show_character_screen': True}</span>

    if key.vk == libtcod.KEY_ENTER and key.lalt:
        ...
</pre>

</div>

</div>


<p>Et maintenant intégrons le à <code>engine.py</code> :</p>

<div>
  <button class="btn btn-primary data-toggle-tab active" data-toggle-tab="diff">
    Diff
  </button>
  <button class="btn btn-secondary data-toggle-tab" data-toggle-tab="original">
    Original
  </button>

   <div class="data-pane active" data-pane="diff">
   <div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-diff" data-lang="diff">        ...
        level_up = action.get(&#39;level_up&#39;)
<span style="color:#a6e22e">+       show_character_screen = action.get(&#39;show_character_screen&#39;)
</span><span style="color:#a6e22e"></span>        exit = action.get(&#39;exit&#39;)
        ...
</code></pre></div>

</div>
<div class="data-pane" data-pane="original">
  
<pre>        ...
        level_up = action.get('level_up')
        <span class="new-text">show_character_screen = action.get('show_character_screen')</span>
        exit = action.get('exit')
        ...</pre>

</div>

</div>


<div>
  <button class="btn btn-primary data-toggle-tab active" data-toggle-tab="diff">
    Diff
  </button>
  <button class="btn btn-secondary data-toggle-tab" data-toggle-tab="original">
    Original
  </button>

   <div class="data-pane active" data-pane="diff">
   <div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-diff" data-lang="diff">        ...
        if level_up:
            ...

<span style="color:#a6e22e">+       if show_character_screen:
</span><span style="color:#a6e22e">+           previous_game_state = game_state
</span><span style="color:#a6e22e">+           game_state = GameStates.CHARACTER_SCREEN
</span><span style="color:#a6e22e"></span>
        if game_state == GameStates.TARGETING:
            ...
</code></pre></div>

</div>
<div class="data-pane" data-pane="original">
  
<pre>        ...
        if level_up:
            ...

        <span class="new-text">if show_character_screen:
            previous_game_state = game_state
            game_state = GameStates.CHARACTER_SCREEN</span>

        if game_state == GameStates.TARGETING:
            ...</pre>

</div>

</div>


<p>Maintenant écrivons un gestionnaire de saisie pour l&rsquo;écran de statistiques du
personnage. Tout ce qu&rsquo;il fait est de gérer la touche Escape étant donné que
notre écran n&rsquo;est pas du tout interactif.</p>

<div>
  <button class="btn btn-primary data-toggle-tab active" data-toggle-tab="diff">
    Diff
  </button>
  <button class="btn btn-secondary data-toggle-tab" data-toggle-tab="original">
    Original
  </button>

   <div class="data-pane active" data-pane="diff">
   <div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-diff" data-lang="diff">def handle_level_up_menu(key):
    ...

<span style="color:#a6e22e">+def handle_character_screen(key):
</span><span style="color:#a6e22e">+   if key.vk == libtcod.KEY_ESCAPE:
</span><span style="color:#a6e22e">+       return {&#39;exit&#39;: True}
</span><span style="color:#a6e22e">+
</span><span style="color:#a6e22e">+   return {}
</span><span style="color:#a6e22e"></span>

def handle_mouse(mouse):
    ...
</code></pre></div>

</div>
<div class="data-pane" data-pane="original">
  
<pre>def handle_level_up_menu(key):
    ...

<span class="new-text">def handle_character_screen(key):
    if key.vk == libtcod.KEY_ESCAPE:
        return {'exit': True}

    return {}</span>


def handle_mouse(mouse):
    ...</pre>

</div>

</div>


<p>Modifier <code>handle_keys</code> pour appeler cette fonction quand on affiche l&rsquo;écran
du personnage :</p>

<div>
  <button class="btn btn-primary data-toggle-tab active" data-toggle-tab="diff">
    Diff
  </button>
  <button class="btn btn-secondary data-toggle-tab" data-toggle-tab="original">
    Original
  </button>

   <div class="data-pane active" data-pane="diff">
   <div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-diff" data-lang="diff">def handle_keys(key, game_state):
    if game_state == GameStates.PLAYERS_TURN:
        return handle_player_turn_keys(key)
    elif game_state == GameStates.PLAYER_DEAD:
        return handle_player_dead_keys(key)
    elif game_state == GameStates.TARGETING:
        return handle_targeting_keys(key)
    elif game_state in (GameStates.SHOW_INVENTORY, GameStates.DROP_INVENTORY):
        return handle_inventory_keys(key)
    elif game_state == GameStates.LEVEL_UP:
        return handle_level_up_menu(key)
<span style="color:#a6e22e">+   elif game_state == GameStates.CHARACTER_SCREEN:
</span><span style="color:#a6e22e">+       return handle_character_screen(key)
</span><span style="color:#a6e22e"></span>
    return {}
</code></pre></div>

</div>
<div class="data-pane" data-pane="original">
  
<pre>def handle_keys(key, game_state):
    if game_state == GameStates.PLAYERS_TURN:
        return handle_player_turn_keys(key)
    elif game_state == GameStates.PLAYER_DEAD:
        return handle_player_dead_keys(key)
    elif game_state == GameStates.TARGETING:
        return handle_targeting_keys(key)
    elif game_state in (GameStates.SHOW_INVENTORY, GameStates.DROP_INVENTORY):
        return handle_inventory_keys(key)
    elif game_state == GameStates.LEVEL_UP:
        return handle_level_up_menu(key)
    <span class="new-text">elif game_state == GameStates.CHARACTER_SCREEN:
        return handle_character_screen(key)</span>

    return {}</pre>

</div>

</div>


<p>Si le joueur enfonce la touche Escape, nous retournons simplement à l&rsquo;état
précédent. Pour cela nous pouvons étendre notre code pour &lsquo;exit&rsquo;.</p>

<div>
  <button class="btn btn-primary data-toggle-tab active" data-toggle-tab="diff">
    Diff
  </button>
  <button class="btn btn-secondary data-toggle-tab" data-toggle-tab="original">
    Original
  </button>

   <div class="data-pane active" data-pane="diff">
   <div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-diff" data-lang="diff">        if exit:
<span style="color:#f92672">-           if game_state in (GameStates.SHOW_INVENTORY, GameStates.DROP_INVENTORY):
</span><span style="color:#f92672"></span><span style="color:#a6e22e">+           if game_state in (GameStates.SHOW_INVENTORY, GameStates.DROP_INVENTORY, GameStates.CHARACTER_SCREEN):
</span><span style="color:#a6e22e"></span>                game_state = previous_game_state
            elif game_state == GameStates.TARGETING:
                player_turn_results.append({&#39;targeting_cancelled&#39;: True})
            else:
                save_game(player, entities, game_map, message_log, game_state)

                return True
</code></pre></div>

</div>
<div class="data-pane" data-pane="original">
  
<pre>        if exit:
            if game_state in (GameStates.SHOW_INVENTORY, GameStates.DROP_INVENTORY<span class="new-text">, GameStates.CHARACTER_SCREEN</span>):
                game_state = previous_game_state
            elif game_state == GameStates.TARGETING:
                player_turn_results.append({'targeting_cancelled': True})
            else:
                save_game(player, entities, game_map, message_log, game_state)

                return True
</pre>

</div>

</div>


<p>Cela prend soin des saisies de l&rsquo;utilisateur. Maintenant pour afficher l&rsquo;écran
nous devons utiliser une nouvelle fonction. Contrairement aux autres fonctions
de menu, nous n&rsquo;affichons pas de liste d&rsquo;options. À la place nous savons
d&rsquo;emblée ce que nous voulons afficher. Aussi, on peut directement afficher
l&rsquo;information à l&rsquo;écran. Ouvrez <code>menus.py</code> et ajoutez la fonction suivante.</p>

<div>
  <button class="btn btn-primary data-toggle-tab active" data-toggle-tab="diff">
    Diff
  </button>
  <button class="btn btn-secondary data-toggle-tab" data-toggle-tab="original">
    Original
  </button>

   <div class="data-pane active" data-pane="diff">
   <div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-diff" data-lang="diff">def level_up_menu(con, header, player, menu_width, screen_width, screen_height):
    ...

<span style="color:#a6e22e">+def character_screen(player, character_screen_width, character_screen_height, screen_width, screen_height):
</span><span style="color:#a6e22e">+   window = libtcod.console_new(character_screen_width, character_screen_height)
</span><span style="color:#a6e22e">+
</span><span style="color:#a6e22e">+   libtcod.console_set_default_foreground(window, libtcod.white)
</span><span style="color:#a6e22e">+
</span><span style="color:#a6e22e">+   libtcod.console_print_rect_ex(window, 0, 1, character_screen_width, character_screen_height, libtcod.BKGND_NONE,
</span><span style="color:#a6e22e">+                                 libtcod.LEFT, &#39;Character Information&#39;)
</span><span style="color:#a6e22e">+   libtcod.console_print_rect_ex(window, 0, 2, character_screen_width, character_screen_height, libtcod.BKGND_NONE,
</span><span style="color:#a6e22e">+                                 libtcod.LEFT, &#39;Level: {0}&#39;.format(player.level.current_level))
</span><span style="color:#a6e22e">+   libtcod.console_print_rect_ex(window, 0, 3, character_screen_width, character_screen_height, libtcod.BKGND_NONE,
</span><span style="color:#a6e22e">+                                 libtcod.LEFT, &#39;Experience: {0}&#39;.format(player.level.current_xp))
</span><span style="color:#a6e22e">+   libtcod.console_print_rect_ex(window, 0, 4, character_screen_width, character_screen_height, libtcod.BKGND_NONE,
</span><span style="color:#a6e22e">+                                 libtcod.LEFT, &#39;Experience to Level: {0}&#39;.format(player.level.experience_to_next_level))
</span><span style="color:#a6e22e">+   libtcod.console_print_rect_ex(window, 0, 6, character_screen_width, character_screen_height, libtcod.BKGND_NONE,
</span><span style="color:#a6e22e">+                                 libtcod.LEFT, &#39;Maximum HP: {0}&#39;.format(player.fighter.max_hp))
</span><span style="color:#a6e22e">+   libtcod.console_print_rect_ex(window, 0, 7, character_screen_width, character_screen_height, libtcod.BKGND_NONE,
</span><span style="color:#a6e22e">+                                 libtcod.LEFT, &#39;Attack: {0}&#39;.format(player.fighter.power))
</span><span style="color:#a6e22e">+   libtcod.console_print_rect_ex(window, 0, 8, character_screen_width, character_screen_height, libtcod.BKGND_NONE,
</span><span style="color:#a6e22e">+                                 libtcod.LEFT, &#39;Defense: {0}&#39;.format(player.fighter.defense))
</span><span style="color:#a6e22e">+
</span><span style="color:#a6e22e">+   x = screen_width // 2 - character_screen_width // 2
</span><span style="color:#a6e22e">+   y = screen_height // 2 - character_screen_height // 2
</span><span style="color:#a6e22e">+   libtcod.console_blit(window, 0, 0, character_screen_width, character_screen_height, 0, x, y, 1.0, 0.7)
</span><span style="color:#a6e22e"></span>

def message_box(con, header, width, screen_width, screen_height):
    ...
</code></pre></div>

</div>
<div class="data-pane" data-pane="original">
  
<pre>def level_up_menu(con, header, player, menu_width, screen_width, screen_height):
    ...

<span class="new-text">def character_screen(player, character_screen_width, character_screen_height, screen_width, screen_height):
    window = libtcod.console_new(character_screen_width, character_screen_height)

    libtcod.console_set_default_foreground(window, libtcod.white)

    libtcod.console_print_rect_ex(window, 0, 1, character_screen_width, character_screen_height, libtcod.BKGND_NONE,
                                  libtcod.LEFT, 'Character Information')
    libtcod.console_print_rect_ex(window, 0, 2, character_screen_width, character_screen_height, libtcod.BKGND_NONE,
                                  libtcod.LEFT, 'Level: {0}'.format(player.level.current_level))
    libtcod.console_print_rect_ex(window, 0, 3, character_screen_width, character_screen_height, libtcod.BKGND_NONE,
                                  libtcod.LEFT, 'Experience: {0}'.format(player.level.current_xp))
    libtcod.console_print_rect_ex(window, 0, 4, character_screen_width, character_screen_height, libtcod.BKGND_NONE,
                                  libtcod.LEFT, 'Experience to Level: {0}'.format(player.level.experience_to_next_level))
    libtcod.console_print_rect_ex(window, 0, 6, character_screen_width, character_screen_height, libtcod.BKGND_NONE,
                                  libtcod.LEFT, 'Maximum HP: {0}'.format(player.fighter.max_hp))
    libtcod.console_print_rect_ex(window, 0, 7, character_screen_width, character_screen_height, libtcod.BKGND_NONE,
                                  libtcod.LEFT, 'Attack: {0}'.format(player.fighter.power))
    libtcod.console_print_rect_ex(window, 0, 8, character_screen_width, character_screen_height, libtcod.BKGND_NONE,
                                  libtcod.LEFT, 'Defense: {0}'.format(player.fighter.defense))

    x = screen_width // 2 - character_screen_width // 2
    y = screen_height // 2 - character_screen_height // 2
    libtcod.console_blit(window, 0, 0, character_screen_width, character_screen_height, 0, x, y, 1.0, 0.7)</span>


def message_box(con, header, width, screen_width, screen_height):
    ...
</pre>

</div>

</div>


<p>De manière à afficher ce nouveau menu, nous allons modifier <code>render_all</code> une
fois encore. Commencez par importer le menu.</p>

<div>
  <button class="btn btn-primary data-toggle-tab active" data-toggle-tab="diff">
    Diff
  </button>
  <button class="btn btn-secondary data-toggle-tab" data-toggle-tab="original">
    Original
  </button>

   <div class="data-pane active" data-pane="diff">
   <div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-diff" data-lang="diff">import tcod as libtcod

from enum import Enum

from game_states import GameStates

<span style="color:#f92672">-from menus import inventory_menu, level_up_menu
</span><span style="color:#f92672"></span><span style="color:#a6e22e">+from menus import character_screen, inventory_menu, level_up_menu
</span><span style="color:#a6e22e"></span>...
</code></pre></div>

</div>
<div class="data-pane" data-pane="original">
  
<pre>import tcod as libtcod

from enum import Enum

from game_states import GameStates

from menus import <span class="new-text">character_screen,</span> inventory_menu, level_up_menu
...
</pre>

</div>

</div>


<p>Maintenant, ajoutez le menu à la fin de <code>render_all</code>.</p>

<div>
  <button class="btn btn-primary data-toggle-tab active" data-toggle-tab="diff">
    Diff
  </button>
  <button class="btn btn-secondary data-toggle-tab" data-toggle-tab="original">
    Original
  </button>

   <div class="data-pane active" data-pane="diff">
   <div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-diff" data-lang="diff">    elif game_state == GameStates.LEVEL_UP:
        level_up_menu(con, &#39;Level up! Choose a stat to raise:&#39;, player, 40, screen_width, screen_height)

<span style="color:#a6e22e">+   elif game_state == GameStates.CHARACTER_SCREEN:
</span><span style="color:#a6e22e">+       character_screen(player, 30, 10, screen_width, screen_height)
</span></code></pre></div>

</div>
<div class="data-pane" data-pane="original">
  
<pre>    elif game_state == GameStates.LEVEL_UP:
        level_up_menu(con, 'Level up! Choose a stat to raise:', player, 40, screen_width, screen_height)

    <span class="new-text">elif game_state == GameStates.CHARACTER_SCREEN:
        character_screen(player, 30, 10, screen_width, screen_height)</span></pre>

</div>

</div>


<p>Dernière étape avant de conclure ce chapitre : bien plus tôt nous avons ajouté
les mouvement diagonaux pour le joueur mais nous avons oublié (okay <strong>j&rsquo;ai
oublié</strong>) d&rsquo;inclure une commande pour passer le tour. C&rsquo;est plutôt simple à
faire mais nous en aurons besoin avant le prochain chapitre où la difficulté va
augmenter. Ouvrez <code>input_handlers.py</code> et ajoutez ce qui suit à
<code>handle_player_turn_keys</code>.</p>

<div>
  <button class="btn btn-primary data-toggle-tab active" data-toggle-tab="diff">
    Diff
  </button>
  <button class="btn btn-secondary data-toggle-tab" data-toggle-tab="original">
    Original
  </button>

   <div class="data-pane active" data-pane="diff">
   <div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-diff" data-lang="diff">def handle_player_turn_keys(key):
    key_char = chr(key.c)

    if key.vk == libtcod.KEY_UP or key_char == &#39;k&#39;:
        return {&#39;move&#39;: (0, -1)}
    elif key.vk == libtcod.KEY_DOWN or key_char == &#39;j&#39;:
        return {&#39;move&#39;: (0, 1)}
    elif key.vk == libtcod.KEY_LEFT or key_char == &#39;h&#39;:
        return {&#39;move&#39;: (-1, 0)}
    elif key.vk == libtcod.KEY_RIGHT or key_char == &#39;l&#39;:
        return {&#39;move&#39;: (1, 0)}
    elif key_char == &#39;y&#39;:
        return {&#39;move&#39;: (-1, -1)}
    elif key_char == &#39;u&#39;:
        return {&#39;move&#39;: (1, -1)}
    elif key_char == &#39;b&#39;:
        return {&#39;move&#39;: (-1, 1)}
    elif key_char == &#39;n&#39;:
        return {&#39;move&#39;: (1, 1)}
<span style="color:#a6e22e">+   elif key_char == &#39;z&#39;:
</span><span style="color:#a6e22e">+       return {&#39;wait&#39;: True}
</span></code></pre></div>

</div>
<div class="data-pane" data-pane="original">
  
<pre>def handle_player_turn_keys(key):
    key_char = chr(key.c)

    if key.vk == libtcod.KEY_UP or key_char == 'k':
        return {'move': (0, -1)}
    elif key.vk == libtcod.KEY_DOWN or key_char == 'j':
        return {'move': (0, 1)}
    elif key.vk == libtcod.KEY_LEFT or key_char == 'h':
        return {'move': (-1, 0)}
    elif key.vk == libtcod.KEY_RIGHT or key_char == 'l':
        return {'move': (1, 0)}
    elif key_char == 'y':
        return {'move': (-1, -1)}
    elif key_char == 'u':
        return {'move': (1, -1)}
    elif key_char == 'b':
        return {'move': (-1, 1)}
    elif key_char == 'n':
        return {'move': (1, 1)}
    <span class="new-text">elif key_char == 'z':
        return {'wait': True}</span></pre>

</div>

</div>


<p>Maintenant dans <code>engine.py</code> :</p>

<div>
  <button class="btn btn-primary data-toggle-tab active" data-toggle-tab="diff">
    Diff
  </button>
  <button class="btn btn-secondary data-toggle-tab" data-toggle-tab="original">
    Original
  </button>

   <div class="data-pane active" data-pane="diff">
   <div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-diff" data-lang="diff">        move = action.get(&#39;move&#39;)
<span style="color:#a6e22e">+       wait = action.get(&#39;wait&#39;)
</span><span style="color:#a6e22e"></span>        pickup = action.get(&#39;pickup&#39;)
        ...

        if move and game_state == GameStates.PLAYERS_TURN:
            ...

<span style="color:#a6e22e">+       elif wait:
</span><span style="color:#a6e22e">+           game_state = GameStates.ENEMY_TURN
</span><span style="color:#a6e22e"></span>
        elif pickup and game_state == GameStates.PLAYERS_TURN:
            ...
</code></pre></div>

</div>
<div class="data-pane" data-pane="original">
  
<pre>        move = action.get('move')
        <span class="new-text">wait = action.get('wait')</span>
        pickup = action.get('pickup')
        ...

        if move and game_state == GameStates.PLAYERS_TURN:
            ...

        <span class="new-text">elif wait:
            game_state = GameStates.ENEMY_TURN</span>

        elif pickup and game_state == GameStates.PLAYERS_TURN:
            ...
</pre>

</div>

</div>


<p>Ainsi tout ce qu&rsquo;on fait est de &ldquo;passer&rdquo; le tour du joueur. Facile ! Vous
pourriez faire beaucoup de chose, comme ajouter 1 HP au joueur pour avoir
attendu mais je suis mauvais, et je ne pardonne pas aussi je ne le ferai pas.</p>

<p>C&rsquo;est tout pour ce chapitre. Nous avons donné au joueur beaucoup d&rsquo;avantages
(À vrai dire, ajouter un point en défense nous rend invulnérable devant les
Orcs&hellip;) mais cela va bientôt changer. Au prochain chapitre nous allons
améliorer les montres et <em>affaiblir</em> le joueur. C&rsquo;est un roguelike après tout,
ce n&rsquo;est pas supposé être facile.</p>

<p>Si vous voulez voir le code actuel entièrement, [cliquez ici](<a href="https://github.com/TStand90/roguelike_tutorial_revised/tree/part-11">https://github.com/TStand90/roguelike_tutorial_revised/tree/part-11</a>.</p>

<p><a href="/tutorials/tcod/part-12">Cliquez ici pour vous rendre à la partie suivante de ce tutoriel.</a></p>

<script src="/js/codetabs.js"></script>


    

    


</article>



        </div>

        <aside class="col-12 col-lg-3 ml-auto blog-sidebar">
    
    
        <section>
    
        
    
        
    
</section>
    
</aside>

      </div>
    </div>
    

    
      







<footer class="blog-footer w-100">
    <nav class="navbar navbar-light bg-light">
        <p class="w-100 text-center">Dernière mise à jour le 24 juillet 2019</p>
        <p class="w-100 text-center"><a href="#">Back to top</a></p>
    </nav>
</footer>

    

    
    
    <script src="https://code.jquery.com/jquery-3.3.1.slim.min.js" integrity="sha384-q8i/X+965DzO0rT7abK41JStQIAqVgRVzpbzo5smXKp4YfRvH+8abtTE1Pi6jizo" crossorigin="anonymous"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/popper.js/1.14.3/umd/popper.min.js" integrity="sha384-ZMP7rVo3mIykV+2+9J3UJ46jBk0WLaUAdn689aCwoqbBJiSnjAK/l8WvCWPIPm49" crossorigin="anonymous"></script>
    <script src="https://stackpath.bootstrapcdn.com/bootstrap/4.1.3/js/bootstrap.min.js" integrity="sha384-ChfqqxuZUCnJSK3+MXmPNIyE6ZbWh2IMqE241rYiqJxyMiZ6OW/JmZQ5stwEULTy" crossorigin="anonymous"></script>
  </body>
</html>
